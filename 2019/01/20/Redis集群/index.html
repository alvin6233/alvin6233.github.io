<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>redis集群 | alvin&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="redis" />
  
  
  
  
  <meta name="description" content="主从复制和哨兵模式，存在诸多问题，最主要的问题是存储能力受单机限制，写操作不能实现负载均衡。Redis3.0开始引入分布式存储方案，集群。集群由多个节点组成，节点分为主节点和从节点。主节点负载读写请求和集群信息的维护，从节点只进行主节点数据和信息的复制。集群的作用如下：  数据分区： 数据分区(或称数据分片)是集群最核心的功能。集群将数据分散到多个节点，一方面突破了Redis单机内存大小的限制，存">
<meta name="keywords" content="redis">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis集群">
<meta property="og:url" content="https://dongz.me/2019/01/20/Redis集群/index.html">
<meta property="og:site_name" content="alvin&#39;s blog">
<meta property="og:description" content="主从复制和哨兵模式，存在诸多问题，最主要的问题是存储能力受单机限制，写操作不能实现负载均衡。Redis3.0开始引入分布式存储方案，集群。集群由多个节点组成，节点分为主节点和从节点。主节点负载读写请求和集群信息的维护，从节点只进行主节点数据和信息的复制。集群的作用如下：  数据分区： 数据分区(或称数据分片)是集群最核心的功能。集群将数据分散到多个节点，一方面突破了Redis单机内存大小的限制，存">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/498077/201608/498077-20160822172408386-366341651.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1174710/201810/1174710-20181025213453407-302249562.png">
<meta property="og:updated_time" content="2019-01-20T14:21:47.002Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis集群">
<meta name="twitter:description" content="主从复制和哨兵模式，存在诸多问题，最主要的问题是存储能力受单机限制，写操作不能实现负载均衡。Redis3.0开始引入分布式存储方案，集群。集群由多个节点组成，节点分为主节点和从节点。主节点负载读写请求和集群信息的维护，从节点只进行主节点数据和信息的复制。集群的作用如下：  数据分区： 数据分区(或称数据分片)是集群最核心的功能。集群将数据分散到多个节点，一方面突破了Redis单机内存大小的限制，存">
<meta name="twitter:image" content="https://images2015.cnblogs.com/blog/498077/201608/498077-20160822172408386-366341651.png">
  
    <link rel="alternate" href="/atom.xml" title="alvin&#39;s blog" type="application/atom+xml">
  

  

  <link rel="icon" href="/css/images/mylogo.jpg">
  <link rel="apple-touch-icon" href="/css/images/mylogo.jpg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>
  <script src="/js/bootstrap.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >

  
    <link rel="stylesheet" href="/css/dialog.css">
  

  

  
    <link rel="stylesheet" href="/css/header-post.css" >
  

  
  
  
    <link rel="stylesheet" href="/css/vdonate.css" >
  

</head>



  <body data-spy="scroll" data-target="#toc" data-offset="50">


  
  <div id="container">
    <div id="wrap">
      
        <header>

    <div id="allheader" class="navbar navbar-default navbar-static-top" role="navigation">
        <div class="navbar-inner">
          
          <div class="container"> 
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>

            
              <a class="brand" style="
                 margin-top: 0px;"  
                href="#" data-toggle="modal" data-target="#myModal" >
                  <img width="124px" height="124px" alt="Hike News" src="/css/images/mylogo.jpg">
              </a>
            
            
            <div class="navbar-collapse collapse">
              <ul class="hnav navbar-nav">
                
                  <li> <a class="main-nav-link" href="/">首页</a> </li>
                
                  <li> <a class="main-nav-link" href="/archives">归档</a> </li>
                
                  <li> <a class="main-nav-link" href="/categories">分类</a> </li>
                
                  <li> <a class="main-nav-link" href="/tags">标签</a> </li>
                
                  <li> <a class="main-nav-link" href="/about">关于</a> </li>
                
                  <li><div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div></li>
            </div>
          </div>
                
      </div>
    </div>

</header>



      
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-Redis集群" style="width: 75%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      Redis集群
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/01/20/Redis集群/" class="article-date">
	  <time datetime="2019-01-20T14:20:00.000Z" itemprop="datePublished">2019-01-20</time>
	</a>

      
    <a class="article-category-link" href="/categories/数据存储/">数据存储</a>

      
	<a class="article-views">
	<span id="busuanzi_container_page_pv">
		阅读量<span id="busuanzi_value_page_pv"></span>
	</span>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>主从复制和哨兵模式，存在诸多问题，最主要的问题是存储能力受单机限制，写操作不能实现负载均衡。<br>Redis3.0开始引入分布式存储方案，集群。集群由多个节点组成，节点分为主节点和从节点。主节点负载读写请求和集群信息的维护，从节点只进行主节点数据和信息的复制。集群的作用如下：</p>
<ul>
<li><strong>数据分区：</strong> 数据分区(或称数据分片)是集群最核心的功能。集群将数据分散到多个节点，一方面突破了Redis单机内存大小的限制，存储容量大大增加；<br>另一方面每个主节点都可以对外提供读服务和写服务，大大提高了集群的响应能力。</li>
<li><strong>高可用：</strong> 集群支持主从复制和主节点的自动故障转移（与哨兵类似）；当任一节点发生故障时，集群仍然可以对外提供服务。  </li>
</ul>
<p>本文集群模式，包含3个主节点、3个从节点。<br><a id="more"></a></p>
<h2 id="Redis集群实战"><a href="#Redis集群实战" class="headerlink" title="Redis集群实战"></a>Redis集群实战</h2><h3 id="纯手工搭建"><a href="#纯手工搭建" class="headerlink" title="纯手工搭建"></a>纯手工搭建</h3><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>为方便理解，通过<code>hostname</code>命令将三个服务器重新命名。<br>172.16.6.242命名为server1；<br>172.16.6.243命名为server2；<br>172.16.6.244命名为server3；  </p>
<p>server1、server2、server3每台服务器启动两个Redis实例节点，6379端口对应实例为主节点，6380对应实例为从节点。6个节点构成3主3从的集群模式。  </p>
<h4 id="配置启动节点"><a href="#配置启动节点" class="headerlink" title="配置启动节点"></a>配置启动节点</h4><blockquote>
<p>在server1服务器上（server2和server3操作相同）：  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"># 创建redis目录，用于存储rdb文件和相关配置文件</span><br><span class="line">[root@server1 test1]# mkdir /redis</span><br><span class="line"></span><br><span class="line"># 创建主节点对应配置文件</span><br><span class="line">[root@server1 test1]# vim /redis/redis-6379.conf</span><br><span class="line">bind 0.0.0.0  </span><br><span class="line">port 6379</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file /redis/nodes-6379.conf</span><br><span class="line">protected-mode no</span><br><span class="line">daemonize yes</span><br><span class="line">logfile /var/log/redis/redis-6379.log</span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line">dir /var/lib/redis-6379</span><br><span class="line">requirepass ialvin</span><br><span class="line">masterauth ialvin</span><br><span class="line">dbfilename dump-6379.rdb</span><br><span class="line"></span><br><span class="line"># 创建从节点对应配置文件</span><br><span class="line">[root@server1 test1]# vim /redis/redis-6380.conf</span><br><span class="line">bind 0.0.0.0  </span><br><span class="line">port 6380</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file /redis/nodes-6380.conf</span><br><span class="line">protected-mode no</span><br><span class="line">daemonize yes</span><br><span class="line">logfile /var/log/redis/redis-6380.log</span><br><span class="line">pidfile /var/run/redis_6380.pid</span><br><span class="line">dir /redis/redis-6380</span><br><span class="line">requirepass ialvin</span><br><span class="line">masterauth ialvin</span><br><span class="line">dbfilename dump-6380.rdb</span><br><span class="line"></span><br><span class="line"># 创建主节点启动文件，并启动主节点</span><br><span class="line">[root@server1 ~]# cp -rp /usr/lib/systemd/system/redis.service /usr/lib/systemd/system/redis-6379.service</span><br><span class="line">[root@server1 ~]# vim /usr/lib/systemd/system/redis-6379.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=Redis persistent key-value database</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/bin/redis-server /redis/redis-6379.conf --supervised systemd</span><br><span class="line">ExecStop=/usr/libexec/redis-shutdown</span><br><span class="line">Type=notify</span><br><span class="line">User=redis</span><br><span class="line">Group=redis</span><br><span class="line">LimitNOFILE=65535</span><br><span class="line">RuntimeDirectory=redis</span><br><span class="line">RuntimeDirectoryMode=0755</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line">[root@server1 ~]# systemctl start redis-6379.service  # 启动主节点实例</span><br><span class="line">[root@server1 ~]# ps -ef|grep 6379  # 查看主节点已启动</span><br><span class="line">root       606 31798  0 23:22 pts/1    00:00:00 grep --color=auto 6379</span><br><span class="line">redis    30078     1  0 1月11 ?       00:05:21 /usr/bin/redis-server 0.0.0.0:6379 [cluster]</span><br><span class="line"></span><br><span class="line"># 创建从节点启动文件，并启动从节点</span><br><span class="line">[root@server1 ~]# cp -rp /usr/lib/systemd/system/redis.service /usr/lib/systemd/system/redis-6380.service</span><br><span class="line">[root@server1 ~]# vim /usr/lib/systemd/system/redis-6380.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=Redis persistent key-value database</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/bin/redis-server /redis/redis-6380.conf --supervised systemd</span><br><span class="line">ExecStop=/usr/libexec/redis-shutdown</span><br><span class="line">Type=notify</span><br><span class="line">User=redis</span><br><span class="line">Group=redis</span><br><span class="line">LimitNOFILE=65535</span><br><span class="line">RuntimeDirectory=redis</span><br><span class="line">RuntimeDirectoryMode=0755</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line">[root@server1 ~]# ps -ef|grep 6380   # 启动从节点实例</span><br><span class="line">root       805 31798  0 23:25 pts/1    00:00:00 grep --color=auto 6380</span><br><span class="line">redis    30100     1  0 1月11 ?       00:05:23 /usr/bin/redis-server 0.0.0.0:6380 [cluster]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意问题：  </p>
</blockquote>
<ol>
<li><p>Can’t chdir to ‘/redis/redis-6379’: No such file or directory<br>在配置文件中配置的dir，要手动创建<code>mkdir -p /redis/redis-6379</code>，用来存放数据库备份文件和临时文件。  </p>
</li>
<li><p>Server can’t set maximum open files to 10032 because of OS error: Operation not permitted.<br>意思进程当前需要打开10032个文件描述符，而当前系统进程可打开的最大文件描述符低于该值。通过<code>ulimit -n 65535</code>修改系统限制。  </p>
</li>
<li><p>Can’t open nodes-6379.conf in order to acquire a lock: Permission denied<br>没有nodes-6379.conf配置文件的读写权限，因为以redis用户启动服务，需要将权限授权给redis用户，这里通过更为文件所属用户和组<code>chown -R redis:redis /redis</code>。  </p>
</li>
<li><p>执行cluster meet ip port 进行节点握手后，cluster nodes只显示部分节点信息。<br>集群配置文件/redis/nodes-6379.conf，记录了集群中各个节点信息。每个节点的唯一id记录在该文件中，造成该问题的原因是复制了集群配置文件，导致不同节点有相同的id。<br>处理方式：关闭服务，将集群配置文件清空，重新启动服务。  </p>
</li>
</ol>
<h4 id="节点之间进行握手"><a href="#节点之间进行握手" class="headerlink" title="节点之间进行握手"></a>节点之间进行握手</h4><p>节点启动以后是相互独立的，并不知道其他节点存在；需要进行节点握手，将独立的节点组成一个网络。节点握手使用cluster meet {ip} {port}命令实现，以一个节点如server1的6379节点为中心，分别和另外5个节点<br>进行握手，其它节点之间会自动进行握手。如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 在server1 6379实例上操作，分别和另外5个节点握手</span><br><span class="line">127.0.0.1:6379&gt; cluster meet 172.16.6.242 6380</span><br><span class="line">127.0.0.1:6379&gt; cluster meet 172.16.6.243 6379</span><br><span class="line">127.0.0.1:6379&gt; cluster meet 172.16.6.243 6380</span><br><span class="line">127.0.0.1:6379&gt; cluster meet 172.16.6.244 6379</span><br><span class="line">127.0.0.1:6379&gt; cluster meet 172.16.6.244 6380</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; cluster nodes # 查看节点之间是否连接成功，connected表示连接成功</span><br><span class="line">24476a1e819364f13a8691eb1709aac5218c3d03 172.16.6.242:6380@16380 master - 0 1547189697000 1 connected</span><br><span class="line">8f4a0dbf53a4652779cdd0694fa7eead9b1b7cf8 172.16.6.244:6380@16380 master - 0 1547189698000 5 connected</span><br><span class="line">9c87a28d355b26615510f4c93fd928f221bcb5d2 172.16.6.244:6379@16379 master - 0 1547189699536 4 connected 10923-16383</span><br><span class="line">0f3567e025db95bc81608da49059d86a79fdf760 172.16.6.243:6380@16380 master - 0 1547189697530 2 connected</span><br><span class="line">b97e7281211f66a84b812a5257b223badee006ba 172.16.6.242:6379@16379 myself,master - 0 1547189693000 0 connected 0-5461</span><br><span class="line">805acf3e1f0e8cd771750739bc3d493d77136500 172.16.6.243:6379@16379 master - 0 1547189698533 3 connected 5462-10922</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">#### 分配槽</span><br><span class="line"></span><br><span class="line">集群有16384个槽，槽是数据管理和迁移的基本单位。当数据库中的16384个槽都分配了节点时，集群处于上线状态（ok）；如果有任意一个槽没有分配节点，则集群处于下线状态（fail）。  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"># 在server1 6379实例上操作，查看集群状态和已分配槽的数量。</span><br><span class="line">127.0.0.1:6379&gt; cluster info</span><br><span class="line">cluster_state:fail</span><br><span class="line">cluster_slots_assigned:0</span><br></pre></td></tr></table></figure>
<p>分配槽使用cluster addslots命令，执行下面的命令将槽（编号0-16383）全部分配完毕：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 在server1 6379实例上操作，分配槽</span><br><span class="line">[root@server1 ~]# redis-cli -p 6379  cluster addslots &#123;0..5461&#125;</span><br><span class="line">[root@server1 ~]# redis-cli -h 172.16.6.243  -p 6379 -a ialvin  cluster addslots &#123;5462..10922&#125;</span><br><span class="line">[root@server1 ~]# redis-cli -h 172.16.6.244  -p 6379 -a ialvin  cluster addslots &#123;10923..16383&#125;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; cluster info  # 查看集群状态和槽分配状态</span><br><span class="line">cluster_state:ok</span><br><span class="line">cluster_slots_assigned:16384</span><br><span class="line">cluster_slots_ok:16384</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br></pre></td></tr></table></figure>
<h4 id="建立主从关系"><a href="#建立主从关系" class="headerlink" title="建立主从关系"></a>建立主从关系</h4><p>集群中指定主从关系不再使用slaveof命令，而是使用cluster replicate命令；参数使用节点id。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 在server1 6379实例上操作，建立主从关系，cluster replicate后参数为主节点id</span><br><span class="line">[root@server1 ~]# redis-cli -p 6380 -a ialvin  cluster replicate b97e7281211f66a84b812a5257b223badee006ba</span><br><span class="line">[root@server1 ~]# redis-cli -h 172.16.6.243 -p 6380 -a ialvin  cluster replicate 805acf3e1f0e8cd771750739bc3d493d77136500</span><br><span class="line">[root@server1 ~]# redis-cli -h 172.16.6.244 -p 6380 -a ialvin  cluster replicate 9c87a28d355b26615510f4c93fd928f221bcb5d2</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; cluster nodes # 查看此时集群状态，可以看到三主三从节点组成</span><br><span class="line">24476a1e819364f13a8691eb1709aac5218c3d03 172.16.6.242:6380@16380 slave b97e7281211f66a84b812a5257b223badee006ba 0 1547190153747 1 connected</span><br><span class="line">8f4a0dbf53a4652779cdd0694fa7eead9b1b7cf8 172.16.6.244:6380@16380 slave 9c87a28d355b26615510f4c93fd928f221bcb5d2 0 1547190153000 5 connected</span><br><span class="line">9c87a28d355b26615510f4c93fd928f221bcb5d2 172.16.6.244:6379@16379 master - 0 1547190155750 4 connected 10923-16383</span><br><span class="line">0f3567e025db95bc81608da49059d86a79fdf760 172.16.6.243:6380@16380 slave 805acf3e1f0e8cd771750739bc3d493d77136500 0 1547190153000 3 connected</span><br><span class="line">b97e7281211f66a84b812a5257b223badee006ba 172.16.6.242:6379@16379 myself,master - 0 1547190155000 0 connected 0-5461</span><br><span class="line">805acf3e1f0e8cd771750739bc3d493d77136500 172.16.6.243:6379@16379 master - 0 1547190154749 3 connected 5462-10922</span><br></pre></td></tr></table></figure>
<h3 id="集群命令搭建"><a href="#集群命令搭建" class="headerlink" title="集群命令搭建"></a>集群命令搭建</h3><p>使用redis-cli –cluster create <ip:port> <ip:port> <ip:port> … 创建自动创建集群。  </ip:port></ip:port></ip:port></p>
<h4 id="启动节点，同手工方式"><a href="#启动节点，同手工方式" class="headerlink" title="启动节点，同手工方式"></a>启动节点，同手工方式</h4><h4 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h4><p>集群搭建过程如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 命令自动创建集群</span><br><span class="line">[root@server1 ~]# redis-cli --cluster create 172.16.6.242:6379 172.16.6.243:6379 172.16.6.244:6379 172.16.6.242:6380 172.16.6.243:6380 172.16.6.244:6380 --cluster-replicas 1</span><br></pre></td></tr></table></figure>
<p>其中：–cluster-replicas=1表示每个主节点有1个从节点；后面的多个{ip:port}表示节点地址，前面的做主节点，后面的做从节点。使用集群命令搭建集群时，要求节点不能包含任何槽和数据。  </p>
<h3 id="集群方案建议"><a href="#集群方案建议" class="headerlink" title="集群方案建议"></a>集群方案建议</h3><ol>
<li><p>高可用要求<br>根据故障转移的原理，至少需要3个主节点才能完成故障转移，且3个主节点不应在同一台物理机上；每个主节点至少需要1个从节点，且主从节点不应在一台物理机上；因此高可用集群至少包含6个节点。  </p>
</li>
<li><p>数据量和访问量<br>估算应用需要的数据量和总访问量(考虑业务发展，留有冗余)，结合每个主节点的容量和能承受的访问量(可以通过benchmark得到较准确估计)，计算需要的主节点数量。  </p>
</li>
<li><p>节点数量限制<br>Redis官方给出的节点数量限制为1000，主要是考虑节点间通信带来的消耗。在实际应用中应尽量避免大集群；如果节点数量不足以满足应用对Redis数据量和访问量的要求，可以考虑：(1)业务分割，大集群分为多个小集群；(2)减少不必要的数据；(3)调整数据过期策略等。  </p>
</li>
<li><p>适度冗余<br>Redis可以在不影响集群服务的情况下增加节点，因此节点数量适当冗余即可，不用太大。  </p>
</li>
</ol>
<h2 id="集群基本原理"><a href="#集群基本原理" class="headerlink" title="集群基本原理"></a>集群基本原理</h2><p>集群最核心的功能是数据分区，因此首先介绍数据的分区规则；然后介绍集群实现的细节：通信机制和数据结构；最后以cluster meet(节点握手)、cluster addslots(槽分配)为例，说明节点是如何利用上述数据结构和通信机制实现集群命令的。  </p>
<h3 id="数据分区方案"><a href="#数据分区方案" class="headerlink" title="数据分区方案"></a>数据分区方案</h3><p>数据分区有顺序分区、哈希分区等，其中哈希分区由于其天然的随机性，使用广泛。<br>哈希分区的基本思路是：对数据的特征值（如key）进行哈希，然后根据哈希值决定数据落在哪个节点。常见的哈希分区包括：哈希取余分区、一致性哈希分区、带虚拟节点的一致性哈希分区等。<br>衡量数据分区方法好坏的标准有很多，其中比较重要的两个因素是(1)数据分布是否均匀(2)增加或删减节点对数据分布的影响。由于哈希的随机性，哈希分区基本可以保证数据分布均匀；因此在比较哈希分区方案时，重点要看增减节点对数据分布的影响。  </p>
<h4 id="哈希取余分区"><a href="#哈希取余分区" class="headerlink" title="哈希取余分区"></a>哈希取余分区</h4><p>哈希取余分区思路非常简单：计算key的hash值，然后对节点数量进行取余，从而决定数据映射到哪个节点上。该方案最大的问题是，当新增或删减节点时，节点数量发生变化，系统中所有的数据都需要重新计算映射关系，引发大规模数据迁移。  </p>
<h4 id="一致性哈希分区"><a href="#一致性哈希分区" class="headerlink" title="一致性哈希分区"></a>一致性哈希分区</h4><p>一致性哈希算法将整个哈希值空间组织成一个虚拟的圆环，如下图所示，范围为0-2^32-1；对于每个数据，根据key计算hash值，确定数据在环上的位置，然后从此位置沿环顺时针行走，找到的第一台服务器就是其应该映射到的服务器。<br><img src="https://images2015.cnblogs.com/blog/498077/201608/498077-20160822172408386-366341651.png" alt=""> </p>
<p>与哈希取余分区相比，一致性哈希分区将增减节点的影响限制在相邻节点。以上图为例，如果在node1和node2之间增加node5，则只有node2中的一部分数据会迁移到node5；如果去掉node2，则原node2中的数据只会迁移到node4中，只有node4会受影响。<br>一致性哈希分区的主要问题在于，当节点数量较少时，增加或删减节点，对单个节点的影响可能很大，造成数据的严重不平衡。还是以上图为例，如果去掉node2，node4中的数据由总数据的1/4左右变为1/2左右，与其他节点相比负载过高。  </p>
<h4 id="带虚拟节点的一致性哈希分区"><a href="#带虚拟节点的一致性哈希分区" class="headerlink" title="带虚拟节点的一致性哈希分区"></a>带虚拟节点的一致性哈希分区</h4><p>该方案在一致性哈希分区的基础上，引入了虚拟节点的概念。Redis集群使用的便是该方案，其中的虚拟节点称为槽（slot）。槽是介于数据和实际节点之间的虚拟概念；每个实际节点包含一定数量的槽，每个槽包含哈希值在一定范围内的数据。引入槽以后，数据的映射关系由数据hash-&gt;实际节点，变成了数据hash-&gt;槽-&gt;实际节点。  </p>
<p>在使用了槽的一致性哈希分区中，槽是数据管理和迁移的基本单位。槽解耦了数据和实际节点之间的关系，增加或删除节点对系统的影响很小。仍以上图为例，系统中有4个实际节点，假设为其分配16个槽(0-15)； 槽0-3位于node1，4-7位于node2，以此类推。如果此时删除node2，只需要将槽4-7重新分配即可，例如槽4-5分配给node1，槽6分配给node3，槽7分配给node4；可以看出删除node2后，数据在其他节点的分布仍然较为均衡。  </p>
<p>槽的数量一般远小于2^32，远大于实际节点的数量；在Redis集群中，槽的数量为16384。  </p>
<p><img src="https://img2018.cnblogs.com/blog/1174710/201810/1174710-20181025213453407-302249562.png" alt=""> </p>
<p>1.Redis对数据的特征值（一般是key）计算哈希值，使用的算法是CRC16。  </p>
<p>2.根据哈希值，计算数据属于哪个槽。  </p>
<p>3.根据槽与节点的映射关系，计算数据属于哪个节点。  </p>
<h3 id="节点通信机制"><a href="#节点通信机制" class="headerlink" title="节点通信机制"></a>节点通信机制</h3><h4 id="两个端口"><a href="#两个端口" class="headerlink" title="两个端口"></a>两个端口</h4><p>在集群中，没有数据节点与非数据节点之分：所有的节点都存储数据，也都参与集群状态的维护。为此，集群中的每个节点，都提供了两个TCP端口：  </p>
<p><strong>普通端口：</strong> 即我们在前面指定的端口(6379等)。普通端口主要用于为客户端提供服务（与单机节点类似）；但在节点间数据迁移时也会使用。  </p>
<p><strong>集群端口：</strong> 端口号是普通端口+10000（10000是固定值，无法改变），如6379节点的集群端口为16379。集群端口只用于节点之间的通信，如搭建集群、增减节点、故障转移等操作时节点间的通信；不要使用客户端连接集群接口。为了保证集群可以正常工作，在配置防火墙时，要同时开启普通端口和集群端口。  </p>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>节点间通信，按照通信协议可以分为几种类型：单对单、广播、Gossip协议等。重点是广播和Gossip的对比。  </p>
<p>广播是指向集群内所有节点发送消息；优点是集群的收敛速度快(集群收敛是指集群内所有节点获得的集群信息是一致的)，缺点是每条消息都要发送给所有节点，CPU、带宽等消耗较大。  </p>
<p>Gossip协议的特点是：在节点数量有限的网络中，每个节点都“随机”的与部分节点通信（并不是真正的随机，而是根据特定的规则选择通信的节点），经过一番杂乱无章的通信，每个节点的状态很快会达到一致。Gossip协议的优点有负载(比广播)低、去中心化、容错性高(因为通信有冗余)等；缺点主要是集群的收敛速度慢。  </p>
<p>集群中的节点采用固定频率（每秒10次）的定时任务进行通信相关的工作：判断是否需要发送消息及消息类型、确定接收节点、发送消息等。如果集群状态发生了变化，如增减节点、槽状态变更，通过节点间的通信，所有节点会很快得知整个集群的状态，使集群收敛。</p>
<p>节点间发送的消息主要分为5种：meet消息、ping消息、pong消息、fail消息、publish消息。不同的消息类型，通信协议、发送的频率和时机、接收节点的选择等是不同的。</p>
<p><strong>MEET消息：</strong> 在节点握手阶段，当节点收到客户端的CLUSTER MEET命令时，会向新加入的节点发送MEET消息，请求新节点加入到当前集群；新节点收到MEET消息后会回复一个PONG消息。<br><strong>PING消息：</strong> 集群里每个节点每秒钟会选择部分节点发送PING消息，接收者收到消息后会回复一个PONG消息。PING消息的内容是自身节点和部分其他节点的状态信息；作用是彼此交换信息，以及检测节点是否在线。PING消息使用Gossip协议发送，接收节点的选择兼顾了收敛速度和带宽成本，具体规则如下：(1)随机找5个节点，在其中选择最久没有通信的1个节点(2)扫描节点列表，选择最近一次收到PONG消息时间大于cluster_node_timeout/2的所有节点，防止这些节点长时间未更新。<br><strong>PONG消息：</strong> PONG消息封装了自身状态数据。可以分为两种：第一种是在接到MEET/PING消息后回复的PONG消息；第二种是指节点向集群广播PONG消息，这样其他节点可以获知该节点的最新信息，例如故障恢复后新的主节点会广播PONG消息。<br><strong>FAIL消息：</strong> 当一个主节点判断另一个主节点进入FAIL状态时，会向集群广播这一FAIL消息；接收节点会将这一FAIL消息保存起来，便于后续的判断。<br><strong>PUBLISH消息：</strong> 节点收到PUBLISH命令后，会先执行该命令，然后向集群广播这一消息，接收节点也会执行该PUBLISH命令。  </p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>节点需要专门的数据结构来存储集群的状态。所谓集群的状态，是一个比较大的概念，包括：集群是否处于上线状态、集群中有哪些节点、节点是否可达、节点的主从状态、槽的分布……</p>
<p>节点为了存储集群状态而提供的数据结构中，最关键的是clusterNode和clusterState结构：前者记录了一个节点的状态，后者记录了集群作为一个整体的状态。  </p>
<h3 id="集群命令实现"><a href="#集群命令实现" class="headerlink" title="集群命令实现"></a>集群命令实现</h3><p>这一部分将以cluster meet(节点握手)、cluster addslots(槽分配)为例，说明节点是如何利用上述数据结构和通信机制实现集群命令的。</p>
<p>cluster meet<br>假设要向A节点发送cluster meet命令，将B节点加入到A所在的集群，则A节点收到命令后，执行的操作如下：</p>
<p>1)  A为B创建一个clusterNode结构，并将其添加到clusterState的nodes字典中</p>
<p>2)  A向B发送MEET消息</p>
<p>3)  B收到MEET消息后，会为A创建一个clusterNode结构，并将其添加到clusterState的nodes字典中</p>
<p>4)  B回复A一个PONG消息</p>
<p>5)  A收到B的PONG消息后，便知道B已经成功接收自己的MEET消息</p>
<p>6)  然后，A向B返回一个PING消息</p>
<p>7)  B收到A的PING消息后，便知道A已经成功接收自己的PONG消息，握手完成</p>
<p>8)  之后，A通过Gossip协议将B的信息广播给集群内其他节点，其他节点也会与B握手；一段时间后，集群收敛，B成为集群内的一个普通节点</p>
<p>通过上述过程可以发现，集群中两个节点的握手过程与TCP类似，都是三次握手：A向B发送MEET；B向A发送PONG；A向B发送PING。</p>
<p>cluster addslots<br>集群中槽的分配信息，存储在clusterNode的slots数组和clusterState的slots数组中，两个数组的结构前面已做介绍；二者的区别在于：前者存储的是该节点中分配了哪些槽，后者存储的是集群中所有槽分别分布在哪个节点。</p>
<p>cluster addslots命令接收一个槽或多个槽作为参数，例如在A节点上执行cluster addslots {0..10}命令，是将编号为0-10的槽分配给A节点，具体执行过程如下：</p>
<p>1)  遍历输入槽，检查它们是否都没有分配，如果有一个槽已分配，命令执行失败；方法是检查输入槽在clusterState.slots[]中对应的值是否为NULL。</p>
<p>2)  遍历输入槽，将其分配给节点A；方法是修改clusterNode.slots[]中对应的比特为1，以及clusterState.slots[]中对应的指针指向A节点</p>
<p>3)  A节点执行完成后，通过节点通信机制通知其他节点，所有节点都会知道0-10的槽分配给了A节点</p>
<h2 id="客户端访问集群"><a href="#客户端访问集群" class="headerlink" title="客户端访问集群"></a>客户端访问集群</h2><p>在集群中，数据分布在不同的节点中，客户端通过某节点访问数据时，数据可能不在该节点中；下面介绍集群是如何处理这个问题的。</p>
<ol>
<li>redis-cli<br>当节点收到redis-cli发来的命令(如set/get)时，过程如下：</li>
</ol>
<p>（1）计算key属于哪个槽：CRC16(key) &amp; 16383</p>
<p>集群提供的cluster keyslot命令也是使用上述公式实现</p>
<p>（2）判断key所在的槽是否在当前节点：假设key位于第i个槽，clusterState.slots[i]则指向了槽所在的节点，如果clusterState.slots[i]==clusterState.myself，说明槽在当前节点，可以直接在当前节点执行命令；否则，说明槽不在当前节点，则查询槽所在节点的地址(clusterState.slots[i].ip/port)，并将其包装到MOVED错误中返回给redis-cli。</p>
<p>（3）redis-cli收到MOVED错误后，根据返回的ip和port重新发送请求。</p>
<p>redis-cli通过-c指定了集群模式，如果没有指定，redis-cli无法处理MOVED错误。</p>
<ol>
<li>Smart客户端<br>redis-cli这一类客户端称为Dummy客户端，因为它们在执行命令前不知道数据在哪个节点，需要借助MOVED错误重新定向。与Dummy客户端相对应的是Smart客户端。</li>
</ol>
<p>Smart客户端（以Java的JedisCluster为例）的基本原理：</p>
<p>（1）JedisCluster初始化时，在内部维护slot-&gt;node的缓存，方法是连接任一节点，执行cluster slots命令，该命令返回如下所示：</p>
<p>（2）此外，JedisCluster为每个节点创建连接池(即JedisPool)。</p>
<p>（3）当执行命令时，JedisCluster根据key-&gt;slot-&gt;node选择需要连接的节点，发送命令。如果成功，则命令执行完毕。如果执行失败，则会随机选择其他节点进行重试，并在出现MOVED错误时，使用cluster slots重新同步slot-&gt;node的映射关系。</p>
<p>注意事项如下：</p>
<p>（1）JedisCluster中已经包含所有节点的连接池，因此JedisCluster要使用单例。</p>
<p>（2）客户端维护了slot-&gt;node映射关系以及为每个节点创建了连接池，当节点数量较多时，应注意客户端内存资源和连接资源的消耗。</p>
<p>（3）Jedis较新版本针对JedisCluster做了一些性能方面的优化，如cluster slots缓存更新和锁阻塞等方面的优化，应尽量使用2.8.2及以上版本的Jedis。</p>
<p><strong>参考：</strong>    </p>
<ol>
<li><a href="https://www.cnblogs.com/kismetv/p/9853040.html" target="_blank" rel="noopener">深入学习Redis（5）：集群</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      
        <div id="donation_div"></div>

<script src="/js/vdonate.js"></script>
<script>
var a = new Donate({
  title: '如果觉得我的文章对您有用，请随意打赏。您的支持将鼓励我继续创作!', // 可选参数，打赏标题
  btnText: '打赏支持', // 可选参数，打赏按钮文字
  el: document.getElementById('donation_div'),
  wechatImage: 'https://raw.githubusercontent.com/alvin6233/alvin6233.github.io/master/css/images/WechatPay.png',
  alipayImage: 'https://raw.githubusercontent.com/alvin6233/alvin6233.github.io/master/css/images/AliPay.png'
});
</script>
      
      
      <div>
        <ul class="post-copyright">
          <li class="post-copyright-author">
          <strong>本文作者:  </strong>alvin dong</a>
          </li>
          <li class="post-copyright-link">
          <strong>本文链接:  </strong>
          <a href="/2019/01/20/Redis集群/" target="_blank" title="Redis集群">https://dongz.me/2019/01/20/Redis集群/</a>
          </li>
          <li class="post-copyright-license">
            <strong>版权声明:   </strong>
            本博客所有文章除特别声明外，均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
            许可协议。转载请注明出处
          </li>
         
        </ul>
<div>

      
      
        
	<div id="comment">
		<!-- 来必力City版安装代码 -->
		<div id="lv-container" data-id="city" data-uid="MTAyMC8yOTQ4MS82MDQ5">
		<script type="text/javascript">
		   (function(d, s) {
		       var j, e = d.getElementsByTagName(s)[0];

		       if (typeof LivereTower === 'function') { return; }

		       j = d.createElement(s);
		       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
		       j.async = true;

		       e.parentNode.insertBefore(j, e);
		   })(document, 'script');
		</script>
		<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
		</div>
		<!-- City版安装代码已完成 -->
	</div>



      
      

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/01/20/mysql实现分布式锁/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          mysql实现分布式锁
        
      </div>
    </a>
  
  
    <a href="/2019/01/06/Redis哨兵/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">Redis哨兵</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="toc-sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis集群实战"><span class="nav-number">1.</span> <span class="nav-text">Redis集群实战</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#纯手工搭建"><span class="nav-number">1.1.</span> <span class="nav-text">纯手工搭建</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#准备"><span class="nav-number">1.1.1.</span> <span class="nav-text">准备</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#配置启动节点"><span class="nav-number">1.1.2.</span> <span class="nav-text">配置启动节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#节点之间进行握手"><span class="nav-number">1.1.3.</span> <span class="nav-text">节点之间进行握手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#建立主从关系"><span class="nav-number">1.1.4.</span> <span class="nav-text">建立主从关系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集群命令搭建"><span class="nav-number">1.2.</span> <span class="nav-text">集群命令搭建</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#启动节点，同手工方式"><span class="nav-number">1.2.1.</span> <span class="nav-text">启动节点，同手工方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#集群搭建"><span class="nav-number">1.2.2.</span> <span class="nav-text">集群搭建</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集群方案建议"><span class="nav-number">1.3.</span> <span class="nav-text">集群方案建议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集群基本原理"><span class="nav-number">2.</span> <span class="nav-text">集群基本原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据分区方案"><span class="nav-number">2.1.</span> <span class="nav-text">数据分区方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#哈希取余分区"><span class="nav-number">2.1.1.</span> <span class="nav-text">哈希取余分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一致性哈希分区"><span class="nav-number">2.1.2.</span> <span class="nav-text">一致性哈希分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#带虚拟节点的一致性哈希分区"><span class="nav-number">2.1.3.</span> <span class="nav-text">带虚拟节点的一致性哈希分区</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#节点通信机制"><span class="nav-number">2.2.</span> <span class="nav-text">节点通信机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#两个端口"><span class="nav-number">2.2.1.</span> <span class="nav-text">两个端口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#协议"><span class="nav-number">2.3.</span> <span class="nav-text">协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构"><span class="nav-number">2.4.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集群命令实现"><span class="nav-number">2.5.</span> <span class="nav-text">集群命令实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#客户端访问集群"><span class="nav-number">3.</span> <span class="nav-text">客户端访问集群</span></a></li></ol>
    
    </div>
  </aside>

</section>
        
      </div>
      
      <footer id="footer">
  

  <div class="container">
      	<div class="row">
	      <p> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/iTimeTraveler/hexo-theme-hiker" target="_blank">Hexo-theme-hiker</a> </p>
	      <p id="copyRightEn">Copyright &copy; 2013 - 2019 alvin&#39;s blog All Rights Reserved.</p>
	      
	      
    		<p class="busuanzi_uv">
				访客数 : <span id="busuanzi_value_site_uv"></span> |  
				访问量 : <span id="busuanzi_value_site_pv"></span>
		    </p>
  		   
		</div>

		
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");
    var allheader = document.getElementById("allheader");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    if (allheader != null) {
      contentdiv.style.minHeight = document.body.offsetHeight - allheader.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    } else {
      contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    }
</script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">home</a>
  
    <a href="/archives" class="mobile-nav-link">archives</a>
  
    <a href="/categories" class="mobile-nav-link">categories</a>
  
    <a href="/tags" class="mobile-nav-link">tags</a>
  
    <a href="/about" class="mobile-nav-link">about</a>
  
</nav> -->
    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/scripts.js"></script>




  <script src="/js/dialog.js"></script>








	<div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="myModalLabel">设置</h2>
      </div>
      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">


      <div class="modal-body">
          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" onclick="javascript:setFontSize();" aria-expanded="true" aria-controls="collapseOne">
              正文字号大小
            </a>
          </div>
          <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
          <div class="panel-body">
            您已调整页面字体大小
          </div>
        </div>
      


          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" onclick="javascript:setBackground();" aria-expanded="true" aria-controls="collapseTwo">
              夜间护眼模式
            </a>
        </div>
          <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
          <div class="panel-body">
            夜间模式已经开启，再次单击按钮即可关闭 
          </div>
        </div>

        <div>
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="true" aria-controls="collapseThree">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关 于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
        </div>
         <div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
          <div class="panel-body">
            alvin&#39;s blog
          </div>
          <div class="panel-body">
            Copyright © 2019 alvin dong All Rights Reserved.
          </div>
        </div>
      </div>


      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <div class="modal-footer">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
      </div>
    </div>
  </div>
</div>
  
  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
  
    <a id="menu-switch"><i class="fa fa-bars fa-lg"></i></a>
  
</body>
</html>