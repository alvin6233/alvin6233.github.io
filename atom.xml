<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>alvin&#39;s blog</title>
  
  <subtitle>Good memory is worse than bad writing</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dongz.me/"/>
  <updated>2019-01-20T14:29:38.030Z</updated>
  <id>https://dongz.me/</id>
  
  <author>
    <name>alvin dong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>zookeeper集群搭建</title>
    <link href="https://dongz.me/2019/01/20/zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <id>https://dongz.me/2019/01/20/zookeeper集群搭建/</id>
    <published>2019-01-20T14:25:00.000Z</published>
    <updated>2019-01-20T14:29:38.030Z</updated>
    
    <content type="html"><![CDATA[<p>zookeeper是一个高效的分布式协调服务，可以提供配置信息管理、命名、分布式同步、集群管理、数据库切换等服务。它不适合用来存储大量信息，可以用来存储一些配置、发布与订阅等少量信息。<br>hadoop、storm、消息中间件、rpc服务框架、分布式数据库同步系统，这些都是zookeeper的应用场景。</p><p>zookeeper集群中节点个数一般为奇数个（&gt;=3），若集群中主节点挂掉，剩余节点个数在半数以上时，就可以推举新的主节点，继续对外提供服务。</p><a id="more"></a><h2 id="为啥子2n-1"><a href="#为啥子2n-1" class="headerlink" title="为啥子2n+1"></a>为啥子2n+1</h2><p>zookeeper集群正常提供服务的前提是：有过半的服务可用。所以服务节点数必须为为<code>2n+1</code>，就不会发生服务器恰好一半可用一半不可用的情况。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server1 ~]# cd /opt</span><br><span class="line">[root@server1 opt]# wget http://apache.01link.hk/zookeeper/stable/zookeeper-3.4.12.tar.gz</span><br><span class="line"></span><br><span class="line"># server2、server3同上，也可利用scp从server1复制</span><br></pre></td></tr></table></figure><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server1 opt]# tar -zxvf zookeeper-3.4.12.tar.gz </span><br><span class="line">[root@server3 opt]# mv zookeeper-3.4.12 zookeeper</span><br><span class="line"></span><br><span class="line"># server2、server3同上</span><br></pre></td></tr></table></figure><h3 id="依赖条件准备"><a href="#依赖条件准备" class="headerlink" title="依赖条件准备"></a>依赖条件准备</h3><blockquote><p>检查jdk是否安装</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@server1 opt]# java -version </span><br><span class="line">openjdk version &quot;1.8.0_121&quot;</span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0_121-b13)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.121-b13, mixed mode)</span><br><span class="line"></span><br><span class="line"># server2、server3同上</span><br></pre></td></tr></table></figure><blockquote><p>防火墙检查</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@server1 opt]# firewall-cmd --state  # 检查防火墙是否开启</span><br><span class="line">not running</span><br></pre></td></tr></table></figure><p>若开启，开放端口：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@server1 opt]# firewall-cmd --zone=public --add-port=2181/tcp --permanent</span><br><span class="line">[root@server1 opt]# firewall-cmd --zone=public --add-port=2888/tcp --permanent</span><br><span class="line">[root@server1 opt]# firewall-cmd --zone=public --add-port=3888/tcp --permanent</span><br><span class="line">[root@server1 opt]# firewall-cmd --complete-reload</span><br><span class="line"></span><br><span class="line"># server2、server3同上</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@server1 opt]# cd zookeeper/conf</span><br><span class="line">[root@server1 conf]# mv zoo_sample.cfg zoo.cfg</span><br><span class="line">[root@server1 conf]# vi zoo.cfg</span><br><span class="line">dataDir=/opt/zookeeper/data  # 数据存储位置，提前创建好;</span><br><span class="line">server.1=172.16.6.242:2888:3888   # 2888为心跳端口，3888为选举端口</span><br><span class="line">server.2=172.16.6.243:2888:3888</span><br><span class="line">server.3=172.16.6.244:2888:3888</span><br><span class="line"></span><br><span class="line"># server2、server3同上</span><br></pre></td></tr></table></figure><h3 id="创建myid文件"><a href="#创建myid文件" class="headerlink" title="创建myid文件"></a>创建myid文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@server1 conf]# cd /opt/zookeeper/data</span><br><span class="line">[root@server1 data]# echo 1 &gt; myid</span><br><span class="line"></span><br><span class="line"># server2</span><br><span class="line">[root@server2 data]# echo 2 &gt; myid</span><br><span class="line"></span><br><span class="line"># server3</span><br><span class="line">[root@server3 data]# echo 3 &gt; myid</span><br></pre></td></tr></table></figure><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@server1 data]# cd /opt/zookeeper/bin/</span><br><span class="line">[root@server1 bin]# ./zkServer.sh start</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/zookeeper/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br><span class="line"></span><br><span class="line"># 查看集群状态</span><br><span class="line">[root@server1 bin]# ./zkServer.sh status # 集群未就绪</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/zookeeper/bin/../conf/zoo.cfg</span><br><span class="line">Error contacting service. It is probably not running.</span><br><span class="line"></span><br><span class="line"># server2、server3节点依次启动后 从server1查看</span><br><span class="line">[root@server1 bin]# ./zkServer.sh status</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/zookeeper/bin/../conf/zoo.cfg</span><br><span class="line">Mode: follower  # 从节点</span><br><span class="line"></span><br><span class="line"># 从server2查看</span><br><span class="line">[root@server2 bin]# ./zkServer.sh status</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/zookeeper/bin/../conf/zoo.cfg</span><br><span class="line">Mode: leader  # 自动被选举为主节点</span><br><span class="line"></span><br><span class="line"># 从server3查看</span><br><span class="line">[root@server3 bin]# ./zkServer.sh status</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/zookeeper/bin/../conf/zoo.cfg</span><br><span class="line">Mode: follower  # 从节点</span><br></pre></td></tr></table></figure><blockquote><p>至此搭建结束，整个过程比较简单，自动实现选举功能。</p></blockquote><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/ZooKeeper.md" target="_blank" rel="noopener">详细了解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;zookeeper是一个高效的分布式协调服务，可以提供配置信息管理、命名、分布式同步、集群管理、数据库切换等服务。它不适合用来存储大量信息，可以用来存储一些配置、发布与订阅等少量信息。&lt;br&gt;hadoop、storm、消息中间件、rpc服务框架、分布式数据库同步系统，这些都是zookeeper的应用场景。&lt;/p&gt;
&lt;p&gt;zookeeper集群中节点个数一般为奇数个（&amp;gt;=3），若集群中主节点挂掉，剩余节点个数在半数以上时，就可以推举新的主节点，继续对外提供服务。&lt;/p&gt;
    
    </summary>
    
      <category term="数据存储" scheme="https://dongz.me/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="zookeeper" scheme="https://dongz.me/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>mysql实现分布式锁</title>
    <link href="https://dongz.me/2019/01/20/mysql%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>https://dongz.me/2019/01/20/mysql实现分布式锁/</id>
    <published>2019-01-20T14:22:00.000Z</published>
    <updated>2019-01-20T14:24:48.293Z</updated>
    
    <content type="html"><![CDATA[<p>为了保证一个方法或者属性在高并发情况下的同一时间只能被同一个线程执行，在传统单机应用单机部署的情况下，可以使用java并发锁如ReentrantLock或Synchronized。<br>但是随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效。<br>为了解决这个问题，就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题。本文主要讲讲通过数据库如何实现分布式锁。<br><a id="more"></a></p><h2 id="分布式锁应具备条件"><a href="#分布式锁应具备条件" class="headerlink" title="分布式锁应具备条件"></a>分布式锁应具备条件</h2><ul><li>在分布式系统环境下，一个方法在同一时间只能被一个机器的的一个线程执行；  </li><li>高可用的获取锁与释放锁；  </li><li>高性能的获取锁与释放锁；  </li><li>具备可重入特性；  </li><li>具备锁失效机制，防止死锁；  </li><li>具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。  </li></ul><h2 id="基于数据库的实现"><a href="#基于数据库的实现" class="headerlink" title="基于数据库的实现"></a>基于数据库的实现</h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>在数据库中创建一个表，表中包含资源字段，并在资源字段上创建唯一索引，想要使用某个资源，就使用这个资源向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。  </p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><h4 id="建锁表"><a href="#建锁表" class="headerlink" title="建锁表"></a>建锁表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">drop table if exists tb_lock;</span><br><span class="line">create table tb_lock(</span><br><span class="line">id int primary key auto_increment comment &apos;主键&apos;,</span><br><span class="line">source_id varchar(64) not null comment &apos;资源id&apos;,</span><br><span class="line">owner_id varchar(64) not null comment &apos;资源占有者id&apos;,</span><br><span class="line">state int default 0 comment &apos;线程重入次数&apos;,</span><br><span class="line">dead_time long comment &apos;失效时间&apos;,</span><br><span class="line">update_time long not null comment &apos;更新时间&apos;,</span><br><span class="line">description varchar(100) comment &apos;说明&apos;,</span><br><span class="line">unique key `uidx_source_id` (`source_id`) using btree</span><br><span class="line">)ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COMMENT=&apos;分布式锁表&apos;;</span><br></pre></td></tr></table></figure><p>id：自增可传递空值。<br>source_id：资源可能是方法、对象等，若为方法可以设置为方法名；若为对象可以设置为对象id或对象其它唯一标示。<br>owner_id：可根据规则 <code>ip+threadId</code>即服务器ip和线程id生成唯一标示。<br>dead_time：根据 <code>System.nanoTime() + TimeUnit.MILLISECONDS.toNanos(lockTimeOut)</code>计算得出。<br>update_time：记录更新时间为 <code>System.nanoTime()</code>。<br>state：设置为1，表示第一次进入锁。<br>description：锁描述。  </p><h4 id="锁定资源"><a href="#锁定资源" class="headerlink" title="锁定资源"></a>锁定资源</h4><p>设计方法 <code>boolean tryLock(String sourceId, long lockTimeOut)</code>，实现对资源sourceId的锁定，lockTimeOut为锁保持的最长有效期，可为空，为空代表永久持有锁直到主动释放锁。<br>方法实现具体步骤：  </p><ol><li>根据资源id查询是否资源被占用</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tb_lock where source_id = &lt;id&gt;</span><br></pre></td></tr></table></figure><ol><li>若返回结果为空，说明资源未被占用，当前线程执行插入资源占用数据。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 插入数据库资源行记录sql</span><br><span class="line">insert into tb_lock</span><br><span class="line">(`id`,</span><br><span class="line">`source_id`,</span><br><span class="line">`owner_id`,</span><br><span class="line">`state`,</span><br><span class="line">`dead_time`,</span><br><span class="line">`update_time`,</span><br><span class="line">`description`)</span><br><span class="line">VALUES</span><br><span class="line">(&lt;&#123;id: &#125;&gt;,</span><br><span class="line">&lt;&#123;source_id: &#125;&gt;,</span><br><span class="line">&lt;&#123;owner_id: &#125;&gt;,</span><br><span class="line">&lt;&#123;state: 0&#125;&gt;,</span><br><span class="line">&lt;&#123;dead_time: &#125;&gt;,</span><br><span class="line">&lt;&#123;update_time: &#125;&gt;,</span><br><span class="line">&lt;&#123;description: &#125;&gt;);</span><br></pre></td></tr></table></figure><ol><li>若返回记录，说明资源已被占用。  </li></ol><p>查看记录<code>owner_id</code>，若相等说明属于锁重入，<code>state</code>加1操作：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tb_lock set state = state + 1 where id = &lt;id&gt;</span><br></pre></td></tr></table></figure><p>若不相等说明资源已被其他线程占用，返回false。  </p><blockquote><p>注意：以上操作要放在同一事务中处理，利用数据库行锁中的排他锁，保证原子性。  </p></blockquote><h4 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h4><p>设计方法<code>boolean unLock(String sourceId)</code>，释放资源<code>sourceId</code>。  </p><p>方法实现具体步骤：  </p><p>判断state值是否为0，若为执行：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from tb_lock where id = &lt;id&gt;</span><br></pre></td></tr></table></figure><p>若不为0，执行：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tb_lock set state = state - 1 where id = &lt;id&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注意：以上操作同样要放到事务中保证原子性。 </p></blockquote><h3 id="缺点及不足"><a href="#缺点及不足" class="headerlink" title="缺点及不足"></a>缺点及不足</h3><ol><li><p>实例中锁属于非阻塞的，即获取锁失败就立刻返回。可以通过循环，指定循环次数或时间进行重试操作，直到成功。  </p></li><li><p>数据库存在单点问题，可以搭建主从结构优化。</p></li><li><p>连接池容易被打满、事务超时、行锁升级表锁等问题难以解决。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了保证一个方法或者属性在高并发情况下的同一时间只能被同一个线程执行，在传统单机应用单机部署的情况下，可以使用java并发锁如ReentrantLock或Synchronized。&lt;br&gt;但是随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效。&lt;br&gt;为了解决这个问题，就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题。本文主要讲讲通过数据库如何实现分布式锁。&lt;br&gt;
    
    </summary>
    
      <category term="分布式" scheme="https://dongz.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式锁" scheme="https://dongz.me/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Redis集群</title>
    <link href="https://dongz.me/2019/01/20/Redis%E9%9B%86%E7%BE%A4/"/>
    <id>https://dongz.me/2019/01/20/Redis集群/</id>
    <published>2019-01-20T14:20:00.000Z</published>
    <updated>2019-01-20T14:21:47.002Z</updated>
    
    <content type="html"><![CDATA[<p>主从复制和哨兵模式，存在诸多问题，最主要的问题是存储能力受单机限制，写操作不能实现负载均衡。<br>Redis3.0开始引入分布式存储方案，集群。集群由多个节点组成，节点分为主节点和从节点。主节点负载读写请求和集群信息的维护，从节点只进行主节点数据和信息的复制。集群的作用如下：</p><ul><li><strong>数据分区：</strong> 数据分区(或称数据分片)是集群最核心的功能。集群将数据分散到多个节点，一方面突破了Redis单机内存大小的限制，存储容量大大增加；<br>另一方面每个主节点都可以对外提供读服务和写服务，大大提高了集群的响应能力。</li><li><strong>高可用：</strong> 集群支持主从复制和主节点的自动故障转移（与哨兵类似）；当任一节点发生故障时，集群仍然可以对外提供服务。  </li></ul><p>本文集群模式，包含3个主节点、3个从节点。<br><a id="more"></a></p><h2 id="Redis集群实战"><a href="#Redis集群实战" class="headerlink" title="Redis集群实战"></a>Redis集群实战</h2><h3 id="纯手工搭建"><a href="#纯手工搭建" class="headerlink" title="纯手工搭建"></a>纯手工搭建</h3><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>为方便理解，通过<code>hostname</code>命令将三个服务器重新命名。<br>172.16.6.242命名为server1；<br>172.16.6.243命名为server2；<br>172.16.6.244命名为server3；  </p><p>server1、server2、server3每台服务器启动两个Redis实例节点，6379端口对应实例为主节点，6380对应实例为从节点。6个节点构成3主3从的集群模式。  </p><h4 id="配置启动节点"><a href="#配置启动节点" class="headerlink" title="配置启动节点"></a>配置启动节点</h4><blockquote><p>在server1服务器上（server2和server3操作相同）：  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"># 创建redis目录，用于存储rdb文件和相关配置文件</span><br><span class="line">[root@server1 test1]# mkdir /redis</span><br><span class="line"></span><br><span class="line"># 创建主节点对应配置文件</span><br><span class="line">[root@server1 test1]# vim /redis/redis-6379.conf</span><br><span class="line">bind 0.0.0.0  </span><br><span class="line">port 6379</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file /redis/nodes-6379.conf</span><br><span class="line">protected-mode no</span><br><span class="line">daemonize yes</span><br><span class="line">logfile /var/log/redis/redis-6379.log</span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line">dir /var/lib/redis-6379</span><br><span class="line">requirepass ialvin</span><br><span class="line">masterauth ialvin</span><br><span class="line">dbfilename dump-6379.rdb</span><br><span class="line"></span><br><span class="line"># 创建从节点对应配置文件</span><br><span class="line">[root@server1 test1]# vim /redis/redis-6380.conf</span><br><span class="line">bind 0.0.0.0  </span><br><span class="line">port 6380</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file /redis/nodes-6380.conf</span><br><span class="line">protected-mode no</span><br><span class="line">daemonize yes</span><br><span class="line">logfile /var/log/redis/redis-6380.log</span><br><span class="line">pidfile /var/run/redis_6380.pid</span><br><span class="line">dir /redis/redis-6380</span><br><span class="line">requirepass ialvin</span><br><span class="line">masterauth ialvin</span><br><span class="line">dbfilename dump-6380.rdb</span><br><span class="line"></span><br><span class="line"># 创建主节点启动文件，并启动主节点</span><br><span class="line">[root@server1 ~]# cp -rp /usr/lib/systemd/system/redis.service /usr/lib/systemd/system/redis-6379.service</span><br><span class="line">[root@server1 ~]# vim /usr/lib/systemd/system/redis-6379.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=Redis persistent key-value database</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/bin/redis-server /redis/redis-6379.conf --supervised systemd</span><br><span class="line">ExecStop=/usr/libexec/redis-shutdown</span><br><span class="line">Type=notify</span><br><span class="line">User=redis</span><br><span class="line">Group=redis</span><br><span class="line">LimitNOFILE=65535</span><br><span class="line">RuntimeDirectory=redis</span><br><span class="line">RuntimeDirectoryMode=0755</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line">[root@server1 ~]# systemctl start redis-6379.service  # 启动主节点实例</span><br><span class="line">[root@server1 ~]# ps -ef|grep 6379  # 查看主节点已启动</span><br><span class="line">root       606 31798  0 23:22 pts/1    00:00:00 grep --color=auto 6379</span><br><span class="line">redis    30078     1  0 1月11 ?       00:05:21 /usr/bin/redis-server 0.0.0.0:6379 [cluster]</span><br><span class="line"></span><br><span class="line"># 创建从节点启动文件，并启动从节点</span><br><span class="line">[root@server1 ~]# cp -rp /usr/lib/systemd/system/redis.service /usr/lib/systemd/system/redis-6380.service</span><br><span class="line">[root@server1 ~]# vim /usr/lib/systemd/system/redis-6380.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=Redis persistent key-value database</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/bin/redis-server /redis/redis-6380.conf --supervised systemd</span><br><span class="line">ExecStop=/usr/libexec/redis-shutdown</span><br><span class="line">Type=notify</span><br><span class="line">User=redis</span><br><span class="line">Group=redis</span><br><span class="line">LimitNOFILE=65535</span><br><span class="line">RuntimeDirectory=redis</span><br><span class="line">RuntimeDirectoryMode=0755</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line">[root@server1 ~]# ps -ef|grep 6380   # 启动从节点实例</span><br><span class="line">root       805 31798  0 23:25 pts/1    00:00:00 grep --color=auto 6380</span><br><span class="line">redis    30100     1  0 1月11 ?       00:05:23 /usr/bin/redis-server 0.0.0.0:6380 [cluster]</span><br></pre></td></tr></table></figure><blockquote><p>注意问题：  </p></blockquote><ol><li><p>Can’t chdir to ‘/redis/redis-6379’: No such file or directory<br>在配置文件中配置的dir，要手动创建<code>mkdir -p /redis/redis-6379</code>，用来存放数据库备份文件和临时文件。  </p></li><li><p>Server can’t set maximum open files to 10032 because of OS error: Operation not permitted.<br>意思进程当前需要打开10032个文件描述符，而当前系统进程可打开的最大文件描述符低于该值。通过<code>ulimit -n 65535</code>修改系统限制。  </p></li><li><p>Can’t open nodes-6379.conf in order to acquire a lock: Permission denied<br>没有nodes-6379.conf配置文件的读写权限，因为以redis用户启动服务，需要将权限授权给redis用户，这里通过更为文件所属用户和组<code>chown -R redis:redis /redis</code>。  </p></li><li><p>执行cluster meet ip port 进行节点握手后，cluster nodes只显示部分节点信息。<br>集群配置文件/redis/nodes-6379.conf，记录了集群中各个节点信息。每个节点的唯一id记录在该文件中，造成该问题的原因是复制了集群配置文件，导致不同节点有相同的id。<br>处理方式：关闭服务，将集群配置文件清空，重新启动服务。  </p></li></ol><h4 id="节点之间进行握手"><a href="#节点之间进行握手" class="headerlink" title="节点之间进行握手"></a>节点之间进行握手</h4><p>节点启动以后是相互独立的，并不知道其他节点存在；需要进行节点握手，将独立的节点组成一个网络。节点握手使用cluster meet {ip} {port}命令实现，以一个节点如server1的6379节点为中心，分别和另外5个节点<br>进行握手，其它节点之间会自动进行握手。如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 在server1 6379实例上操作，分别和另外5个节点握手</span><br><span class="line">127.0.0.1:6379&gt; cluster meet 172.16.6.242 6380</span><br><span class="line">127.0.0.1:6379&gt; cluster meet 172.16.6.243 6379</span><br><span class="line">127.0.0.1:6379&gt; cluster meet 172.16.6.243 6380</span><br><span class="line">127.0.0.1:6379&gt; cluster meet 172.16.6.244 6379</span><br><span class="line">127.0.0.1:6379&gt; cluster meet 172.16.6.244 6380</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; cluster nodes # 查看节点之间是否连接成功，connected表示连接成功</span><br><span class="line">24476a1e819364f13a8691eb1709aac5218c3d03 172.16.6.242:6380@16380 master - 0 1547189697000 1 connected</span><br><span class="line">8f4a0dbf53a4652779cdd0694fa7eead9b1b7cf8 172.16.6.244:6380@16380 master - 0 1547189698000 5 connected</span><br><span class="line">9c87a28d355b26615510f4c93fd928f221bcb5d2 172.16.6.244:6379@16379 master - 0 1547189699536 4 connected 10923-16383</span><br><span class="line">0f3567e025db95bc81608da49059d86a79fdf760 172.16.6.243:6380@16380 master - 0 1547189697530 2 connected</span><br><span class="line">b97e7281211f66a84b812a5257b223badee006ba 172.16.6.242:6379@16379 myself,master - 0 1547189693000 0 connected 0-5461</span><br><span class="line">805acf3e1f0e8cd771750739bc3d493d77136500 172.16.6.243:6379@16379 master - 0 1547189698533 3 connected 5462-10922</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">#### 分配槽</span><br><span class="line"></span><br><span class="line">集群有16384个槽，槽是数据管理和迁移的基本单位。当数据库中的16384个槽都分配了节点时，集群处于上线状态（ok）；如果有任意一个槽没有分配节点，则集群处于下线状态（fail）。  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"># 在server1 6379实例上操作，查看集群状态和已分配槽的数量。</span><br><span class="line">127.0.0.1:6379&gt; cluster info</span><br><span class="line">cluster_state:fail</span><br><span class="line">cluster_slots_assigned:0</span><br></pre></td></tr></table></figure><p>分配槽使用cluster addslots命令，执行下面的命令将槽（编号0-16383）全部分配完毕：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 在server1 6379实例上操作，分配槽</span><br><span class="line">[root@server1 ~]# redis-cli -p 6379  cluster addslots &#123;0..5461&#125;</span><br><span class="line">[root@server1 ~]# redis-cli -h 172.16.6.243  -p 6379 -a ialvin  cluster addslots &#123;5462..10922&#125;</span><br><span class="line">[root@server1 ~]# redis-cli -h 172.16.6.244  -p 6379 -a ialvin  cluster addslots &#123;10923..16383&#125;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; cluster info  # 查看集群状态和槽分配状态</span><br><span class="line">cluster_state:ok</span><br><span class="line">cluster_slots_assigned:16384</span><br><span class="line">cluster_slots_ok:16384</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br></pre></td></tr></table></figure><h4 id="建立主从关系"><a href="#建立主从关系" class="headerlink" title="建立主从关系"></a>建立主从关系</h4><p>集群中指定主从关系不再使用slaveof命令，而是使用cluster replicate命令；参数使用节点id。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 在server1 6379实例上操作，建立主从关系，cluster replicate后参数为主节点id</span><br><span class="line">[root@server1 ~]# redis-cli -p 6380 -a ialvin  cluster replicate b97e7281211f66a84b812a5257b223badee006ba</span><br><span class="line">[root@server1 ~]# redis-cli -h 172.16.6.243 -p 6380 -a ialvin  cluster replicate 805acf3e1f0e8cd771750739bc3d493d77136500</span><br><span class="line">[root@server1 ~]# redis-cli -h 172.16.6.244 -p 6380 -a ialvin  cluster replicate 9c87a28d355b26615510f4c93fd928f221bcb5d2</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; cluster nodes # 查看此时集群状态，可以看到三主三从节点组成</span><br><span class="line">24476a1e819364f13a8691eb1709aac5218c3d03 172.16.6.242:6380@16380 slave b97e7281211f66a84b812a5257b223badee006ba 0 1547190153747 1 connected</span><br><span class="line">8f4a0dbf53a4652779cdd0694fa7eead9b1b7cf8 172.16.6.244:6380@16380 slave 9c87a28d355b26615510f4c93fd928f221bcb5d2 0 1547190153000 5 connected</span><br><span class="line">9c87a28d355b26615510f4c93fd928f221bcb5d2 172.16.6.244:6379@16379 master - 0 1547190155750 4 connected 10923-16383</span><br><span class="line">0f3567e025db95bc81608da49059d86a79fdf760 172.16.6.243:6380@16380 slave 805acf3e1f0e8cd771750739bc3d493d77136500 0 1547190153000 3 connected</span><br><span class="line">b97e7281211f66a84b812a5257b223badee006ba 172.16.6.242:6379@16379 myself,master - 0 1547190155000 0 connected 0-5461</span><br><span class="line">805acf3e1f0e8cd771750739bc3d493d77136500 172.16.6.243:6379@16379 master - 0 1547190154749 3 connected 5462-10922</span><br></pre></td></tr></table></figure><h3 id="集群命令搭建"><a href="#集群命令搭建" class="headerlink" title="集群命令搭建"></a>集群命令搭建</h3><p>使用redis-cli –cluster create <ip:port> <ip:port> <ip:port> … 创建自动创建集群。  </ip:port></ip:port></ip:port></p><h4 id="启动节点，同手工方式"><a href="#启动节点，同手工方式" class="headerlink" title="启动节点，同手工方式"></a>启动节点，同手工方式</h4><h4 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h4><p>集群搭建过程如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 命令自动创建集群</span><br><span class="line">[root@server1 ~]# redis-cli --cluster create 172.16.6.242:6379 172.16.6.243:6379 172.16.6.244:6379 172.16.6.242:6380 172.16.6.243:6380 172.16.6.244:6380 --cluster-replicas 1</span><br></pre></td></tr></table></figure><p>其中：–cluster-replicas=1表示每个主节点有1个从节点；后面的多个{ip:port}表示节点地址，前面的做主节点，后面的做从节点。使用集群命令搭建集群时，要求节点不能包含任何槽和数据。  </p><h3 id="集群方案建议"><a href="#集群方案建议" class="headerlink" title="集群方案建议"></a>集群方案建议</h3><ol><li><p>高可用要求<br>根据故障转移的原理，至少需要3个主节点才能完成故障转移，且3个主节点不应在同一台物理机上；每个主节点至少需要1个从节点，且主从节点不应在一台物理机上；因此高可用集群至少包含6个节点。  </p></li><li><p>数据量和访问量<br>估算应用需要的数据量和总访问量(考虑业务发展，留有冗余)，结合每个主节点的容量和能承受的访问量(可以通过benchmark得到较准确估计)，计算需要的主节点数量。  </p></li><li><p>节点数量限制<br>Redis官方给出的节点数量限制为1000，主要是考虑节点间通信带来的消耗。在实际应用中应尽量避免大集群；如果节点数量不足以满足应用对Redis数据量和访问量的要求，可以考虑：(1)业务分割，大集群分为多个小集群；(2)减少不必要的数据；(3)调整数据过期策略等。  </p></li><li><p>适度冗余<br>Redis可以在不影响集群服务的情况下增加节点，因此节点数量适当冗余即可，不用太大。  </p></li></ol><h2 id="集群基本原理"><a href="#集群基本原理" class="headerlink" title="集群基本原理"></a>集群基本原理</h2><p>集群最核心的功能是数据分区，因此首先介绍数据的分区规则；然后介绍集群实现的细节：通信机制和数据结构；最后以cluster meet(节点握手)、cluster addslots(槽分配)为例，说明节点是如何利用上述数据结构和通信机制实现集群命令的。  </p><h3 id="数据分区方案"><a href="#数据分区方案" class="headerlink" title="数据分区方案"></a>数据分区方案</h3><p>数据分区有顺序分区、哈希分区等，其中哈希分区由于其天然的随机性，使用广泛。<br>哈希分区的基本思路是：对数据的特征值（如key）进行哈希，然后根据哈希值决定数据落在哪个节点。常见的哈希分区包括：哈希取余分区、一致性哈希分区、带虚拟节点的一致性哈希分区等。<br>衡量数据分区方法好坏的标准有很多，其中比较重要的两个因素是(1)数据分布是否均匀(2)增加或删减节点对数据分布的影响。由于哈希的随机性，哈希分区基本可以保证数据分布均匀；因此在比较哈希分区方案时，重点要看增减节点对数据分布的影响。  </p><h4 id="哈希取余分区"><a href="#哈希取余分区" class="headerlink" title="哈希取余分区"></a>哈希取余分区</h4><p>哈希取余分区思路非常简单：计算key的hash值，然后对节点数量进行取余，从而决定数据映射到哪个节点上。该方案最大的问题是，当新增或删减节点时，节点数量发生变化，系统中所有的数据都需要重新计算映射关系，引发大规模数据迁移。  </p><h4 id="一致性哈希分区"><a href="#一致性哈希分区" class="headerlink" title="一致性哈希分区"></a>一致性哈希分区</h4><p>一致性哈希算法将整个哈希值空间组织成一个虚拟的圆环，如下图所示，范围为0-2^32-1；对于每个数据，根据key计算hash值，确定数据在环上的位置，然后从此位置沿环顺时针行走，找到的第一台服务器就是其应该映射到的服务器。<br><img src="https://images2015.cnblogs.com/blog/498077/201608/498077-20160822172408386-366341651.png" alt=""> </p><p>与哈希取余分区相比，一致性哈希分区将增减节点的影响限制在相邻节点。以上图为例，如果在node1和node2之间增加node5，则只有node2中的一部分数据会迁移到node5；如果去掉node2，则原node2中的数据只会迁移到node4中，只有node4会受影响。<br>一致性哈希分区的主要问题在于，当节点数量较少时，增加或删减节点，对单个节点的影响可能很大，造成数据的严重不平衡。还是以上图为例，如果去掉node2，node4中的数据由总数据的1/4左右变为1/2左右，与其他节点相比负载过高。  </p><h4 id="带虚拟节点的一致性哈希分区"><a href="#带虚拟节点的一致性哈希分区" class="headerlink" title="带虚拟节点的一致性哈希分区"></a>带虚拟节点的一致性哈希分区</h4><p>该方案在一致性哈希分区的基础上，引入了虚拟节点的概念。Redis集群使用的便是该方案，其中的虚拟节点称为槽（slot）。槽是介于数据和实际节点之间的虚拟概念；每个实际节点包含一定数量的槽，每个槽包含哈希值在一定范围内的数据。引入槽以后，数据的映射关系由数据hash-&gt;实际节点，变成了数据hash-&gt;槽-&gt;实际节点。  </p><p>在使用了槽的一致性哈希分区中，槽是数据管理和迁移的基本单位。槽解耦了数据和实际节点之间的关系，增加或删除节点对系统的影响很小。仍以上图为例，系统中有4个实际节点，假设为其分配16个槽(0-15)； 槽0-3位于node1，4-7位于node2，以此类推。如果此时删除node2，只需要将槽4-7重新分配即可，例如槽4-5分配给node1，槽6分配给node3，槽7分配给node4；可以看出删除node2后，数据在其他节点的分布仍然较为均衡。  </p><p>槽的数量一般远小于2^32，远大于实际节点的数量；在Redis集群中，槽的数量为16384。  </p><p><img src="https://img2018.cnblogs.com/blog/1174710/201810/1174710-20181025213453407-302249562.png" alt=""> </p><p>1.Redis对数据的特征值（一般是key）计算哈希值，使用的算法是CRC16。  </p><p>2.根据哈希值，计算数据属于哪个槽。  </p><p>3.根据槽与节点的映射关系，计算数据属于哪个节点。  </p><h3 id="节点通信机制"><a href="#节点通信机制" class="headerlink" title="节点通信机制"></a>节点通信机制</h3><h4 id="两个端口"><a href="#两个端口" class="headerlink" title="两个端口"></a>两个端口</h4><p>在集群中，没有数据节点与非数据节点之分：所有的节点都存储数据，也都参与集群状态的维护。为此，集群中的每个节点，都提供了两个TCP端口：  </p><p><strong>普通端口：</strong> 即我们在前面指定的端口(6379等)。普通端口主要用于为客户端提供服务（与单机节点类似）；但在节点间数据迁移时也会使用。  </p><p><strong>集群端口：</strong> 端口号是普通端口+10000（10000是固定值，无法改变），如6379节点的集群端口为16379。集群端口只用于节点之间的通信，如搭建集群、增减节点、故障转移等操作时节点间的通信；不要使用客户端连接集群接口。为了保证集群可以正常工作，在配置防火墙时，要同时开启普通端口和集群端口。  </p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>节点间通信，按照通信协议可以分为几种类型：单对单、广播、Gossip协议等。重点是广播和Gossip的对比。  </p><p>广播是指向集群内所有节点发送消息；优点是集群的收敛速度快(集群收敛是指集群内所有节点获得的集群信息是一致的)，缺点是每条消息都要发送给所有节点，CPU、带宽等消耗较大。  </p><p>Gossip协议的特点是：在节点数量有限的网络中，每个节点都“随机”的与部分节点通信（并不是真正的随机，而是根据特定的规则选择通信的节点），经过一番杂乱无章的通信，每个节点的状态很快会达到一致。Gossip协议的优点有负载(比广播)低、去中心化、容错性高(因为通信有冗余)等；缺点主要是集群的收敛速度慢。  </p><p>集群中的节点采用固定频率（每秒10次）的定时任务进行通信相关的工作：判断是否需要发送消息及消息类型、确定接收节点、发送消息等。如果集群状态发生了变化，如增减节点、槽状态变更，通过节点间的通信，所有节点会很快得知整个集群的状态，使集群收敛。</p><p>节点间发送的消息主要分为5种：meet消息、ping消息、pong消息、fail消息、publish消息。不同的消息类型，通信协议、发送的频率和时机、接收节点的选择等是不同的。</p><p><strong>MEET消息：</strong> 在节点握手阶段，当节点收到客户端的CLUSTER MEET命令时，会向新加入的节点发送MEET消息，请求新节点加入到当前集群；新节点收到MEET消息后会回复一个PONG消息。<br><strong>PING消息：</strong> 集群里每个节点每秒钟会选择部分节点发送PING消息，接收者收到消息后会回复一个PONG消息。PING消息的内容是自身节点和部分其他节点的状态信息；作用是彼此交换信息，以及检测节点是否在线。PING消息使用Gossip协议发送，接收节点的选择兼顾了收敛速度和带宽成本，具体规则如下：(1)随机找5个节点，在其中选择最久没有通信的1个节点(2)扫描节点列表，选择最近一次收到PONG消息时间大于cluster_node_timeout/2的所有节点，防止这些节点长时间未更新。<br><strong>PONG消息：</strong> PONG消息封装了自身状态数据。可以分为两种：第一种是在接到MEET/PING消息后回复的PONG消息；第二种是指节点向集群广播PONG消息，这样其他节点可以获知该节点的最新信息，例如故障恢复后新的主节点会广播PONG消息。<br><strong>FAIL消息：</strong> 当一个主节点判断另一个主节点进入FAIL状态时，会向集群广播这一FAIL消息；接收节点会将这一FAIL消息保存起来，便于后续的判断。<br><strong>PUBLISH消息：</strong> 节点收到PUBLISH命令后，会先执行该命令，然后向集群广播这一消息，接收节点也会执行该PUBLISH命令。  </p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>节点需要专门的数据结构来存储集群的状态。所谓集群的状态，是一个比较大的概念，包括：集群是否处于上线状态、集群中有哪些节点、节点是否可达、节点的主从状态、槽的分布……</p><p>节点为了存储集群状态而提供的数据结构中，最关键的是clusterNode和clusterState结构：前者记录了一个节点的状态，后者记录了集群作为一个整体的状态。  </p><h3 id="集群命令实现"><a href="#集群命令实现" class="headerlink" title="集群命令实现"></a>集群命令实现</h3><p>这一部分将以cluster meet(节点握手)、cluster addslots(槽分配)为例，说明节点是如何利用上述数据结构和通信机制实现集群命令的。</p><p>cluster meet<br>假设要向A节点发送cluster meet命令，将B节点加入到A所在的集群，则A节点收到命令后，执行的操作如下：</p><p>1)  A为B创建一个clusterNode结构，并将其添加到clusterState的nodes字典中</p><p>2)  A向B发送MEET消息</p><p>3)  B收到MEET消息后，会为A创建一个clusterNode结构，并将其添加到clusterState的nodes字典中</p><p>4)  B回复A一个PONG消息</p><p>5)  A收到B的PONG消息后，便知道B已经成功接收自己的MEET消息</p><p>6)  然后，A向B返回一个PING消息</p><p>7)  B收到A的PING消息后，便知道A已经成功接收自己的PONG消息，握手完成</p><p>8)  之后，A通过Gossip协议将B的信息广播给集群内其他节点，其他节点也会与B握手；一段时间后，集群收敛，B成为集群内的一个普通节点</p><p>通过上述过程可以发现，集群中两个节点的握手过程与TCP类似，都是三次握手：A向B发送MEET；B向A发送PONG；A向B发送PING。</p><p>cluster addslots<br>集群中槽的分配信息，存储在clusterNode的slots数组和clusterState的slots数组中，两个数组的结构前面已做介绍；二者的区别在于：前者存储的是该节点中分配了哪些槽，后者存储的是集群中所有槽分别分布在哪个节点。</p><p>cluster addslots命令接收一个槽或多个槽作为参数，例如在A节点上执行cluster addslots {0..10}命令，是将编号为0-10的槽分配给A节点，具体执行过程如下：</p><p>1)  遍历输入槽，检查它们是否都没有分配，如果有一个槽已分配，命令执行失败；方法是检查输入槽在clusterState.slots[]中对应的值是否为NULL。</p><p>2)  遍历输入槽，将其分配给节点A；方法是修改clusterNode.slots[]中对应的比特为1，以及clusterState.slots[]中对应的指针指向A节点</p><p>3)  A节点执行完成后，通过节点通信机制通知其他节点，所有节点都会知道0-10的槽分配给了A节点</p><h2 id="客户端访问集群"><a href="#客户端访问集群" class="headerlink" title="客户端访问集群"></a>客户端访问集群</h2><p>在集群中，数据分布在不同的节点中，客户端通过某节点访问数据时，数据可能不在该节点中；下面介绍集群是如何处理这个问题的。</p><ol><li>redis-cli<br>当节点收到redis-cli发来的命令(如set/get)时，过程如下：</li></ol><p>（1）计算key属于哪个槽：CRC16(key) &amp; 16383</p><p>集群提供的cluster keyslot命令也是使用上述公式实现</p><p>（2）判断key所在的槽是否在当前节点：假设key位于第i个槽，clusterState.slots[i]则指向了槽所在的节点，如果clusterState.slots[i]==clusterState.myself，说明槽在当前节点，可以直接在当前节点执行命令；否则，说明槽不在当前节点，则查询槽所在节点的地址(clusterState.slots[i].ip/port)，并将其包装到MOVED错误中返回给redis-cli。</p><p>（3）redis-cli收到MOVED错误后，根据返回的ip和port重新发送请求。</p><p>redis-cli通过-c指定了集群模式，如果没有指定，redis-cli无法处理MOVED错误。</p><ol><li>Smart客户端<br>redis-cli这一类客户端称为Dummy客户端，因为它们在执行命令前不知道数据在哪个节点，需要借助MOVED错误重新定向。与Dummy客户端相对应的是Smart客户端。</li></ol><p>Smart客户端（以Java的JedisCluster为例）的基本原理：</p><p>（1）JedisCluster初始化时，在内部维护slot-&gt;node的缓存，方法是连接任一节点，执行cluster slots命令，该命令返回如下所示：</p><p>（2）此外，JedisCluster为每个节点创建连接池(即JedisPool)。</p><p>（3）当执行命令时，JedisCluster根据key-&gt;slot-&gt;node选择需要连接的节点，发送命令。如果成功，则命令执行完毕。如果执行失败，则会随机选择其他节点进行重试，并在出现MOVED错误时，使用cluster slots重新同步slot-&gt;node的映射关系。</p><p>注意事项如下：</p><p>（1）JedisCluster中已经包含所有节点的连接池，因此JedisCluster要使用单例。</p><p>（2）客户端维护了slot-&gt;node映射关系以及为每个节点创建了连接池，当节点数量较多时，应注意客户端内存资源和连接资源的消耗。</p><p>（3）Jedis较新版本针对JedisCluster做了一些性能方面的优化，如cluster slots缓存更新和锁阻塞等方面的优化，应尽量使用2.8.2及以上版本的Jedis。</p><p><strong>参考：</strong>    </p><ol><li><a href="https://www.cnblogs.com/kismetv/p/9853040.html" target="_blank" rel="noopener">深入学习Redis（5）：集群</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主从复制和哨兵模式，存在诸多问题，最主要的问题是存储能力受单机限制，写操作不能实现负载均衡。&lt;br&gt;Redis3.0开始引入分布式存储方案，集群。集群由多个节点组成，节点分为主节点和从节点。主节点负载读写请求和集群信息的维护，从节点只进行主节点数据和信息的复制。集群的作用如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数据分区：&lt;/strong&gt; 数据分区(或称数据分片)是集群最核心的功能。集群将数据分散到多个节点，一方面突破了Redis单机内存大小的限制，存储容量大大增加；&lt;br&gt;另一方面每个主节点都可以对外提供读服务和写服务，大大提高了集群的响应能力。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高可用：&lt;/strong&gt; 集群支持主从复制和主节点的自动故障转移（与哨兵类似）；当任一节点发生故障时，集群仍然可以对外提供服务。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文集群模式，包含3个主节点、3个从节点。&lt;br&gt;
    
    </summary>
    
      <category term="数据存储" scheme="https://dongz.me/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="redis" scheme="https://dongz.me/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis哨兵</title>
    <link href="https://dongz.me/2019/01/06/Redis%E5%93%A8%E5%85%B5/"/>
    <id>https://dongz.me/2019/01/06/Redis哨兵/</id>
    <published>2019-01-06T04:24:00.000Z</published>
    <updated>2019-01-06T04:25:27.032Z</updated>
    
    <content type="html"><![CDATA[<p>哨兵在复制的基础上，哨兵实现了自动化的故障恢复。缺陷：写操作无法负载均衡；存储能力受到单机的限制。<br>Redis2.8引入哨兵，主要功能如下：</p><ul><li><strong>监控（Monitoring：</strong> 哨兵会不断地检查主节点和从节点是否运作正常。</li><li><strong>自动故障转移（Automatic failover）：</strong> 当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。</li><li><strong>配置提供者（Configuration provider）：</strong> 客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。</li><li><strong>通知（Notification）：</strong> 哨兵可以将故障转移的结果发送给客户端。</li></ul><p>本文哨兵系统，包含1个主节点、2个从节点和3个哨兵节点。<br><a id="more"></a></p><h2 id="高可用哨兵实战"><a href="#高可用哨兵实战" class="headerlink" title="高可用哨兵实战"></a>高可用哨兵实战</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>搭建主从复制集群，参考《主从复制实战》，包括master(172.16.6.242)、slave1(172.16.6.243)、slave2(172.16.6.244)。在此基础上，三个哨兵节点分散部署在每个主从复制Redis节点上。</p><h3 id="配置启动哨兵"><a href="#配置启动哨兵" class="headerlink" title="配置启动哨兵"></a>配置启动哨兵</h3><h4 id="主节点master上配置并启动哨兵节点"><a href="#主节点master上配置并启动哨兵节点" class="headerlink" title="主节点master上配置并启动哨兵节点"></a>主节点master上配置并启动哨兵节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# vim /etc/redis-sentinel.conf</span><br><span class="line">port 26379</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">dir /tmp</span><br><span class="line">sentinel monitor mymaster 172.16.6.242 6379 2</span><br><span class="line">sentinel auth-pass mymaster ialvin</span><br><span class="line">sentinel down-after-milliseconds mymaster 5000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line">logfile &quot;/var/log/redis/sentinel.log&quot;</span><br><span class="line"></span><br><span class="line">[root@master ~]# systemctl start redis-sentinel.service</span><br><span class="line">[root@master ~]# ss -ntl # 端口26379已开启</span><br><span class="line">State      Recv-Q Send-Q Local Address:Port               Peer Address:Port</span><br><span class="line">LISTEN     0      128          *:26379                    *:*</span><br><span class="line">LISTEN     0      128          *:6379                     *:*</span><br><span class="line">LISTEN     0      128          *:111                      *:*</span><br></pre></td></tr></table></figure><h4 id="从节点slave1和slave2配置并启动哨兵"><a href="#从节点slave1和slave2配置并启动哨兵" class="headerlink" title="从节点slave1和slave2配置并启动哨兵"></a>从节点slave1和slave2配置并启动哨兵</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# scp /etc/redis-sentinel.conf 172.16.6.243:/etc/     # 复制主节点哨兵配置文件到slave1；</span><br><span class="line">[root@master ~]# scp /etc/redis-sentinel.conf 172.16.6.243:/etc/     # 复制主节点哨兵配置文件到slave2；</span><br><span class="line"></span><br><span class="line"># 启动slave1上哨兵服务</span><br><span class="line">[root@slave1 ~]# systemctl start redis-sentinel.service</span><br><span class="line">[root@slave1 ~]# ss -ntl</span><br><span class="line">State      Recv-Q Send-Q Local Address:Port               Peer Address:Port</span><br><span class="line">LISTEN     0      128    172.16.6.243:7946                     *:*</span><br><span class="line">LISTEN     0      128          *:27018                    *:*</span><br><span class="line">LISTEN     0      128          *:26379                    *:*</span><br><span class="line">LISTEN     0      128          *:6379                     *:*</span><br><span class="line"></span><br><span class="line"># 启动slave2上哨兵服务</span><br><span class="line">[root@slave2 ~]# systemctl start redis-sentinel.service</span><br><span class="line">[root@slave2 ~]# ss -ntl</span><br><span class="line">State      Recv-Q Send-Q Local Address:Port               Peer Address:Port</span><br><span class="line">LISTEN     0      128          *:26379                    *:*</span><br><span class="line">LISTEN     0      128          *:6379                     *:*</span><br><span class="line">LISTEN     0      128          *:111                      *:*</span><br></pre></td></tr></table></figure><h4 id="从master节点上的哨兵查看相关信息"><a href="#从master节点上的哨兵查看相关信息" class="headerlink" title="从master节点上的哨兵查看相关信息"></a>从master节点上的哨兵查看相关信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# redis-cli -h 172.16.6.242 -p 26379      # 连接redis-sentinel，指定端口26379；</span><br><span class="line">172.16.6.242:26379&gt; sentinel masters                     # 通过哨兵查看主节点信息；</span><br><span class="line">1)  1) &quot;name&quot;</span><br><span class="line">    2) &quot;mymaster&quot;</span><br><span class="line">    3) &quot;ip&quot;</span><br><span class="line">    4) &quot;172.16.6.242&quot;</span><br><span class="line">    5) &quot;port&quot;</span><br><span class="line">    6) &quot;6379&quot;</span><br><span class="line">    7) &quot;runid&quot;</span><br><span class="line">    8) &quot;099f4715cadd5e7b204d510eda834d9aa584eb6f&quot;</span><br><span class="line">    9) &quot;flags&quot;</span><br><span class="line">   10) &quot;master&quot;</span><br><span class="line">   11) &quot;link-pending-commands&quot;</span><br><span class="line">   12) &quot;0&quot;</span><br><span class="line">   13) &quot;link-refcount&quot;</span><br><span class="line">   14) &quot;1&quot;</span><br><span class="line">   15) &quot;last-ping-sent&quot;</span><br><span class="line">   16) &quot;0&quot;</span><br><span class="line">   17) &quot;last-ok-ping-reply&quot;</span><br><span class="line">   18) &quot;304&quot;</span><br><span class="line">   19) &quot;last-ping-reply&quot;</span><br><span class="line">   20) &quot;304&quot;</span><br><span class="line">   21) &quot;down-after-milliseconds&quot;</span><br><span class="line">   22) &quot;30000&quot;</span><br><span class="line">   23) &quot;info-refresh&quot;</span><br><span class="line">   24) &quot;1610&quot;</span><br><span class="line">   25) &quot;role-reported&quot;</span><br><span class="line">   26) &quot;master&quot;</span><br><span class="line">   27) &quot;role-reported-time&quot;</span><br><span class="line">   28) &quot;59678249&quot;</span><br><span class="line">   29) &quot;config-epoch&quot;</span><br><span class="line">   30) &quot;0&quot;</span><br><span class="line">   31) &quot;num-slaves&quot;</span><br><span class="line">   32) &quot;2&quot;</span><br><span class="line">   33) &quot;num-other-sentinels&quot;</span><br><span class="line">   34) &quot;0&quot;</span><br><span class="line">   35) &quot;quorum&quot;</span><br><span class="line">   36) &quot;2&quot;</span><br><span class="line">   37) &quot;failover-timeout&quot;</span><br><span class="line">   38) &quot;180000&quot;</span><br><span class="line">   39) &quot;parallel-syncs&quot;</span><br><span class="line">   40) &quot;1&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">172.16.6.242:26379&gt; sentinel slaves mymaster                     # 通过哨兵查看主节点名称为mymaster对应的从节点；</span><br><span class="line">1)  1) &quot;name&quot;</span><br><span class="line">    2) &quot;172.16.6.244:6379&quot;</span><br><span class="line">    3) &quot;ip&quot;</span><br><span class="line">    4) &quot;172.16.6.244&quot;</span><br><span class="line">    5) &quot;port&quot;</span><br><span class="line">    6) &quot;6379&quot;</span><br><span class="line">    7) &quot;runid&quot;</span><br><span class="line">    8) &quot;5c34cdad4c9c8623bf5ebdf388d01d410e464fdc&quot;</span><br><span class="line">    9) &quot;flags&quot;</span><br><span class="line">   10) &quot;slave&quot;</span><br><span class="line">   11) &quot;link-pending-commands&quot;</span><br><span class="line">   12) &quot;0&quot;</span><br><span class="line">   13) &quot;link-refcount&quot;</span><br><span class="line">   14) &quot;1&quot;</span><br><span class="line">   15) &quot;last-ping-sent&quot;</span><br><span class="line">   16) &quot;0&quot;</span><br><span class="line">   17) &quot;last-ok-ping-reply&quot;</span><br><span class="line">   18) &quot;858&quot;</span><br><span class="line">   19) &quot;last-ping-reply&quot;</span><br><span class="line">   20) &quot;858&quot;</span><br><span class="line">   21) &quot;down-after-milliseconds&quot;</span><br><span class="line">   22) &quot;30000&quot;</span><br><span class="line">   23) &quot;info-refresh&quot;</span><br><span class="line">   24) &quot;1610&quot;</span><br><span class="line">   25) &quot;role-reported&quot;</span><br><span class="line">   26) &quot;slave&quot;</span><br><span class="line">   27) &quot;role-reported-time&quot;</span><br><span class="line">   28) &quot;59960910&quot;</span><br><span class="line">   29) &quot;master-link-down-time&quot;</span><br><span class="line">   30) &quot;0&quot;</span><br><span class="line">   31) &quot;master-link-status&quot;</span><br><span class="line">   32) &quot;ok&quot;</span><br><span class="line">   33) &quot;master-host&quot;</span><br><span class="line">   34) &quot;172.16.6.242&quot;</span><br><span class="line">   35) &quot;master-port&quot;</span><br><span class="line">   36) &quot;6379&quot;</span><br><span class="line">   37) &quot;slave-priority&quot;</span><br><span class="line">   38) &quot;100&quot;</span><br><span class="line">   39) &quot;slave-repl-offset&quot;</span><br><span class="line">   40) &quot;13193196&quot;</span><br><span class="line">2)  1) &quot;name&quot;</span><br><span class="line">    2) &quot;172.16.6.243:6379&quot;</span><br><span class="line">    3) &quot;ip&quot;</span><br><span class="line">    4) &quot;172.16.6.243&quot;</span><br><span class="line">    5) &quot;port&quot;</span><br><span class="line">    6) &quot;6379&quot;</span><br><span class="line">    7) &quot;runid&quot;</span><br><span class="line">    8) &quot;154d2e317cff5e0b1672f2b4f385b481ce560b55&quot;</span><br><span class="line">    9) &quot;flags&quot;</span><br><span class="line">   10) &quot;slave&quot;</span><br><span class="line">   11) &quot;link-pending-commands&quot;</span><br><span class="line">   12) &quot;0&quot;</span><br><span class="line">   13) &quot;link-refcount&quot;</span><br><span class="line">   14) &quot;1&quot;</span><br><span class="line">   15) &quot;last-ping-sent&quot;</span><br><span class="line">   16) &quot;0&quot;</span><br><span class="line">   17) &quot;last-ok-ping-reply&quot;</span><br><span class="line">   18) &quot;858&quot;</span><br><span class="line">   19) &quot;last-ping-reply&quot;</span><br><span class="line">   20) &quot;858&quot;</span><br><span class="line">   21) &quot;down-after-milliseconds&quot;</span><br><span class="line">   22) &quot;30000&quot;</span><br><span class="line">   23) &quot;info-refresh&quot;</span><br><span class="line">   24) &quot;1610&quot;</span><br><span class="line">   25) &quot;role-reported&quot;</span><br><span class="line">   26) &quot;slave&quot;</span><br><span class="line">   27) &quot;role-reported-time&quot;</span><br><span class="line">   28) &quot;59960909&quot;</span><br><span class="line">   29) &quot;master-link-down-time&quot;</span><br><span class="line">   30) &quot;0&quot;</span><br><span class="line">   31) &quot;master-link-status&quot;</span><br><span class="line">   32) &quot;ok&quot;</span><br><span class="line">   33) &quot;master-host&quot;</span><br><span class="line">   34) &quot;172.16.6.242&quot;</span><br><span class="line">   35) &quot;master-port&quot;</span><br><span class="line">   36) &quot;6379&quot;</span><br><span class="line">   37) &quot;slave-priority&quot;</span><br><span class="line">   38) &quot;100&quot;</span><br><span class="line">   39) &quot;slave-repl-offset&quot;</span><br><span class="line">   40) &quot;13193196&quot;</span><br></pre></td></tr></table></figure><h3 id="主节点故障转移测试"><a href="#主节点故障转移测试" class="headerlink" title="主节点故障转移测试"></a>主节点故障转移测试</h3><h4 id="模拟主节点master宕机"><a href="#模拟主节点master宕机" class="headerlink" title="模拟主节点master宕机"></a>模拟主节点master宕机</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# systemctl stop redis.service        # 停止主节点redis服务；</span><br><span class="line">[root@master ~]# ss -ntl        # 6379端口已关闭；</span><br><span class="line">State      Recv-Q Send-Q Local Address:Port               Peer Address:Port</span><br><span class="line">LISTEN     0      128          *:26379                    *:*</span><br><span class="line">LISTEN     0      128          *:111                      *:*</span><br><span class="line">LISTEN     0      128          *:22                       *:*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@master ~]# redis-cli -h 172.16.6.242 -p 26379  # 连接redis-sentinel，指定端口26379；</span><br><span class="line">172.16.6.242:26379&gt; sentinel masters             # 查看当前主节点相关信息；</span><br><span class="line">1)  1) &quot;name&quot;</span><br><span class="line">    2) &quot;mymaster&quot;</span><br><span class="line">    3) &quot;ip&quot;</span><br><span class="line">    4) &quot;172.16.6.243&quot;</span><br><span class="line">    5) &quot;port&quot;</span><br><span class="line">    6) &quot;6379&quot;</span><br><span class="line">    7) &quot;runid&quot;</span><br><span class="line">    8) &quot;154d2e317cff5e0b1672f2b4f385b481ce560b55&quot;</span><br><span class="line">    9) &quot;flags&quot;</span><br><span class="line">   10) &quot;master&quot;</span><br><span class="line">   11) &quot;link-pending-commands&quot;</span><br><span class="line">   12) &quot;0&quot;</span><br><span class="line">   13) &quot;link-refcount&quot;</span><br><span class="line">   14) &quot;1&quot;</span><br><span class="line">   15) &quot;last-ping-sent&quot;</span><br><span class="line">   16) &quot;0&quot;</span><br><span class="line">   17) &quot;last-ok-ping-reply&quot;</span><br><span class="line">   18) &quot;296&quot;</span><br><span class="line">   19) &quot;last-ping-reply&quot;</span><br><span class="line">   20) &quot;296&quot;</span><br><span class="line">   21) &quot;down-after-milliseconds&quot;</span><br><span class="line">   22) &quot;30000&quot;</span><br><span class="line">   23) &quot;info-refresh&quot;</span><br><span class="line">   24) &quot;357&quot;</span><br><span class="line">   25) &quot;role-reported&quot;</span><br><span class="line">   26) &quot;master&quot;</span><br><span class="line">   27) &quot;role-reported-time&quot;</span><br><span class="line">   28) &quot;71092&quot;</span><br><span class="line">   29) &quot;config-epoch&quot;</span><br><span class="line">   30) &quot;1&quot;</span><br><span class="line">   31) &quot;num-slaves&quot;</span><br><span class="line">   32) &quot;2&quot;</span><br><span class="line">   33) &quot;num-other-sentinels&quot;</span><br><span class="line">   34) &quot;2&quot;</span><br><span class="line">   35) &quot;quorum&quot;</span><br><span class="line">   36) &quot;2&quot;</span><br><span class="line">   37) &quot;failover-timeout&quot;</span><br><span class="line">   38) &quot;180000&quot;</span><br><span class="line">   39) &quot;parallel-syncs&quot;</span><br><span class="line">   40) &quot;1&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">172.16.6.242:26379&gt; sentinel slaves mymaster        # 查看当前从节点，可以看到原来的主节点242变成了从节点；</span><br><span class="line">1)  1) &quot;name&quot;</span><br><span class="line">    2) &quot;172.16.6.242:6379&quot;</span><br><span class="line">    3) &quot;ip&quot;</span><br><span class="line">    4) &quot;172.16.6.242&quot;</span><br><span class="line">    5) &quot;port&quot;</span><br><span class="line">    6) &quot;6379&quot;</span><br><span class="line">    7) &quot;runid&quot;</span><br><span class="line">    8) &quot;&quot;</span><br><span class="line">    9) &quot;flags&quot;</span><br><span class="line">   10) &quot;s_down,slave,disconnected&quot;</span><br><span class="line">   11) &quot;link-pending-commands&quot;</span><br><span class="line">   12) &quot;3&quot;</span><br><span class="line">   13) &quot;link-refcount&quot;</span><br><span class="line">   14) &quot;1&quot;</span><br><span class="line">   15) &quot;last-ping-sent&quot;</span><br><span class="line">   16) &quot;141427&quot;</span><br><span class="line">   17) &quot;last-ok-ping-reply&quot;</span><br><span class="line">   18) &quot;141427&quot;</span><br><span class="line">   19) &quot;last-ping-reply&quot;</span><br><span class="line">   20) &quot;141427&quot;</span><br><span class="line">   21) &quot;s-down-time&quot;</span><br><span class="line">   22) &quot;111358&quot;</span><br><span class="line">   23) &quot;down-after-milliseconds&quot;</span><br><span class="line">   24) &quot;30000&quot;</span><br><span class="line">   25) &quot;info-refresh&quot;</span><br><span class="line">   26) &quot;1546599601970&quot;</span><br><span class="line">   27) &quot;role-reported&quot;</span><br><span class="line">   28) &quot;slave&quot;</span><br><span class="line">   29) &quot;role-reported-time&quot;</span><br><span class="line">   30) &quot;141427&quot;</span><br><span class="line">   31) &quot;master-link-down-time&quot;</span><br><span class="line">   32) &quot;0&quot;</span><br><span class="line">   33) &quot;master-link-status&quot;</span><br><span class="line">   34) &quot;err&quot;</span><br><span class="line">   35) &quot;master-host&quot;</span><br><span class="line">   36) &quot;?&quot;</span><br><span class="line">   37) &quot;master-port&quot;</span><br><span class="line">   38) &quot;0&quot;</span><br><span class="line">   39) &quot;slave-priority&quot;</span><br><span class="line">   40) &quot;100&quot;</span><br><span class="line">   41) &quot;slave-repl-offset&quot;</span><br><span class="line">   42) &quot;0&quot;</span><br><span class="line">2)  1) &quot;name&quot;</span><br><span class="line">    2) &quot;172.16.6.244:6379&quot;</span><br><span class="line">    3) &quot;ip&quot;</span><br><span class="line">    4) &quot;172.16.6.244&quot;</span><br><span class="line">    5) &quot;port&quot;</span><br><span class="line">    6) &quot;6379&quot;</span><br><span class="line">    7) &quot;runid&quot;</span><br><span class="line">    8) &quot;5c34cdad4c9c8623bf5ebdf388d01d410e464fdc&quot;</span><br><span class="line">    9) &quot;flags&quot;</span><br><span class="line">   10) &quot;slave&quot;</span><br><span class="line">   11) &quot;link-pending-commands&quot;</span><br><span class="line">   12) &quot;0&quot;</span><br><span class="line">   13) &quot;link-refcount&quot;</span><br><span class="line">   14) &quot;1&quot;</span><br><span class="line">   15) &quot;last-ping-sent&quot;</span><br><span class="line">   16) &quot;0&quot;</span><br><span class="line">   17) &quot;last-ok-ping-reply&quot;</span><br><span class="line">   18) &quot;283&quot;</span><br><span class="line">   19) &quot;last-ping-reply&quot;</span><br><span class="line">   20) &quot;283&quot;</span><br><span class="line">   21) &quot;down-after-milliseconds&quot;</span><br><span class="line">   22) &quot;30000&quot;</span><br><span class="line">   23) &quot;info-refresh&quot;</span><br><span class="line">   24) &quot;784&quot;</span><br><span class="line">   25) &quot;role-reported&quot;</span><br><span class="line">   26) &quot;slave&quot;</span><br><span class="line">   27) &quot;role-reported-time&quot;</span><br><span class="line">   28) &quot;141427&quot;</span><br><span class="line">   29) &quot;master-link-down-time&quot;</span><br><span class="line">   30) &quot;0&quot;</span><br><span class="line">   31) &quot;master-link-status&quot;</span><br><span class="line">   32) &quot;ok&quot;</span><br><span class="line">   33) &quot;master-host&quot;</span><br><span class="line">   34) &quot;172.16.6.243&quot;</span><br><span class="line">   35) &quot;master-port&quot;</span><br><span class="line">   36) &quot;6379&quot;</span><br><span class="line">   37) &quot;slave-priority&quot;</span><br><span class="line">   38) &quot;100&quot;</span><br><span class="line">   39) &quot;slave-repl-offset&quot;</span><br><span class="line">   40) &quot;2485282&quot;</span><br></pre></td></tr></table></figure><h4 id="恢复原主节点master"><a href="#恢复原主节点master" class="headerlink" title="恢复原主节点master"></a>恢复原主节点master</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# vim /etc/redis.conf         # 修改配置文件；</span><br><span class="line">masterauth ialvin</span><br><span class="line"></span><br><span class="line">[root@master ~]# systemctl restart redis.service         # 重启redis；</span><br><span class="line">[root@master ~]# redis-cli</span><br><span class="line">127.0.0.1:6379&gt; auth ialvin</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; info replication        # master节点已变成从节点</span><br><span class="line"># Replication</span><br><span class="line">role:slave</span><br><span class="line">master_host:172.16.6.243</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:0</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:2662497</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:93005e7b0ff1af41731dac92725041afbfd01809</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:2662497</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:2650868</span><br><span class="line">repl_backlog_histlen:11630</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@master ~]# redis-cli -h 172.16.6.242 -p 26379   # 连接redis-sentinel查看所有从节点</span><br><span class="line">172.16.6.242:26379&gt; sentinel slaves mymaster</span><br><span class="line">1)  1) &quot;name&quot;</span><br><span class="line">    2) &quot;172.16.6.242:6379&quot;</span><br><span class="line">    3) &quot;ip&quot;</span><br><span class="line">    4) &quot;172.16.6.242&quot;</span><br><span class="line">    5) &quot;port&quot;</span><br><span class="line">    6) &quot;6379&quot;</span><br><span class="line">    7) &quot;runid&quot;</span><br><span class="line">    8) &quot;e93cddd24e01de32f189e48aba3945ba3460d2c5&quot;</span><br><span class="line">    9) &quot;flags&quot;</span><br><span class="line">   10) &quot;slave&quot;</span><br><span class="line">   11) &quot;link-pending-commands&quot;</span><br><span class="line">   12) &quot;0&quot;</span><br><span class="line">   13) &quot;link-refcount&quot;</span><br><span class="line">   14) &quot;1&quot;</span><br><span class="line">   15) &quot;last-ping-sent&quot;</span><br><span class="line">   16) &quot;0&quot;</span><br><span class="line">   17) &quot;last-ok-ping-reply&quot;</span><br><span class="line">   18) &quot;694&quot;</span><br><span class="line">   19) &quot;last-ping-reply&quot;</span><br><span class="line">   20) &quot;694&quot;</span><br><span class="line">   21) &quot;down-after-milliseconds&quot;</span><br><span class="line">   22) &quot;30000&quot;</span><br><span class="line">   23) &quot;info-refresh&quot;</span><br><span class="line">   24) &quot;5921&quot;</span><br><span class="line">   25) &quot;role-reported&quot;</span><br><span class="line">   26) &quot;slave&quot;</span><br><span class="line">   27) &quot;role-reported-time&quot;</span><br><span class="line">   28) &quot;538314&quot;</span><br><span class="line">   29) &quot;master-link-down-time&quot;</span><br><span class="line">   30) &quot;0&quot;</span><br><span class="line">   31) &quot;master-link-status&quot;</span><br><span class="line">   32) &quot;ok&quot;</span><br><span class="line">   33) &quot;master-host&quot;</span><br><span class="line">   34) &quot;172.16.6.243&quot;</span><br><span class="line">   35) &quot;master-port&quot;</span><br><span class="line">   36) &quot;6379&quot;</span><br><span class="line">   37) &quot;slave-priority&quot;</span><br><span class="line">   38) &quot;100&quot;</span><br><span class="line">   39) &quot;slave-repl-offset&quot;</span><br><span class="line">   40) &quot;2692453&quot;</span><br><span class="line">2)  1) &quot;name&quot;</span><br><span class="line">    2) &quot;172.16.6.244:6379&quot;</span><br><span class="line">    3) &quot;ip&quot;</span><br><span class="line">    4) &quot;172.16.6.244&quot;</span><br><span class="line">    5) &quot;port&quot;</span><br><span class="line">    6) &quot;6379&quot;</span><br><span class="line">    7) &quot;runid&quot;</span><br><span class="line">    8) &quot;5c34cdad4c9c8623bf5ebdf388d01d410e464fdc&quot;</span><br><span class="line">    9) &quot;flags&quot;</span><br><span class="line">   10) &quot;slave&quot;</span><br><span class="line">   11) &quot;link-pending-commands&quot;</span><br><span class="line">   12) &quot;0&quot;</span><br><span class="line">   13) &quot;link-refcount&quot;</span><br><span class="line">   14) &quot;1&quot;</span><br><span class="line">   15) &quot;last-ping-sent&quot;</span><br><span class="line">   16) &quot;0&quot;</span><br><span class="line">   17) &quot;last-ok-ping-reply&quot;</span><br><span class="line">   18) &quot;694&quot;</span><br><span class="line">   19) &quot;last-ping-reply&quot;</span><br><span class="line">   20) &quot;694&quot;</span><br><span class="line">   21) &quot;down-after-milliseconds&quot;</span><br><span class="line">   22) &quot;30000&quot;</span><br><span class="line">   23) &quot;info-refresh&quot;</span><br><span class="line">   24) &quot;7809&quot;</span><br><span class="line">   25) &quot;role-reported&quot;</span><br><span class="line">   26) &quot;slave&quot;</span><br><span class="line">   27) &quot;role-reported-time&quot;</span><br><span class="line">   28) &quot;1152017&quot;</span><br><span class="line">   29) &quot;master-link-down-time&quot;</span><br><span class="line">   30) &quot;0&quot;</span><br><span class="line">   31) &quot;master-link-status&quot;</span><br><span class="line">   32) &quot;ok&quot;</span><br><span class="line">   33) &quot;master-host&quot;</span><br><span class="line">   34) &quot;172.16.6.243&quot;</span><br><span class="line">   35) &quot;master-port&quot;</span><br><span class="line">   36) &quot;6379&quot;</span><br><span class="line">   37) &quot;slave-priority&quot;</span><br><span class="line">   38) &quot;100&quot;</span><br><span class="line">   39) &quot;slave-repl-offset&quot;</span><br><span class="line">   40) &quot;2692036&quot;</span><br></pre></td></tr></table></figure><h3 id="搭建过程注意事项"><a href="#搭建过程注意事项" class="headerlink" title="搭建过程注意事项"></a>搭建过程注意事项</h3><p>1.哨兵系统中的主从节点，与普通的主从节点并没有什么区别，故障发现和转移是由哨兵来控制和完成的。<br>2.哨兵节点本质上是Redis节点。<br>3.每个哨兵节点，只需要配置监控主节点，便可以自动发现其他的哨兵节点和从节点。<br>4.在哨兵节点启动和故障转移阶段，各个节点的配置文件会被重写(config rewrite)。<br>5.例子中，一个哨兵只监控了一个主节点；实际上，一个哨兵可以监控多个主节点，通过配置多条sentinel monitor即可实现。<br>6.每个哨兵有唯一标示myid，在copy配置文件时，若存在该配置要删掉，哨兵启动后会自动生成新的myid。  </p><h2 id="哨兵原理"><a href="#哨兵原理" class="headerlink" title="哨兵原理"></a>哨兵原理</h2><h3 id="架构如下图"><a href="#架构如下图" class="headerlink" title="架构如下图"></a>架构如下图</h3><p><img src="https://coding.net/u/alvin_me/p/blogpics/git/raw/master/shaobingdesign.png" alt="">  </p><h3 id="哨兵相关命令"><a href="#哨兵相关命令" class="headerlink" title="哨兵相关命令"></a>哨兵相关命令</h3><blockquote><p>info sentinel：获取监控的所有主节点的基本信息<br>sentinel masters：获取监控的所有主节点的详细信息<br>sentinel master mymaster：获取监控的主节点mymaster的详细信息<br>sentinel slaves mymaster：获取监控的主节点mymaster的从节点的详细信息<br>sentinel sentinels mymaster：获取监控的主节点mymaster的哨兵节点的详细信息<br>sentinel get-master-addr-by-name mymaster：获取监控的主节点mymaster的地址信息<br>sentinel is-master-down-by-addr：哨兵节点之间可以通过该命令询问主节点是否下线，从而对是否客观下线做出判断<br>sentinel monitor mymaster 172.16.6.242 6379 2：与部署哨兵节点时配置文件中的sentinel monitor功能完全一样<br>sentinel remove mymaster：取消当前哨兵节点对主节点mymaster的监控<br>sentinel failover mymaster：强制对mymaster执行故障转移，即便当前的主节点运行完好   </p></blockquote><h3 id="相关概念及原理"><a href="#相关概念及原理" class="headerlink" title="相关概念及原理"></a>相关概念及原理</h3><blockquote><p>定时任务：每个哨兵节点维护了3个定时任务。定时任务的功能分别如下：通过向主从节点发送info命令获取最新的主从结构；通过发布订阅功能获取其他哨兵节点的信息；通过向其他节点发送ping命令进行心跳检测，判断是否下线。<br>主观下线：在心跳检测的定时任务中，如果其他节点超过一定时间没有回复，哨兵节点就会将其进行主观下线。顾名思义，主观下线的意思是一个哨兵节点“主观地”判断下线；与主观下线相对应的是客观下线。<br>客观下线：哨兵节点在对主节点进行主观下线后，会通过sentinel is-master-down-by-addr命令询问其他哨兵节点该主节点的状态；如果判断主节点下线的哨兵数量达到一定数值，则对该主节点进行客观下线。<br><strong>需要特别注意的是，客观下线是主节点才有的概念；如果从节点和哨兵节点发生故障，被哨兵主观下线后，不会再有后续的客观下线和故障转移操作。</strong><br>选举领导者哨兵节点：当主节点被判断客观下线以后，各个哨兵节点会进行协商，选举出一个领导者哨兵节点，并由该领导者节点对其进行故障转移操作。<br><strong>监视该主节点的所有哨兵都有可能被选为领导者，选举使用的算法是Raft算法；Raft算法的基本思路是先到先得：即在一轮选举中，哨兵A向哨兵B发送成为领导者的申请，如果B没有同意过其他哨兵，则会同意A成为领导者。选举的具体过程这里不做详细描述，一般来说，哨兵选择的过程很快，谁先完成客观下线，一般就能成为领导者。</strong><br>故障转移：选举出的领导者哨兵，开始进行故障转移操作，该操作大体可以分为3个步骤：    </p></blockquote><p>1.在从节点中选择新的主节点：选择的原则是，首先过滤掉不健康的从节点；然后选择优先级最高的从节点(由slave-priority指定)；如果优先级无法区分，则选择复制偏移量最大的从节点；如果仍无法区分，则选择runid最小的从节点。<br>2.更新主从状态：通过slaveof no one命令，让选出来的从节点成为主节点；并通过slaveof命令让其他节点成为其从节点。<br>3.将已经下线的主节点(即6379)设置为新的主节点的从节点，当6379重新上线后，它会成为新的主节点的从节点。  </p><h3 id="配置建议"><a href="#配置建议" class="headerlink" title="配置建议"></a>配置建议</h3><h4 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h4><blockquote><p>sentinel monitor <master-name> <ip> <redis-port> <quorum>  </quorum></redis-port></ip></master-name></p></blockquote><p>sentinel monitor是哨兵最核心的配置，在前文讲述部署哨兵节点时已说明，其中：master-name指定了主节点名称，ip和redis-port指定了主节点地址，quorum是判断主节点客观下线的哨兵数量阈值：当判定主节点下线的哨兵数量达到quorum时，对主节点进行客观下线。建议取值为哨兵数量的一半加1。  </p><blockquote><p>sentinel down-after-milliseconds <master-name> <milliseconds>  </milliseconds></master-name></p></blockquote><p>sentinel down-after-milliseconds与主观下线的判断有关：哨兵使用ping命令对其他节点进行心跳检测，如果其他节点超过milliseconds没有回复，哨兵就会将其进行主观下线。该配置对主节点、从节点和哨兵节点的主观下线判定都有效。</p><p>down-after-milliseconds的默认值是30000，即30s；可以根据不同的网络环境和应用要求来调整：值越大，对主观下线的判定会越宽松，好处是误判的可能性小，坏处是故障发现和故障转移的时间变长，客户端等待的时间也会变长。例如，如果应用对可用性要求较高，则可以将值适当调小，当故障发生时尽快完成转移；如果网络环境相对较差，可以适当提高该阈值，避免频繁误判。  </p><blockquote><p>sentinel parallel-syncs <master-name> <numreplicas>  </numreplicas></master-name></p></blockquote><p>sentinel parallel-syncs与故障转移之后从节点的复制有关：它规定了每次向新的主节点发起复制操作的从节点个数。例如，假设主节点切换完成之后，有3个从节点要向新的主节点发起复制；如果parallel-syncs=1，则从节点会一个一个开始复制；如果parallel-syncs=3，则3个从节点会一起开始复制。</p><p>parallel-syncs取值越大，从节点完成复制的时间越快，但是对主节点的网络负载、硬盘负载造成的压力也越大；应根据实际情况设置。例如，如果主节点的负载较低，而从节点对服务可用的要求较高，可以适量增加parallel-syncs取值。parallel-syncs的默认值是1。</p><blockquote><p>sentinel failover-timeout <master-name> <milliseconds>   </milliseconds></master-name></p></blockquote><p>sentinel failover-timeout与故障转移超时的判断有关，但是该参数不是用来判断整个故障转移阶段的超时，而是其几个子阶段的超时，例如如果主节点晋升从节点时间超过timeout，或从节点向新的主节点发起复制操作的时间(不包括复制数据的时间)超过timeout，都会导致故障转移超时失败。</p><p>failover-timeout的默认值是180000，即180s；如果超时，则下一次该值会变为原来的2倍。</p><h4 id="操作建议"><a href="#操作建议" class="headerlink" title="操作建议"></a>操作建议</h4><ol><li>哨兵节点的数量应不止一个，一方面增加哨兵节点的冗余，避免哨兵本身成为高可用的瓶颈；另一方面减少对下线的误判。此外，这些不同的哨兵节点应部署在不同的物理机上。  </li><li>哨兵节点的数量应该是奇数，便于哨兵通过投票做出“决策”：领导者选举的决策、客观下线的决策等。  </li><li>各个哨兵节点的配置应一致，包括硬件、参数等；此外，所有节点都应该使用<code>ntp</code>或类似服务，保证时间准确、一致。  </li><li>哨兵的配置提供者和通知客户端功能，需要客户端的支持才能实现，如前文所说的Jedis；如果开发者使用的库未提供相应支持，则可能需要开发者自己实现。  </li><li>当哨兵系统中的节点在docker（或其他可能进行端口映射的软件）中部署时，应特别注意端口映射可能会导致哨兵系统无法正常工作，因为哨兵的工作基于与其他节点的通信，而docker的端口映射可能导致哨兵无法连接到其他节点。例如，哨兵之间互相发现，依赖于它们对外宣称的IP和port，如果某个哨兵A部署在做了端口映射的docker中，那么其他哨兵使用A宣称的port无法连接到A。  </li></ol><p>参考：  </p><ol><li><a href="https://www.cnblogs.com/kismetv/p/9609938.html" target="_blank" rel="noopener">深入学习Redis（4）：哨兵</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;哨兵在复制的基础上，哨兵实现了自动化的故障恢复。缺陷：写操作无法负载均衡；存储能力受到单机的限制。&lt;br&gt;Redis2.8引入哨兵，主要功能如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;监控（Monitoring：&lt;/strong&gt; 哨兵会不断地检查主节点和从节点是否运作正常。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自动故障转移（Automatic failover）：&lt;/strong&gt; 当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;配置提供者（Configuration provider）：&lt;/strong&gt; 客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通知（Notification）：&lt;/strong&gt; 哨兵可以将故障转移的结果发送给客户端。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文哨兵系统，包含1个主节点、2个从节点和3个哨兵节点。&lt;br&gt;
    
    </summary>
    
      <category term="数据存储" scheme="https://dongz.me/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="redis" scheme="https://dongz.me/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis主从复制</title>
    <link href="https://dongz.me/2019/01/06/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>https://dongz.me/2019/01/06/Redis主从复制/</id>
    <published>2019-01-06T04:20:00.000Z</published>
    <updated>2019-01-06T04:33:00.101Z</updated>
    
    <content type="html"><![CDATA[<p>主从复制，就是把一台Redis服务的数据拷贝到另一台Redis服务器。前者称为主节点，后者称为从节点。数据只能从主节点流向从节点。一个主节点可以有多个从节点，一个从节点只能有一个主节点。<br>Redis的主从架构主要有两种模式：主从复制模式和链式主从复制模式。</p><p>主从复制的作用主要有以下几点：</p><ol><li><strong>数据冗余：</strong>实现数据热备份，提供多个数据冗余备份保证数据安全性。</li><li><strong>增强容错：</strong>主节点故障，从节点仍可以对外提供读服务。</li><li><strong>负载均衡：</strong>读写分离，分担服务器负载压力。</li><li><strong>高可用基础：</strong>是哨兵和集群实现的基础。<a id="more"></a></li></ol><h2 id="主从复制实战"><a href="#主从复制实战" class="headerlink" title="主从复制实战"></a>主从复制实战</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p>系统：centos7<br>服务器：master(172.16.6.242)、slave1(172.16.6.243)、slave2(172.16.6.244)<br>Redis版本：5.0.3</p><h4 id="同步时间"><a href="#同步时间" class="headerlink" title="同步时间"></a>同步时间</h4><p>服务器依次执行如下命令：<br>    sudo ntpdate cn.pool.ntp.org  // cn.pool.ntp.org为网络时间服务器，也可以同步自己的时间服务器</p><p>若ntpdate未安装，执行如下命令安装：<br>    yum -y install ntp ntpdate</p><h3 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h3><p>设置yum源，以安置最新稳定版本Redis：<br>    yum install -y <a href="http://rpms.famillecollet.com/enterprise/remi-release-7.rpm" target="_blank" rel="noopener">http://rpms.famillecollet.com/enterprise/remi-release-7.rpm</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># master安装  </span><br><span class="line">[root@master ~]# yum --enablerepo=remi install redis</span><br><span class="line"></span><br><span class="line"># slave1安装  </span><br><span class="line">[root@slave1 ~]# yum --enablerepo=remi install redis</span><br><span class="line"></span><br><span class="line"># slave2安装  </span><br><span class="line">[root@slave2 ~]# yum --enablerepo=remi install redis</span><br></pre></td></tr></table></figure><h3 id="配置启动"><a href="#配置启动" class="headerlink" title="配置启动"></a>配置启动</h3><p>配置master节点并启动服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# vim /etc/redis.conf</span><br><span class="line">bind 0.0.0.0        # 监控本地所有IP；</span><br><span class="line">requirepass ialvin      # 设置密码 ialvin；</span><br><span class="line">[root@master ~]# systemctl start redis</span><br><span class="line">[root@master ~]# ss -tnl</span><br><span class="line">State      Recv-Q Send-Q Local Address:Port               Peer Address:Port</span><br><span class="line">LISTEN     0      128          *:6379                     *:*</span><br><span class="line">LISTEN     0      128          *:111                      *:*</span><br><span class="line">LISTEN     0      128          *:22                       *:*</span><br></pre></td></tr></table></figure></p><p>配置slave1节点并启动服务，配置文件方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">[root@slave1 ~]# vim /etc/redis.conf</span><br><span class="line">bind 0.0.0.0            # 监控本地所有IP；</span><br><span class="line">requirepass ialvin      # 设置密码为ialvin；</span><br><span class="line"></span><br><span class="line">replicaof 172.16.6.242 6379       # 设置主节点IP 端口；</span><br><span class="line">masterauth ialvin           # 主节点认证密码；</span><br><span class="line"></span><br><span class="line">[root@slave1 ~]# systemctl start redis       # 启动服务；</span><br><span class="line">[root@slave1 ~]# ss -tnl     # 端口已经开启；</span><br><span class="line">State      Recv-Q Send-Q Local Address:Port           Peer Address:Port</span><br><span class="line">LISTEN     0      128    172.16.6.243:7946                *:*</span><br><span class="line">LISTEN     0      128          *:27018                    *:*</span><br><span class="line">LISTEN     0      128          *:6379                     *:*</span><br><span class="line"></span><br><span class="line">[root@slave1 ~]# redis-cli</span><br><span class="line">127.0.0.1:6379&gt; auth ialvin</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:slave</span><br><span class="line">master_host:172.16.6.242</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:6</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:140642</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:970c2af1479671a4acb859113f0527c94c1a1fea</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:140642</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:295</span><br><span class="line">repl_backlog_histlen:140348</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 切换到master查看</span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=172.16.6.243,port=6379,state=online,offset=140838,lag=1</span><br><span class="line">master_replid:970c2af1479671a4acb859113f0527c94c1a1fea</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:140838</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:140838</span><br></pre></td></tr></table></figure></p><p>配置slave2节点并启动服务，命令行方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">[root@slave2 ~]# vim /etc/redis.conf </span><br><span class="line">bind 0.0.0.0            # 监控本地所有IP；</span><br><span class="line">requirepass ialvin      # 设置密码为ialvin；</span><br><span class="line"></span><br><span class="line">[root@slave2 ~]# systemctl start redis</span><br><span class="line">[root@slave2 ~]# ss -tnl</span><br><span class="line">State      Recv-Q Send-Q Local Address:Port               Peer Address:Port</span><br><span class="line">LISTEN     0      128          *:6379                     *:*</span><br><span class="line">LISTEN     0      128          *:111                      *:*</span><br><span class="line">LISTEN     0      128          *:22                       *:*</span><br><span class="line">LISTEN     0      128    127.0.0.1:631                      *:*</span><br><span class="line"></span><br><span class="line">[root@slave2 ~]# redis-cli -a ialvin</span><br><span class="line">127.0.0.1:6379&gt; info replication        # 目前slave2还不是master的从节点；</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:bdcd0e33999ba623c1363dbce3489775fc972850</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; config get replicaof      # 查看当前redis节点配置信息；</span><br><span class="line">1) &quot;replicaof&quot;</span><br><span class="line">2) &quot;&quot;</span><br><span class="line">127.0.0.1:6379&gt; replicaof 172.16.6.242 6379   # 配置主节点IP 端口；</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get masterauth       # 认证信息；</span><br><span class="line">1) &quot;masterauth&quot;</span><br><span class="line">2) &quot;&quot;</span><br><span class="line">127.0.0.1:6379&gt; config set masterauth iavlin        # 配置认证；</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; info replication        # 主节点配置完成；</span><br><span class="line"># Replication</span><br><span class="line">role:slave</span><br><span class="line">master_host:172.16.6.242</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:10</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:141496</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:970c2af1479671a4acb859113f0527c94c1a1fea</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:141496</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:141483</span><br><span class="line">repl_backlog_histlen:14</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; config rewrite      # 保存到配置文件中；</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">[root@slave2 ~]# tail -3  /etc/redis.conf        # 已经保存到配置文件中；</span><br><span class="line"># Generated by CONFIG REWRITE</span><br><span class="line">replicaof 172.16.6.242 6379</span><br><span class="line">masterauth &quot;ialvin&quot;</span><br></pre></td></tr></table></figure></p><h3 id="主从复制测试"><a href="#主从复制测试" class="headerlink" title="主从复制测试"></a>主从复制测试</h3><p>统一在默认库0做测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#主节点master创建key</span><br><span class="line">[root@master ~]# redis-cli -a ialvin</span><br><span class="line">127.0.0.1:6379&gt; set foo bar</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get foo</span><br><span class="line">&quot;bar&quot;</span><br><span class="line"></span><br><span class="line"># slave1上查看</span><br><span class="line">[root@slave1 ~]# redis-cli -a ialvin</span><br><span class="line">127.0.0.1:6379&gt; get foo</span><br><span class="line">&quot;bar&quot;</span><br><span class="line"></span><br><span class="line"># slave2上查看</span><br><span class="line">[root@slave2 ~]# redis-cli -a ialvin</span><br><span class="line">127.0.0.1:6379&gt; get foo</span><br><span class="line">&quot;bar&quot;</span><br><span class="line"></span><br><span class="line"># 主库写入key，从库可以读到</span><br></pre></td></tr></table></figure></p><h2 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h2><p>Redis复制过程大体可分为三个阶段：建立连接、数据同步、命令传播。  </p><h3 id="建立连接阶段"><a href="#建立连接阶段" class="headerlink" title="建立连接阶段"></a>建立连接阶段</h3><h4 id="主服务器的地址和端口"><a href="#主服务器的地址和端口" class="headerlink" title="主服务器的地址和端口"></a>主服务器的地址和端口</h4><p>当输入replicaof命令或者在配置文件中配置replicaof信息时，从服务器会将主服务器的ip地址和端口号保存到服务器状态的属性里面。</p><h4 id="建立套接字连接"><a href="#建立套接字连接" class="headerlink" title="建立套接字连接"></a>建立套接字连接</h4><p>在replicaof命令执行之后，从服务器会根据属性里维护的主节点的ip和端口，向主服务器发起socket连接。以下为连接建立后主从节点的操作。<br>从节点：为该socket建立一个专门处理复制工作的文件事件处理器，负责后续的复制工作，如接收RDB文件、接收命令传播等。<br>主节点：为该socket创建相应的客户端状态，保存客户端信息。</p><h4 id="PING探活"><a href="#PING探活" class="headerlink" title="PING探活"></a>PING探活</h4><p>从节点成为主节点的客户端之后，发送ping命令进行首次请求，检查socket连接是否可用，以及主节点当前是否能够处理请求。<br>正常情况下主节点会返回PONG，异常情况下从节点会断开socket连接，稍后会重新建立连接。</p><h4 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h4><p>主节点设置了requirepass开启连接验证，从节点需要设置masterauth属性，且与主节点requirepass值设置为相同值。在从节点收到主节点PONG回复时，从节点会发送auth命令，命令格式为“auth + 密码”进行密码验证，其中密码为masterauth参数配置的密码。</p><h4 id="发送从节点端口信息"><a href="#发送从节点端口信息" class="headerlink" title="发送从节点端口信息"></a>发送从节点端口信息</h4><p>身份验证之后，从节点会向主节点发送其监听的端口号（使用默认端口为6379），主节点将该信息保存到该从节点对应的客户端的slave_listening_port字段中；用来在主节点中执行info Replication时显示。</p><h3 id="数据同步阶段"><a href="#数据同步阶段" class="headerlink" title="数据同步阶段"></a>数据同步阶段</h3><p>主从连接建立以后，便开始进行该阶段。执行方式：从节点向主节点发送psync命令（Redis2.8以前是sync命令）开始同步。  </p><p>该阶段是主从复制核心阶段，根据主从节点状态不同分为全量复制和部分复制。  </p><ul><li>全量复制：初始化同步或无法进行部分复制时采用的同步方式，主节点将全量数据发给从节点，属于重型操作。</li><li>部分复制：网络短暂中断情况下同步方式，主节点只将中断期间的写命令发送给从节点，比全量复制高效。但长时间网络中断，主节点无法完整保存期间执行的写命令，只能进行全量同步。</li></ul><p>该阶段以前从节点是主节点的客户端，主节点不是从节点的客户端；该阶段及以后阶段主从互为客户端。原因是从该阶段开始主节点开始主动向从节点发起请求。</p><h4 id="全量复制同步"><a href="#全量复制同步" class="headerlink" title="全量复制同步"></a>全量复制同步</h4><p>Redis2.8以前只有该同步方式，通过psync命令进行全量复制过程：  </p><ol><li>从节点向主节点发送全量复制请求；或从节点向主节点发送部分复制请求，但主节点判断只能进行全量复制。  </li><li>主节点接收全量复制请求，开线程执行bgsave命令生成RDB文件，同时使用复制缓冲区记录此刻开始的所有写命令。  </li><li>bgsave命令执行完以后，将RDB文件发送到从节点，从节点先清除旧数据然后加载RDB文件（阻塞，进行时不能响应客户端请求）。</li><li>主节点将复制缓冲区所有命令发送给从节点，从节点执行命令，此时从节点数据和主节点数据保持一致。</li><li>从节点若开启AOF，会触发bgrewriteaof执行，保证和主节点AOF文件一致。</li></ol><h4 id="部分复制同步"><a href="#部分复制同步" class="headerlink" title="部分复制同步"></a>部分复制同步</h4><p>Redis2.8以后新增复制方式，缓解全量复制带来的性能开销及其它问题。<br>相关概念：<br><strong>复制偏移量</strong><br>主节点和从节点同时维护一个复制偏移量（offset），代表主节点向从节点传递的字节数；主节点向从节点传递N个字节，则主节点offset增加N；从节点从主节点接收N个字节，则从节点offset增加N。<br>从节点携带offset请求主节点进行部分复制，主节点通过比较自己保存的offset和从节点offset值确定本次部分复制的数据范围。<br>例如，如果主节点的offset是1000，而从节点的offset是500，那么部分复制就需要将offset为501-1000的数据传递给从节点。而offset为501-1000的数据存储在复制缓冲区。</p><p><strong>复制缓冲区</strong><br>复制积压缓冲区是由主节点维护的、固定长度的、先进先出(FIFO)队列，默认大小1MB，可通过修改repl-backlog-size自定义配置；主要作用是备份主节点最近发送给从节点的数据。只有一个复制积压缓冲区。<br>  在命令传播阶段，主节点除了向从节点发送命令，同时会发一份到复制缓冲区作为备份，同时会记录每个字节的offset。部分复制的数据区间从该区域获取，当主从节点offset差距过大超过缓冲区长度时，无法进行部分复制，<br>只能进行全量复制。</p><p><strong>Redis运行ID</strong><br>Redis启动时生成的40位16进制随机串，每次启动不一样。无论主从，每个节点都会生成。可通过 <code>redis-cli info server | grep run_id</code>查看。<br>  主从节点初次复制时，主节点将自己的runid发送给从节点，从节点将这个runid保存起来；当断线重连时，从节点会将这个runid发送给主节点；主节点根据runid判断能否进行部分复制，若相同则发起部分复制请求（还要综合offset和复制缓冲区情况），<br>不相同则全量复制。</p><p>部分复制执行过程：  </p><ol><li>未执行过slaveof或最近执行了slaveof no one，则从节点发送命令为psync ? -1，向主节点请求全量复制。  </li><li>之前执行了slaveof，则发送命令为psync <runid> <offset>，其中runid为上次复制的主节点的runid，offset为上次复制截止时从节点保存的复制偏移量。  </offset></runid></li><li>如果主节点版本低于Redis2.8，则返回-ERR回复，此时从节点重新发送sync命令执行全量复制。  </li><li>如果主节点版本够新，且runid与从节点发送的runid相同，且从节点发送的offset之后的数据在复制积压缓冲区中都存在，则回复+CONTINUE，表示将进行部分复制，从节点等待主节点发送其缺少的数据即可。</li><li>如果主节点版本够新，但是runid与从节点发送的runid不同，或从节点发送的offset之后的数据已不在复制积压缓冲区中(在队列中被挤出了)，则回复+FULLRESYNC <runid> <offset>，表示要进行全量复制，<br>其中runid表示主节点当前的runid，offset表示主节点当前的offset，从节点保存这两个值，以备使用。</offset></runid></li></ol><h5 id="redis4-0升级psync"><a href="#redis4-0升级psync" class="headerlink" title="redis4.0升级psync"></a>redis4.0升级psync</h5><p>Redis4.0之前的psync我们称为psync1，4.0及以后升级后的psnyc我们称为psync2。  </p><p>psync1主要存在以下问题：  </p><ol><li>节点重启后，runid和复制缓冲区丢失，只能进行全量复制。  </li><li>主从发生切换时，只能进行全量复制。  </li></ol><p>psync2主要解决了以上问题。psync2在psync1基础上新增两个复制id：  </p><ul><li>master_replid: 复制id1(后文简称：replid1)，一个长度为41个字节(40个随机串+’0’)的字符串，每个节点都有，和runid没有直接关联，但和runid生成规则相同。当节点变为从节点后，自己的replid1会被主节点的replid1覆盖。  </li><li>master_replid2：复制id2(后文简称:replid2),默认初始化为全0，用于存储上次主节点的replid1。</li></ul><p><strong>重启实现部分复制</strong>  </p><ol><li>Redis关闭时，通过shutdown save，都会调用rdbSaveInfoAuxFields函数，把当前实例的repl-id和repl-offset保存到RDB文件中。  </li><li>重启时Redis加载RDB文件，会专门处理文件中辅助字段(AUX fields）信息，把其中repl_id和repl_offset加载到实例中，分别赋给master_replid和master_repl_offset两个变量值。<br>若开启了AOF持久化，由于加载优先级较高，导致重启后从节点依旧使用全量复制。  </li><li>从节点向主节点上报master_replid和master_repl_offset+1，若与主节点的master_replid1或replid2有一个相等，且master_repl_offset+1字节，还存在于主节点的复制积压缓冲区中，则进行部分复制。</li></ol><p><strong>主从切换实现部分复制</strong><br>Redis从节点默认开启复制缓冲区功能，以便主节点故障从节点切换为主节点后，其他落后该节点的从节点可以从缓冲区中获取缺少的命令。该过程的实现通过两组replid、offset替换原来的master runid和offset变量实现：<br>第一组：master_replid和master_repl_offset：如果Redis是主节点，则表示为自己的replid和复制偏移量； 如果Redis是从节点，则表示同步主节点的replid1和复制偏移量。<br>第二组：master_replid2和second_repl_offset：无论主从，都表示自己上次主节点repid1和复制偏移量。  </p><p>判断是否使用部分复制条件：如果从库提供的master_replid与master的replid相同，或者与master的replid2相同，且master_repl_offset+1字节，还存在于目标节点的复制积压缓冲区中，则进行部分复制。</p><h3 id="命令传播阶段"><a href="#命令传播阶段" class="headerlink" title="命令传播阶段"></a>命令传播阶段</h3><p>在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：PING和REPLCONF ACK。心跳机制对于主从复制的超时判断、数据安全等有作用。  </p><p><strong>主==&gt;从：PING</strong><br>每隔一段时间（默认10秒，通过repl-ping-slave-period参数指定）主节点向从节点发送PING命令判断从节点是否在线。  </p><p><strong>从==&gt;主：REPLCONF ACK</strong><br>从节点每秒1次向主节点发送REPLCONF ACK命令，命令格式为：REPLCONF ACK {offset}，其中offset指从节点保存的复制偏移量，作用有以下几点：  </p><ol><li>实时监测主从节点网络状态<br>该命令会被主节点用于复制超时的判断，在主节点中使用info Replication，可以看到其从节点的状态中的lag值，代表的是主节点上次收到该REPLCONF ACK命令的时间间隔，在正常情况下，该值应该是0或1  </li><li>检测命令丢失<br>从节点发送了自身的offset，主节点会与自己的offset对比，如果从节点数据缺失（如网络丢包），主节点会推送缺失的数据（这里也会利用复制积压缓冲区）。<br>注意，offset和复制积压缓冲区，不仅可以用于部分复制，也可以用于处理命令丢失等情形；区别在于前者是在断线重连后进行的，而后者是在主从节点没有断线的情况下进行的。  </li><li>辅助保证从节点的数量和延迟<br>Redis主节点中使用min-slaves-to-write和min-slaves-max-lag参数，来保证主节点在不安全的情况下不会执行写命令；所谓不安全，是指从节点数量太少，或延迟过高。例如min-slaves-to-write和min-slaves-max-lag分别是3和10，<br>含义是如果从节点数量小于3个，或所有从节点的延迟值都大于10s，则主节点拒绝执行写命令。而这里从节点延迟值的获取，就是通过主节点接收到REPLCONF ACK命令的时间来判断的，即前面所说的info Replication中的lag值。</li></ol><p>参考：  </p><ol><li><a href="https://www.cnblogs.com/kismetv/p/9236731.html" target="_blank" rel="noopener">深入学习Redis（3）：主从复制</a></li><li><a href="https://juejin.im/post/5b67029c6fb9a04fa42fd592#heading-5" target="_blank" rel="noopener">redis系列–主从复制以及redis复制演进</a></li><li><a href="https://juejin.im/post/5b625b9be51d4519956759d0#heading-14" target="_blank" rel="noopener">redis系列：主从复制</a></li><li><a href="https://www.jianshu.com/p/6fe7c56e487c" target="_blank" rel="noopener">Redis4.0新特性(二)-PSYNC2</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主从复制，就是把一台Redis服务的数据拷贝到另一台Redis服务器。前者称为主节点，后者称为从节点。数据只能从主节点流向从节点。一个主节点可以有多个从节点，一个从节点只能有一个主节点。&lt;br&gt;Redis的主从架构主要有两种模式：主从复制模式和链式主从复制模式。&lt;/p&gt;
&lt;p&gt;主从复制的作用主要有以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;数据冗余：&lt;/strong&gt;实现数据热备份，提供多个数据冗余备份保证数据安全性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;增强容错：&lt;/strong&gt;主节点故障，从节点仍可以对外提供读服务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;负载均衡：&lt;/strong&gt;读写分离，分担服务器负载压力。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高可用基础：&lt;/strong&gt;是哨兵和集群实现的基础。
    
    </summary>
    
      <category term="数据存储" scheme="https://dongz.me/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="redis" scheme="https://dongz.me/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程</title>
    <link href="https://dongz.me/2018/12/21/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://dongz.me/2018/12/21/函数式编程/</id>
    <published>2018-12-20T16:27:00.000Z</published>
    <updated>2018-12-21T13:38:09.162Z</updated>
    
    <content type="html"><![CDATA[<p>最早是从一些博客上看到过函数式编程，但是没有太在意。js支持将函数作为传出/传入参数，可以存储在变量中。java8中Lambda表达式 、Stream流处理等功能等闪亮登场，除此之外还支持函数接口。越来越多语言中引入函数式编程的特性，种种苗头都预示着函数式编程越来越得到重视。这里主要对函数式编程思想做一些理解和认识。<br><a id="more"></a></p><h2 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h2><h3 id="形式系统"><a href="#形式系统" class="headerlink" title="形式系统"></a>形式系统</h3><blockquote><p>概念：先是确立一些互不冲突的基础原理，以及一些操作这些原理的规则，然后就可以把这些原理以及规则拼凑起来形成新的更加复杂的规则或是定理了。数学家把这种方法称为“形式系统”或是“演算”。    </p><p>理解：<br>示例1-没有人见过这样的一个圆，但是我们知道怎样的圆是完美的圆，而且可以用公式把它描述出来。<br>示例2-自然数，很难说所有的自然数都与客观世界有关，随便举一个超级大的数，这个数可能就和世界上任何事物无关，因为这个世界可能不是无穷大的。</p></blockquote><p><strong>notice:</strong> 形式系统是客观存在的，虽然不同文明不同智慧生物对它们的存在和理解方式有差异，与客观世界有关的更容易被发现和理解，而与客观世界无关的不容易被发现和理解。</p><h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><blockquote><p>阿隆佐设计了一个名为<a href="https://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97" target="_blank" rel="noopener">lambda演算</a>的形式系统。这个系统实质上是为其中一个超级机器设计的编程语言。在这种语言里面，函数的参数是函数，返回值也是函数。  </p><p>艾伦·图灵设计了一种完全不同的系统（后来被称为图灵机），并用这种系统得出了和阿隆佐相似的答案。到了后来人们证明了图灵机和lambda演算的能力是一样的。  </p><p>二战时期IBM制造了第一台机器Mark一号用来计算各种火炮发射数据表。Mark一号重5吨，由75万个零部件构成，每一秒可以完成3次运算。</p><p>1949年第一台电子离散变量自动计算机诞生并取得了巨大的成功。它是冯·诺伊曼设计架构的第一个实例，也是一台现实世界中实现的图灵机。</p><p>1958年John McCarthy的MIT教授发明了一种列表处理语言（Lisp），这种语言是一种阿隆佐lambda演算在现实世界的实现，而且它能在冯·诺伊曼计算机上运行！很多计算机科学家都认识到了Lisp强大的能力。</p><p>1973年在MIT人工智能实验室的一些程序员研发出一种机器，并把它叫做Lisp机。于是阿隆佐的lambda演算也有自己的硬件实现了！</p></blockquote><h2 id="函数式编程-FP"><a href="#函数式编程-FP" class="headerlink" title="函数式编程(FP)"></a>函数式编程(FP)</h2><blockquote><p>函数式编程是阿隆佐思想的在现实世界中的实现。不过不是全部的lambda演算思想都可以运用到实际中，因lambda演算在设计的时候就不是为了在各种现实世界中的限制下工作的。函数式编程只是一系列想法，而不是一套严苛的规定。</p><p>Lambda演算在最初设计的时候就是为了研究计算相关的问题，所以函数式编程主要解决的也是计算问题。</p><p>函数就是函数式编程中的基础元素，可以完成几乎所有的操作，哪怕最简单的计算，也是用函数完成的。</p><p>FP中变量称为符号，且都是final的。</p><p>函数式程序可以通过函数参数保存状态。</p></blockquote><h3 id="FP的优点"><a href="#FP的优点" class="headerlink" title="FP的优点"></a>FP的优点</h3><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><blockquote><p>因为FP中的每个符号都是final的，所以没有什么函数会有副作用。函数不会修改外部状态值，测试不需要关心外部状态值，也不需要关心函数调用顺序，唯一需要关心的仅仅是函数参数。  </p></blockquote><h4 id="调试查错"><a href="#调试查错" class="headerlink" title="调试查错"></a>调试查错</h4><blockquote><p>只要传递参数一致，错误百分百可以重现。<br>返回值异常时，检查栈上的数据，查看哪些参数传给了哪些函数，函数返回值是什么。跳进对应函数步进调试定位问题即可。</p></blockquote><h4 id="并发执行"><a href="#并发执行" class="headerlink" title="并发执行"></a>并发执行</h4><blockquote><p>不需要任何改动，所有FP程序都是可以并发执行的。<br>由于根本不需要采用锁机制，因此完全不需要担心死锁或是并发竞争的发生。<br>编译器可以对函数式代码进行分析，对耗时的函数并行调用。</p></blockquote><h4 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h4><blockquote><p>FP的程序中所有状态就是传给函数的参数，而参数都是储存在栈上的，这一特性让实现热部署变的简单。<br>只要比较一下正在运行的代码以及新的代码获得一个diff，然后用这个diff更新现有的代码，新代码的热部署就完成了。</p></blockquote><h4 id="机器辅助优化及证明"><a href="#机器辅助优化及证明" class="headerlink" title="机器辅助优化及证明"></a>机器辅助优化及证明</h4><blockquote><p>FP语言是可以用数学方法来分析的。只要是能在纸上写出来的数学运算就可以用这种语言表述出来。<br>可以用这种方法来证明代码的正确性，甚至可以设计出能够自动分析代码并为单元测试自动生成边缘测试用例的工具出来。</p></blockquote><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><blockquote><p>所谓的高阶函数就是对其他函数进行操作（比如说把这些函数当成参数）的函数。</p></blockquote><p>如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class MessageHandler &#123;</span><br><span class="line">    void handleMessage(Message msg, Function getClientCode) &#123;</span><br><span class="line">        // ...</span><br><span class="line">        Message msg1 = msg.setClientCode(getClientCode());</span><br><span class="line">        // ...</span><br><span class="line"></span><br><span class="line">        sendMessage(msg1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String getClientCodeOne() &#123;</span><br><span class="line">    return &quot;ABCD_123&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String getClientCodeTwo() &#123;</span><br><span class="line">    return &quot;123_ABCD&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MessageHandler handler = new MessageHandler();</span><br><span class="line">handler.handleMessage(someMsg, getClientCodeOne);</span><br></pre></td></tr></table></figure><blockquote><p>好处：一是不再受限于多层类的结构。这样做可以在运行时传递新的函数，可以在任何时候改变这些函数，而且这些改变不仅更加精准而且触碰的代码更少。</p></blockquote><h3 id="柯里化-Currying"><a href="#柯里化-Currying" class="headerlink" title="柯里化(Currying)"></a>柯里化(Currying)</h3><blockquote><p>是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。<br>使用匿名单参数函数来实现多参数函数的方法，如下：  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var foo = function(a) &#123;</span><br><span class="line">  return function(b) &#123;</span><br><span class="line">    return a * a + b * b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>好处：可以快速且简单的实现函数封装，让我们更专注于自己的设计；可以实现概念编程，从而完全不需要设计模式。<br><a href="https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96" target="_blank" rel="noopener">了解更多</a></p></blockquote><h3 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h3><p>如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = somewhatLongOperation1();</span><br><span class="line">String s2 = somewhatLongOperation2();</span><br><span class="line">String s3 = concatenate(s1, s2);</span><br></pre></td></tr></table></figure></p><p>其中s1和s2函数作为函数concatenate的参数，执行concatenate需要用到s1和s2的时候才去执行s1和s2函数。  </p><blockquote><p>支持惰性求值的编译器可以抵消相同项从而避免执行无谓的代码，安排代码执行顺序从而实现更高的执行效率甚至是减少错误。<br>惰性求值技术允许定义无穷数据结构，把很多问题抽象化，然后在更高的层面上解决它们。如定义一个Fibonacci数列的无穷列表结构，列表中只有真正会被用到的数才会被计算出来。<br>不足：因为不支持顺序执行，不能处理IO等必须顺序执行的操作。解决方案-continuations，monads以及uniqueness typing。</p></blockquote><h3 id="链式风格-continuation"><a href="#链式风格-continuation" class="headerlink" title="链式风格(continuation)"></a>链式风格(continuation)</h3><blockquote><p>continuation又称CPS（Continuation Programming Style）就是一种特别的参数，把这种参数传到函数中，函数就能够根据continuation将返回值传递到程序中的某段代码中。</p></blockquote><p>如下示例：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i = add(5, 10);</span><br><span class="line">int j = square(i);</span><br></pre></td></tr></table></figure><p>add这个函数将返回15然后这个值会赋给i，这也是add被调用的地方。接下来i的值又会被用于调用square。用Continuation Pass Style（CPS）技术重写如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int j = add(5, 10, square);</span><br></pre></td></tr></table></figure><p>add多了一个参数：一个函数，add必须在完成自己的计算后，调用这个函数并把结果传给它。这时square就是add的一个continuation。</p><blockquote><p>用CPS风格写出来的程序不需要栈，但是每次调用函数的时候都会要多加一个参数。<br>continuation和栈上指示函数返回地址的指针其实是同一样东西，只是continuation是显式的传递该地址并且因此代码就不局限于只能返回到函数被调用的地方了。  </p></blockquote><h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><blockquote><p>模式匹配并不是什么新功能。而事实上它和函数式编程也没有什么太大的关系。<br>有点类似重载，几个同名函数会根据具体参数选择最佳的执行函数。</p></blockquote><p>普通Fibonacci函数：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int fib(int n) &#123;</span><br><span class="line">    if(n == 0) return 1;</span><br><span class="line">    if(n == 1) return 1;</span><br><span class="line"></span><br><span class="line">    return fib(n - 2) + fib(n - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用模式匹配重写过的Fibonacci函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int fib(0) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">int fib(1) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">int fib(int n) &#123;</span><br><span class="line">    return fib(n - 2) + fib(n - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当n为0时，可以用函数int fib(int n)，不过真正调用的是int fib(0)因为这个函数更具体更接近调用者的要求。</p><h3 id="闭包-Closure"><a href="#闭包-Closure" class="headerlink" title="闭包(Closure)"></a>闭包(Closure)</h3><blockquote><p>在指令式语言中变量不是final，可以读写外部的状态的情况下，又想使用FP的高阶函数等特性，需要通过lexical closure支持。<br>返回类型为函数的函数，closure保存了指向其外部变量的引用。如下示例：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Function makeIncrementer() &#123;</span><br><span class="line">   int n = 0;</span><br><span class="line"></span><br><span class="line">   int increment() &#123;</span><br><span class="line">       return ++n;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Function inc1 = makeIncrementer();</span><br><span class="line">Function inc2 = makeIncrementer();</span><br><span class="line"></span><br><span class="line">inc1(); // returns 1;</span><br><span class="line">inc1(); // returns 2;</span><br><span class="line">inc1(); // returns 3;</span><br><span class="line">inc2(); // returns 1;</span><br><span class="line">inc2(); // returns 2;</span><br><span class="line">inc2(); // returns 3;</span><br></pre></td></tr></table></figure><p>参考：<br><a href="https://github.com/justinyhuang/Functional-Programming-For-The-Rest-of-Us-Cn" target="_blank" rel="noopener">傻瓜函数编程(https://github.com/justinyhuang/Functional-Programming-For-The-Rest-of-Us-Cn)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最早是从一些博客上看到过函数式编程，但是没有太在意。js支持将函数作为传出/传入参数，可以存储在变量中。java8中Lambda表达式 、Stream流处理等功能等闪亮登场，除此之外还支持函数接口。越来越多语言中引入函数式编程的特性，种种苗头都预示着函数式编程越来越得到重视。这里主要对函数式编程思想做一些理解和认识。&lt;br&gt;
    
    </summary>
    
      <category term="名词解释" scheme="https://dongz.me/categories/%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"/>
    
    
  </entry>
  
  <entry>
    <title>oracle递归查询</title>
    <link href="https://dongz.me/2018/12/18/oracle%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2/"/>
    <id>https://dongz.me/2018/12/18/oracle递归查询/</id>
    <published>2018-12-18T15:05:00.000Z</published>
    <updated>2018-12-18T16:03:25.248Z</updated>
    
    <content type="html"><![CDATA[<p>工作中遇到了递归查询部门树的需求，之前虽然用过，但隔的时间久了记不清具体用法。在这里mark一下，重新熟悉下<br><a id="more"></a></p><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span>  <span class="keyword">table</span> dept_tree(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> ,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">parent</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">comment</span> <span class="keyword">on</span> <span class="keyword">column</span> dept_tree.id <span class="keyword">is</span> <span class="string">'主键'</span>;</span><br><span class="line"><span class="keyword">comment</span> <span class="keyword">on</span> <span class="keyword">column</span> dept_tree.name <span class="keyword">is</span> <span class="string">'部门名称'</span>;</span><br><span class="line"><span class="keyword">comment</span> <span class="keyword">on</span> <span class="keyword">column</span> dept_tree.parent <span class="keyword">is</span> <span class="string">'父部门主键'</span>;</span><br></pre></td></tr></table></figure><h2 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h2><p>执行 <code>desc dept_tree;</code>  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">名称     空值       类型           </span><br><span class="line"><span class="comment">------ -------- ------------ </span></span><br><span class="line">ID     NOT NULL NUMBER(38)   </span><br><span class="line">NAME   NOT NULL VARCHAR2(20) </span><br><span class="line">PARENT NOT NULL NUMBER(38)</span><br></pre></td></tr></table></figure><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">1</span> , <span class="string">'部门1'</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">2</span> , <span class="string">'部门2'</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">3</span> , <span class="string">'部门3'</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">4</span> , <span class="string">'部门1-1'</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">5</span> , <span class="string">'部门1-2'</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">6</span> , <span class="string">'部门1-3'</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">7</span> , <span class="string">'部门2-1'</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">8</span> , <span class="string">'部门2-2'</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">9</span> , <span class="string">'部门3-1'</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">10</span> , <span class="string">'部门3-2'</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">11</span> , <span class="string">'部门3-3'</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">12</span> , <span class="string">'部门3-4'</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">13</span> , <span class="string">'部门3-5'</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">14</span> , <span class="string">'部门3-6'</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">15</span> , <span class="string">'部门3-6'</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">16</span> , <span class="string">'部门2-2-1'</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">17</span> , <span class="string">'部门2-2-2'</span>, <span class="number">8</span>);</span><br></pre></td></tr></table></figure><h2 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h2><h3 id="递归语法"><a href="#递归语法" class="headerlink" title="递归语法"></a>递归语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> [<span class="keyword">column</span>, ...] <span class="keyword">from</span> tablename</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> [condition1]</span><br><span class="line"><span class="keyword">connect</span> <span class="keyword">by</span> [condition2]</span><br><span class="line"><span class="keyword">where</span> [condition3];</span><br></pre></td></tr></table></figure><p><strong>condition1:</strong><br>根结点的限定语句，可以放宽限定条件，以取得多个根结点，实际就是多棵树；省略该条件或设置为1=1则是每个节点作为根节点遍历一遍。  </p><p><strong>condition2:</strong><br>连接条件，其中用PRIOR表示上一条记录。比如 CONNECT BY PRIOR id = parent，就是说上一条记录的id 是本条记录的parent，即本记录的父亲是上一条记录，递归方式为自顶向下顺序遍历；CONNECT BY id =  PRIOR parent，就是说上一条记录的parent是本条记录的id，即上一条记录的父亲是本记录，递归方式为自底向上顺序遍历。  </p><p><strong>condition3:</strong><br>是过滤条件，用于对返回的所有记录进行过滤。</p><h3 id="递归实例"><a href="#递归实例" class="headerlink" title="递归实例"></a>递归实例</h3><h4 id="根部门为17，向上遍历所有节点"><a href="#根部门为17，向上遍历所有节点" class="headerlink" title="根部门为17，向上遍历所有节点"></a>根部门为17，向上遍历所有节点</h4><blockquote><p>执行sql: </p></blockquote>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span>,sys_connect_by_path(<span class="keyword">name</span>, <span class="string">'=&gt;'</span>) namejoins, <span class="keyword">level</span></span><br><span class="line"><span class="keyword">from</span> dept_tree</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> dept_tree.id=<span class="number">17</span></span><br><span class="line"><span class="keyword">connect</span> <span class="keyword">by</span>  <span class="keyword">id</span> = <span class="keyword">prior</span> <span class="keyword">parent</span></span><br></pre></td></tr></table></figure><blockquote><p>执行结果:  </p></blockquote><table><thead><tr><th style="text-align:center">ID</th><th style="text-align:center">NAME</th><th style="text-align:center">NAMEJOINS</th><th style="text-align:center">LEVEL</th></tr></thead><tbody><tr><td style="text-align:center">17</td><td style="text-align:center">部门2-2-2</td><td style="text-align:center">=&gt;部门2-2-2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">部门2-2</td><td style="text-align:center">=&gt;部门2-2-2=&gt;部门2-2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">部门2</td><td style="text-align:center">=&gt;部门2-2-2=&gt;部门2-2=&gt;部门2</td><td style="text-align:center">3</td></tr></tbody></table><h4 id="根部门为17，向下遍历所有节点"><a href="#根部门为17，向下遍历所有节点" class="headerlink" title="根部门为17，向下遍历所有节点"></a>根部门为17，向下遍历所有节点</h4><blockquote><p>执行sql:  </p></blockquote>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span>,sys_connect_by_path(<span class="keyword">name</span>, <span class="string">'=&gt;'</span>) namejoins, <span class="keyword">level</span></span><br><span class="line"><span class="keyword">from</span> dept_tree</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> dept_tree.id=<span class="number">17</span></span><br><span class="line"><span class="keyword">connect</span> <span class="keyword">by</span>  <span class="keyword">prior</span> <span class="keyword">id</span> = <span class="keyword">parent</span></span><br></pre></td></tr></table></figure><blockquote><p>执行结果:  </p></blockquote><table><thead><tr><th style="text-align:center">ID</th><th style="text-align:center">NAME</th><th style="text-align:center">NAMEJOINS</th><th style="text-align:center">LEVEL</th></tr></thead><tbody><tr><td style="text-align:center">17</td><td style="text-align:center">部门2-2-2</td><td style="text-align:center">=&gt;部门2-2-2</td><td style="text-align:center">1</td></tr></tbody></table><h4 id="根部门不设置过滤条件，以所有节点作为根节点遍历"><a href="#根部门不设置过滤条件，以所有节点作为根节点遍历" class="headerlink" title="根部门不设置过滤条件，以所有节点作为根节点遍历"></a>根部门不设置过滤条件，以所有节点作为根节点遍历</h4><blockquote><p>执行sql:  </p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span>,sys_connect_by_path(<span class="keyword">name</span>, <span class="string">'=&gt;'</span>) namejoins, <span class="keyword">level</span></span><br><span class="line"><span class="keyword">from</span> dept_tree</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> <span class="number">1</span>=<span class="number">1</span></span><br><span class="line"><span class="keyword">connect</span> <span class="keyword">by</span>  <span class="keyword">prior</span> <span class="keyword">id</span> = <span class="keyword">parent</span></span><br></pre></td></tr></table></figure><blockquote><p>执行结果:</p></blockquote><table><thead><tr><th style="text-align:center">ID</th><th style="text-align:center">NAME</th><th style="text-align:center">NAMEJOINS</th><th style="text-align:center">LEVEL</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">部门1</td><td style="text-align:center">=&gt;部门1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">部门1-1</td><td style="text-align:center">=&gt;部门1=&gt;部门1-1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">部门1-2</td><td style="text-align:center">=&gt;部门1=&gt;部门1-2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">部门1-3</td><td style="text-align:center">=&gt;部门1=&gt;部门1-3</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">部门2</td><td style="text-align:center">=&gt;部门2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">部门2-1</td><td style="text-align:center">=&gt;部门2=&gt;部门2-1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">部门2-2</td><td style="text-align:center">=&gt;部门2=&gt;部门2-2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">部门2-2-1</td><td style="text-align:center">=&gt;部门2=&gt;部门2-2=&gt;部门2-2-1</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">17</td><td style="text-align:center">部门2-2-2</td><td style="text-align:center">=&gt;部门2=&gt;部门2-2=&gt;部门2-2-2</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">部门3</td><td style="text-align:center">=&gt;部门3</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">部门3-1</td><td style="text-align:center">=&gt;部门3=&gt;部门3-1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">部门3-2</td><td style="text-align:center">=&gt;部门3=&gt;部门3-2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">部门3-3</td><td style="text-align:center">=&gt;部门3=&gt;部门3-3</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">部门3-4</td><td style="text-align:center">=&gt;部门3=&gt;部门3-4</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">部门3-5</td><td style="text-align:center">=&gt;部门3=&gt;部门3-5</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">部门3-6</td><td style="text-align:center">=&gt;部门3=&gt;部门3-6</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">部门3-6</td><td style="text-align:center">=&gt;部门3=&gt;部门3-6</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">部门1-1</td><td style="text-align:center">=&gt;部门1-1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">部门1-2</td><td style="text-align:center">=&gt;部门1-2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">部门1-3</td><td style="text-align:center">=&gt;部门1-3</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">部门2-1</td><td style="text-align:center">=&gt;部门2-1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">部门2-2</td><td style="text-align:center">=&gt;部门2-2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">部门2-2-1</td><td style="text-align:center">=&gt;部门2-2=&gt;部门2-2-1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">17</td><td style="text-align:center">部门2-2-2</td><td style="text-align:center">=&gt;部门2-2=&gt;部门2-2-2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">部门3-1</td><td style="text-align:center">=&gt;部门3-1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">部门3-2</td><td style="text-align:center">=&gt;部门3-2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">部门3-3</td><td style="text-align:center">=&gt;部门3-3</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">部门3-4</td><td style="text-align:center">=&gt;部门3-4</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">部门3-5</td><td style="text-align:center">=&gt;部门3-5</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">部门3-6</td><td style="text-align:center">=&gt;部门3-6</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">部门3-6</td><td style="text-align:center">=&gt;部门3-6</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">部门2-2-1</td><td style="text-align:center">=&gt;部门2-2-1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">17</td><td style="text-align:center">部门2-2-2</td><td style="text-align:center">=&gt;部门2-2-2</td><td style="text-align:center">1</td></tr></tbody></table><blockquote><p>这时自底向上执行如下sql输出结果同上:     </p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span>,sys_connect_by_path(<span class="keyword">name</span>, <span class="string">'=&gt;'</span>) namejoins, <span class="keyword">level</span></span><br><span class="line"><span class="keyword">from</span> dept_tree</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> <span class="number">1</span>=<span class="number">1</span></span><br><span class="line"><span class="keyword">connect</span> <span class="keyword">by</span> <span class="keyword">id</span> = <span class="keyword">prior</span> <span class="keyword">parent</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作中遇到了递归查询部门树的需求，之前虽然用过，但隔的时间久了记不清具体用法。在这里mark一下，重新熟悉下&lt;br&gt;
    
    </summary>
    
      <category term="积累" scheme="https://dongz.me/categories/%E7%A7%AF%E7%B4%AF/"/>
    
      <category term="数据存储" scheme="https://dongz.me/categories/%E7%A7%AF%E7%B4%AF/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>HTTP常见状态码</title>
    <link href="https://dongz.me/2018/12/16/HTTP%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <id>https://dongz.me/2018/12/16/HTTP常见状态码/</id>
    <published>2018-12-16T15:12:00.000Z</published>
    <updated>2018-12-16T15:14:09.557Z</updated>
    
    <content type="html"><![CDATA[<p>当浏览器向服务器发送请求后，服务端会返回一个状态码用以表示服务器当响应状态，可以根据具体的返回码分析请求状态及问题出现的可能原因。<a id="more"></a></p><h2 id="1xx临时响应"><a href="#1xx临时响应" class="headerlink" title="1xx临时响应"></a>1xx临时响应</h2><blockquote><p>表示临时响应并需要请求者继续执行操作的状态码  </p></blockquote><ul><li>100 (继续) 服务器仅接收到部分请求，客户端应该继续发送其余的请求</li><li>101 (切换协议) 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</li></ul><h2 id="2xx成功"><a href="#2xx成功" class="headerlink" title="2xx成功"></a>2xx成功</h2><blockquote><p>表示成功处理了请求的状态码</p></blockquote><ul><li>200 (成功) 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页</li><li>201 (已创建) 成功请求并创建了新的资源</li><li>202 (已接受) 请求已被服务器接受，但是处理未完成</li><li>203 (非授权信息) 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</li><li>204 (无内容) 服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</li><li>205 (重置内容) 服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</li><li>206 (部分内容) 客户发送了一个带有Range头的GET请求，服务器完成了它</li></ul><h2 id="3xx重定向"><a href="#3xx重定向" class="headerlink" title="3xx重定向"></a>3xx重定向</h2><blockquote><p>表示要完成请求，需要进一步操作。 通常，这些状态码用来重定向</p></blockquote><ul><li>300 (多种选择) 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</li><li>301 (永久移动) 所请求的页面已经转移至新的URI，并将请求转到新URI</li><li>302 (临时移动) 与301类似。但资源只是临时被移动。客户端应继续使用原有URI</li><li>303 (查看其他地址) 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码</li><li>304 (未修改) 所请求的资源未修改（一般是提供If-Modified-Since头表示客户只想比指定日期更新的资源），服务器返回此状态码时，不会返回任何资源</li><li>305 (使用代理) 客户请求的资源应该通过Location头所指明的代理服务器提取</li><li>307 (临时重定向) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</li></ul><h2 id="4xx客户端错误"><a href="#4xx客户端错误" class="headerlink" title="4xx客户端错误"></a>4xx客户端错误</h2><blockquote><p>这些状态码表示请求可能出错，妨碍了服务器的处理。</p></blockquote><ul><li>400 (错误请求) 服务器未能理解请求</li><li>401 (未授权) 请求要求用户的身份认证</li><li>403 (禁止) 服务器端拒绝执行客户端请求</li><li>404 (未找到) 服务器找不到请求的网页</li><li>405 (方法禁用) 请求中指定的方法不被允许</li><li>406 (不接受) 服务器无法根据客户端请求的内容特性完成请求</li><li>407 (需要代理授权) 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</li><li>408 (请求超时) 请求超出了服务器的等待时间</li><li>409 (冲突) 服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息</li><li>410 (已删除) 如果请求的资源已永久删除，服务器就会返回此响应</li><li>411 (需要有效长度) 服务器无法处理客户端发送的不带Content-Length的请求信息</li><li>412 (未满足前提条件) 请求中的前提条件被服务器判定为失败</li><li>413 (请求实体过大) 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</li><li>414 (请求的 URI 过长) 请求的URI过长（URI通常为网址），服务器无法处理</li><li>415 (不支持的媒体类型) 服务器无法处理请求附带的媒体格式</li><li>416 (请求范围不符合要求) 服务器不能满足客户在请求中指定的Range头</li><li>417 (未满足期望值) 服务器无法满足Expect的请求头信息</li></ul><h2 id="5xx服务器端错误"><a href="#5xx服务器端错误" class="headerlink" title="5xx服务器端错误"></a>5xx服务器端错误</h2><blockquote><p>表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</p></blockquote><ul><li>500 (服务器内部错误) 服务器遇到错误，无法完成请求</li><li>501 (尚未实施) 服务器不具备完成请求的功能 例如，服务器无法识别请求方法时可能会返回此代码</li><li>502 (错误网关) 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</li><li>503 (服务不可用) 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</li><li>504 (网关超时) 服务器作为网关或代理，但是没有及时从上游服务器收到请求</li><li>505 (HTTP 版本不受支持) 服务器不支持请求中所用的 HTTP 协议版本</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当浏览器向服务器发送请求后，服务端会返回一个状态码用以表示服务器当响应状态，可以根据具体的返回码分析请求状态及问题出现的可能原因。
    
    </summary>
    
      <category term="网络" scheme="https://dongz.me/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>[music]-[ツナ覚醒]</title>
    <link href="https://dongz.me/2018/12/13/music-%E3%83%84%E3%83%8A%E8%A6%9A%E9%86%92/"/>
    <id>https://dongz.me/2018/12/13/music-ツナ覚醒/</id>
    <published>2018-12-12T16:28:00.000Z</published>
    <updated>2018-12-12T16:35:21.363Z</updated>
    
    <content type="html"><![CDATA[<p>一步超然动画片《家庭教师》中的插曲，特别喜欢这种燃炸天的节奏♡♡♡♡♡<br><a id="more"></a></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=29023858&auto=1&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一步超然动画片《家庭教师》中的插曲，特别喜欢这种燃炸天的节奏♡♡♡♡♡&lt;br&gt;
    
    </summary>
    
      <category term="音乐" scheme="https://dongz.me/categories/%E9%9F%B3%E4%B9%90/"/>
    
    
  </entry>
  
  <entry>
    <title>风暴之集合</title>
    <link href="https://dongz.me/2018/12/12/%E9%A3%8E%E6%9A%B4%E4%B9%8B%E9%9B%86%E5%90%88/"/>
    <id>https://dongz.me/2018/12/12/风暴之集合/</id>
    <published>2018-12-11T16:51:00.000Z</published>
    <updated>2018-12-11T16:57:41.497Z</updated>
    
    <content type="html"><![CDATA[<p>java中容器，也称集合可以容纳其它类型数据。在平时也接触类不少比如ArrayList、HashSet、LinkedList、HashMap、TreeMap等等，但真要细说还真一知半解，大体风暴类一下，有不当的地方欢迎评论中指出～～<br><a id="more"></a>  </p><h1 id="风暴之集合"><a href="#风暴之集合" class="headerlink" title="风暴之集合"></a>风暴之集合</h1><p><img src="https://coding.net/u/alvin_me/p/blogpics/git/raw/master/rongqiorjihe.jpg" alt=""></p><p><a href="http://www.edrawsoft.cn/viewer/public/s/ec6e5017846566" target="_blank" rel="noopener">看大图</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java中容器，也称集合可以容纳其它类型数据。在平时也接触类不少比如ArrayList、HashSet、LinkedList、HashMap、TreeMap等等，但真要细说还真一知半解，大体风暴类一下，有不当的地方欢迎评论中指出～～&lt;br&gt;
    
    </summary>
    
      <category term="集合" scheme="https://dongz.me/categories/%E9%9B%86%E5%90%88/"/>
    
    
      <category term="集合" scheme="https://dongz.me/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>风暴之mysql</title>
    <link href="https://dongz.me/2018/12/11/%E9%A3%8E%E6%9A%B4%E4%B9%8Bmysql/"/>
    <id>https://dongz.me/2018/12/11/风暴之mysql/</id>
    <published>2018-12-10T16:40:00.000Z</published>
    <updated>2018-12-10T17:01:35.394Z</updated>
    
    <content type="html"><![CDATA[<p>本篇以mysql常见维度展开头脑风暴。维度包括数据的存储结构、数据库事务、mysql中常见的锁、mysql使用优化、mysql中常见日志。图中有不当的地方请留言指出～～<br><a id="more"></a>  </p><h1 id="风暴之mysql"><a href="#风暴之mysql" class="headerlink" title="风暴之mysql"></a>风暴之mysql</h1><p><img src="https://coding.net/u/alvin_me/p/blogpics/git/raw/master/mysql.jpg" alt=""></p><p><a href="http://www.edrawsoft.cn/viewer/public/s/b8368745248662" target="_blank" rel="noopener">看大图</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇以mysql常见维度展开头脑风暴。维度包括数据的存储结构、数据库事务、mysql中常见的锁、mysql使用优化、mysql中常见日志。图中有不当的地方请留言指出～～&lt;br&gt;
    
    </summary>
    
      <category term="数据存储" scheme="https://dongz.me/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="mysql" scheme="https://dongz.me/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>风暴之线上问题排查</title>
    <link href="https://dongz.me/2018/11/29/%E9%A3%8E%E6%9A%B4%E4%B9%8B%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    <id>https://dongz.me/2018/11/29/风暴之线上问题排查/</id>
    <published>2018-11-28T16:23:00.000Z</published>
    <updated>2018-12-10T17:02:37.966Z</updated>
    
    <content type="html"><![CDATA[<p>实际生产环境下，应用不可避免的会遇到各种各样的问题，要熟练掌握一些命令和工具，以快速排查定位线上问题。<br><a id="more"></a>  </p><h1 id="风暴之线上问题排查"><a href="#风暴之线上问题排查" class="headerlink" title="风暴之线上问题排查"></a>风暴之线上问题排查</h1><p><img src="https://coding.net/u/alvin_me/p/blogpics/git/raw/master/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5.png" alt=""></p><p><a href="http://www.edrawsoft.cn/viewer/public/s/72167602893328" target="_blank" rel="noopener">看大图</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实际生产环境下，应用不可避免的会遇到各种各样的问题，要熟练掌握一些命令和工具，以快速排查定位线上问题。&lt;br&gt;
    
    </summary>
    
      <category term="积累" scheme="https://dongz.me/categories/%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="问题排查" scheme="https://dongz.me/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>风暴之并发和多线程</title>
    <link href="https://dongz.me/2018/11/29/%E9%A3%8E%E6%9A%B4%E4%B9%8B%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://dongz.me/2018/11/29/风暴之并发和多线程/</id>
    <published>2018-11-28T16:18:00.000Z</published>
    <updated>2018-12-10T17:03:00.135Z</updated>
    
    <content type="html"><![CDATA[<p>并发和多线程是Java编程中避不开的话题，今天主要对并发和多线程相关知识进行下头脑风暴。<br><a id="more"></a></p><h1 id="风暴之并发和多线程"><a href="#风暴之并发和多线程" class="headerlink" title="风暴之并发和多线程"></a>风暴之并发和多线程</h1><p><img src="https://coding.net/u/alvin_me/p/blogpics/git/raw/master/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" alt=""></p><p><a href="http://www.edrawsoft.cn/viewer/public/s/7e9bd056155369" target="_blank" rel="noopener">看大图</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并发和多线程是Java编程中避不开的话题，今天主要对并发和多线程相关知识进行下头脑风暴。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://dongz.me/categories/java/"/>
    
    
      <category term="并发" scheme="https://dongz.me/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="多线程" scheme="https://dongz.me/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>风暴之Redis</title>
    <link href="https://dongz.me/2018/11/29/%E9%A3%8E%E6%9A%B4%E4%B9%8BRedis/"/>
    <id>https://dongz.me/2018/11/29/风暴之Redis/</id>
    <published>2018-11-28T16:01:00.000Z</published>
    <updated>2018-12-10T17:03:26.961Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。<br><a id="more"></a></p><h1 id="风暴之Redis"><a href="#风暴之Redis" class="headerlink" title="风暴之Redis"></a>风暴之Redis</h1><p><img src="https://coding.net/u/alvin_me/p/blogpics/git/raw/master/redis%E7%9F%A5%E8%AF%86.png" alt=""></p><p><a href="http://www.edrawsoft.cn/viewer/public/s/0be97318174746" target="_blank" rel="noopener">看大图</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。&lt;br&gt;
    
    </summary>
    
      <category term="数据存储" scheme="https://dongz.me/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="redis" scheme="https://dongz.me/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>风暴之JVM</title>
    <link href="https://dongz.me/2018/11/28/%E9%A3%8E%E6%9A%B4%E4%B9%8BJVM/"/>
    <id>https://dongz.me/2018/11/28/风暴之JVM/</id>
    <published>2018-11-28T15:51:00.000Z</published>
    <updated>2018-12-10T17:03:39.290Z</updated>
    
    <content type="html"><![CDATA[<p>Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够”一次编译，到处运行“的原因。了解JVM底层有助于理解Java工作原理，更好的编程。<br><a id="more"></a></p><h1 id="风暴之JVM"><a href="#风暴之JVM" class="headerlink" title="风暴之JVM"></a>风暴之JVM</h1><p><img src="https://coding.net/u/alvin_me/p/blogpics/git/raw/master/jvm%E7%9B%B8%E5%85%B3.jpg" alt="">  </p><p><a href="http://www.edrawsoft.cn/viewer/public/s/41a60748487374" target="_blank" rel="noopener">看大图</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够”一次编译，到处运行“的原因。了解JVM底层有助于理解Java工作原理，更好的编程。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://dongz.me/categories/java/"/>
    
    
      <category term="jvm" scheme="https://dongz.me/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>风暴之Spring事务</title>
    <link href="https://dongz.me/2018/10/27/%E9%A3%8E%E6%9A%B4%E4%B9%8BSpring%E4%BA%8B%E5%8A%A1/"/>
    <id>https://dongz.me/2018/10/27/风暴之Spring事务/</id>
    <published>2018-10-27T02:14:00.000Z</published>
    <updated>2018-12-10T17:04:18.020Z</updated>
    
    <content type="html"><![CDATA[<p>Spring 简单而强大的事务管理功能，包括编程式事务和声明式事务。通过对相关知识梳理，能够理解 Spring 事务管理的本质，并灵活运用之。<br><a id="more"></a></p><h1 id="风暴之Spring事务"><a href="#风暴之Spring事务" class="headerlink" title="风暴之Spring事务"></a>风暴之Spring事务</h1><p><img src="https://coding.net/u/alvin_me/p/blogpics/git/raw/master/spring%E4%BA%8B%E5%8A%A1.jpg" alt="Spring事务"></p><p><a href="http://www.edrawsoft.cn/viewer/public/s/4cbc1230271951" target="_blank" rel="noopener">看大图</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="https://www.ibm.com/developerworks/cn/education/opensource/os-cn-spring-trans/index.html" target="_blank" rel="noopener">全面分析 Spring 的编程式事务管理及声明式事务管理</a><br>[2] <a href="https://juejin.im/post/5b00c52ef265da0b95276091" target="_blank" rel="noopener">可能是最漂亮的Spring事务管理详解</a><br>[3] <a href="https://juejin.im/post/5a5c631e6fb9a01cb508cd3d" target="_blank" rel="noopener">Spring核心系列之Spring中的事务</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring 简单而强大的事务管理功能，包括编程式事务和声明式事务。通过对相关知识梳理，能够理解 Spring 事务管理的本质，并灵活运用之。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://dongz.me/categories/java/"/>
    
    
      <category term="spring" scheme="https://dongz.me/tags/spring/"/>
    
      <category term="事务" scheme="https://dongz.me/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>风暴之Aop</title>
    <link href="https://dongz.me/2018/10/25/%E9%A3%8E%E6%9A%B4%E4%B9%8BAop/"/>
    <id>https://dongz.me/2018/10/25/风暴之Aop/</id>
    <published>2018-10-24T16:34:00.000Z</published>
    <updated>2018-12-02T14:25:44.654Z</updated>
    
    <content type="html"><![CDATA[<p>面向切面编程<br><a id="more"></a></p><h1 id="风暴之Aop"><a href="#风暴之Aop" class="headerlink" title="风暴之Aop"></a>风暴之Aop</h1><p><img src="https://coding.net/u/alvin_me/p/blogpics/git/raw/master/spring%20aop.jpg" alt=""></p><p><a href="http://www.edrawsoft.cn/viewer/public/s/032fa832508900" target="_blank" rel="noopener">看大图</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/index.html" target="_blank" rel="noopener">Spring AOP 实现原理与 CGLIB 应用</a><br>[2] <a href="http://www.importnew.com/24305.html" target="_blank" rel="noopener">Spring AOP的实现原理</a><br>[3] <a href="https://juejin.im/post/5af3bd6f518825673954bf22" target="_blank" rel="noopener">Spring AOP实现原理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面向切面编程&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://dongz.me/categories/java/"/>
    
    
      <category term="aop" scheme="https://dongz.me/tags/aop/"/>
    
  </entry>
  
  <entry>
    <title>风暴之Rocketmq消息有序</title>
    <link href="https://dongz.me/2018/10/25/%E9%A3%8E%E6%9A%B4%E4%B9%8BRocketmq%E6%B6%88%E6%81%AF%E6%9C%89%E5%BA%8F/"/>
    <id>https://dongz.me/2018/10/25/风暴之Rocketmq消息有序/</id>
    <published>2018-10-24T16:17:00.000Z</published>
    <updated>2018-12-02T14:25:57.171Z</updated>
    
    <content type="html"><![CDATA[<p>Rocketmq消息有序知识梳理<br><a id="more"></a></p><h1 id="风暴之Rocketmq消息有序"><a href="#风暴之Rocketmq消息有序" class="headerlink" title="风暴之Rocketmq消息有序"></a>风暴之Rocketmq消息有序</h1><p><img src="https://coding.net/u/alvin_me/p/blogpics/git/raw/master/rocketmq%E6%9C%89%E5%BA%8F.jpg" alt="">  </p><p><a href="http://www.edrawsoft.cn/viewer/public/s/44af6152338359" target="_blank" rel="noopener">看大图</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="https://www.zhihu.com/question/30195969" target="_blank" rel="noopener">rocketmq怎么保证队列完全顺序消费？</a><br>[2] <a href="https://www.jianshu.com/p/453c6e7ff81c" target="_blank" rel="noopener">分布式开放消息系统(RocketMQ)的原理与实践</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Rocketmq消息有序知识梳理&lt;br&gt;
    
    </summary>
    
      <category term="消息" scheme="https://dongz.me/categories/%E6%B6%88%E6%81%AF/"/>
    
    
      <category term="rocketmq" scheme="https://dongz.me/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>风暴之分布式事务</title>
    <link href="https://dongz.me/2018/10/24/%E9%A3%8E%E6%9A%B4%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <id>https://dongz.me/2018/10/24/风暴之分布式事务/</id>
    <published>2018-10-23T16:23:00.000Z</published>
    <updated>2018-12-10T17:06:23.075Z</updated>
    
    <content type="html"><![CDATA[<p>分布式事务是企业集成中的一个技术难点，也是每一个分布式系统架构中都会涉及到的一个东西，特别是在微服务架构中，几乎可以说是无法避免，本文通过思维导图做一个简单的知识梳理。<br><a id="more"></a></p><h1 id="风暴之分布式事务"><a href="#风暴之分布式事务" class="headerlink" title="风暴之分布式事务"></a>风暴之分布式事务</h1><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="800" height="800" src="http://edrawcloudpubliccn.oss-cn-shenzhen.aliyuncs.com/viewer/self/220828/share/2018-10-31/1540946315/main.svg"></iframe><p><a href="http://www.edrawsoft.cn/viewer/public/s/4c0fe347331170" target="_blank" rel="noopener">看大图</a></p><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p>[1] <a href="https://draveness.me/distributed-transaction-principle" target="_blank" rel="noopener">分布式事务的实现原理</a><br>[2] <a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" target="_blank" rel="noopener">聊聊分布式事务，再说说解决方案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分布式事务是企业集成中的一个技术难点，也是每一个分布式系统架构中都会涉及到的一个东西，特别是在微服务架构中，几乎可以说是无法避免，本文通过思维导图做一个简单的知识梳理。&lt;br&gt;
    
    </summary>
    
      <category term="分布式" scheme="https://dongz.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式事务" scheme="https://dongz.me/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之传输对象模式</title>
    <link href="https://dongz.me/2018/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongz.me/2018/10/21/设计模式之传输对象模式/</id>
    <published>2018-10-21T04:46:00.000Z</published>
    <updated>2018-10-21T04:47:51.901Z</updated>
    
    <content type="html"><![CDATA[<p>传输对象模式（Transfer Object Pattern）用于从客户端向服务器一次性传递带有多个属性的数据。传输对象也被称为数值对象。传输对象是一个具有 getter/setter 方法的简单的 POJO 类，它是可序列化的，所以它可以通过网络传输。它没有任何的行为。服务器端的业务类通常从数据库读取数据，然后填充 POJO，并把它发送到客户端或按值传递它。对于客户端，传输对象是只读的。客户端可以创建自己的传输对象，并把它传递给服务器，以便一次性更新数据库中的数值。以下是这种设计模式的实体。</p><ul><li><strong>业务对象（Business Object）</strong> - 为传输对象填充数据的业务服务。</li><li><strong>传输对象（Transfer Object）</strong> - 简单的 POJO，只有设置/获取属性的方法。</li><li><strong>客户端（Client）</strong> - 客户端可以发送请求或者发送传输对象到业务对象。<a id="more"></a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传输对象模式（Transfer Object Pattern）用于从客户端向服务器一次性传递带有多个属性的数据。传输对象也被称为数值对象。传输对象是一个具有 getter/setter 方法的简单的 POJO 类，它是可序列化的，所以它可以通过网络传输。它没有任何的行为。服务器端的业务类通常从数据库读取数据，然后填充 POJO，并把它发送到客户端或按值传递它。对于客户端，传输对象是只读的。客户端可以创建自己的传输对象，并把它传递给服务器，以便一次性更新数据库中的数值。以下是这种设计模式的实体。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;业务对象（Business Object）&lt;/strong&gt; - 为传输对象填充数据的业务服务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;传输对象（Transfer Object）&lt;/strong&gt; - 简单的 POJO，只有设置/获取属性的方法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;客户端（Client）&lt;/strong&gt; - 客户端可以发送请求或者发送传输对象到业务对象。
    
    </summary>
    
      <category term="设计模式" scheme="https://dongz.me/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="传输对象模式" scheme="https://dongz.me/tags/%E4%BC%A0%E8%BE%93%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
