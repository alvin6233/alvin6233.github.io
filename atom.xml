<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>alvin&#39;s blog</title>
  
  <subtitle>Good memory is worse than bad writing</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dongme.site/"/>
  <updated>2018-10-16T17:12:06.401Z</updated>
  <id>https://dongme.site/</id>
  
  <author>
    <name>alvin dong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式之适配器模式</title>
    <link href="https://dongme.site/2018/10/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongme.site/2018/10/17/设计模式之适配器模式/</id>
    <published>2018-10-16T17:08:00.000Z</published>
    <updated>2018-10-16T17:12:06.401Z</updated>
    
    <content type="html"><![CDATA[<p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。</p><p>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。</p><p>我们通过下面的实例来演示适配器模式的使用。其中，音频播放器设备只能播放 mp3 文件，通过使用一个更高级的音频播放器来播放 vlc 和 mp4 文件。</p><a id="more"></a><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><strong>意图：</strong> 将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p><strong>主要解决：</strong> 主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。</p><p><strong>何时使用：</strong> 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）</p><p><strong>如何解决：</strong> 继承或依赖（推荐）。</p><p><strong>关键代码：</strong> 适配器继承或依赖已有的对象，实现想要的目标接口。</p><p><strong>应用实例： </strong> 1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。</p><p><strong>优点：</strong> 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。</p><p><strong>缺点：</strong> 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。</p><p><strong>使用场景：</strong> 有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。</p><p><strong>注意事项：</strong> 适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>我们有一个 MediaPlayer 接口和一个实现了 MediaPlayer 接口的实体类 AudioPlayer。默认情况下，AudioPlayer 可以播放 mp3 格式的音频文件。</p><p>我们还有另一个接口 AdvancedMediaPlayer 和实现了 AdvancedMediaPlayer 接口的实体类。该类可以播放 vlc 和 mp4 格式的文件。</p><p>我们想要让 AudioPlayer 播放其他格式的音频文件。为了实现这个功能，我们需要创建一个实现了 MediaPlayer 接口的适配器类 MediaAdapter，并使用 AdvancedMediaPlayer 对象来播放所需的格式。</p><p>AudioPlayer 使用适配器类 MediaAdapter 传递所需的音频类型，不需要知道能播放所需格式音频的实际类。AdapterPatternDemo，我们的演示类使用 AudioPlayer 类来播放各种格式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。&lt;/p&gt;
&lt;p&gt;这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。&lt;/p&gt;
&lt;p&gt;我们通过下面的实例来演示适配器模式的使用。其中，音频播放器设备只能播放 mp3 文件，通过使用一个更高级的音频播放器来播放 vlc 和 mp4 文件。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://dongme.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="适配器模式" scheme="https://dongme.site/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之原型模式</title>
    <link href="https://dongme.site/2018/10/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongme.site/2018/10/17/设计模式之原型模式/</id>
    <published>2018-10-16T17:06:41.000Z</published>
    <updated>2018-10-16T17:07:27.613Z</updated>
    
    <content type="html"><![CDATA[<p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。  </p><a id="more"></a><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><strong>意图：</strong> 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。<br><strong>主要解决：</strong> 在运行期建立和删除原型。<br><strong>何时使用：</strong> 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。<br><strong>如何解决：</strong> 利用已有的一个原型对象，快速地生成和原型对象一样的实例。<br><strong>关键代码：</strong> 1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些”易变类”拥有稳定的接口。<br><strong>应用实例：</strong> 1、细胞分裂。 2、JAVA 中的 Object clone() 方法。<br><strong>优点：</strong> 1、性能提高。 2、逃避构造函数的约束。<br><strong>缺点：</strong> 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。<br><strong>使用场景：</strong> 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。<br><strong>注意事项：</strong> 与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。  </p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>我们将创建一个抽象类 Shape 和扩展了 Shape 类的实体类。下一步是定义类 ShapeCache，该类把 shape 对象存储在一个 Hashtable 中，并在请求的时候返回它们的克隆。<br>PrototypePatternDemo，我们的演示类使用 ShapeCache 类来获取 Shape 对象。  </p><p><img src="http://ombpxfki1.bkt.clouddn.com/prototype-1.png" alt="">  </p><h5 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h5><p>创建一个实现了Clonable接口的抽象类。<br>Shape.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">protected</span> String type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object clone = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clone = <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h5><p>创建扩展了上面抽象类的实体类。<br>Rectangle.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">()</span></span>&#123;</span><br><span class="line">     type = <span class="string">"Rectangle"</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Rectangle::draw() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Square.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Square</span><span class="params">()</span></span>&#123;</span><br><span class="line">     type = <span class="string">"Square"</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Square::draw() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Circle.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">()</span></span>&#123;</span><br><span class="line">     type = <span class="string">"Circle"</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Circle::draw() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="步骤3"><a href="#步骤3" class="headerlink" title="步骤3"></a>步骤3</h5><p>创建一个类，从数据库获取实体类，并把它们存储在一个Hashtable中。<br>ShapeCache.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Hashtable&lt;String, Shape&gt; shapeMap</span><br><span class="line">            = <span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Shape <span class="title">getShape</span><span class="params">(String shapeId)</span> </span>&#123;</span><br><span class="line">        Shape cacheShape = shapeMap.get(shapeId);</span><br><span class="line">        <span class="keyword">return</span> (Shape) cacheShape.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每种形状都运行数据库查询，并创建该形状</span></span><br><span class="line">    <span class="comment">// shapeMap.put(shapeKey, shape);</span></span><br><span class="line">    <span class="comment">// 例如，我们要添加三种形状</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Circle circle = <span class="keyword">new</span> Circle();</span><br><span class="line">        circle.setId(<span class="string">"1"</span>);</span><br><span class="line">        shapeMap.put(circle.getId(), circle);</span><br><span class="line"></span><br><span class="line">        Square square = <span class="keyword">new</span> Square();</span><br><span class="line">        square.setId(<span class="string">"2"</span>);</span><br><span class="line">        shapeMap.put(square.getId(), square);</span><br><span class="line"></span><br><span class="line">        Rectangle rectangle = <span class="keyword">new</span> Rectangle();</span><br><span class="line">        rectangle.setId(<span class="string">"3"</span>);</span><br><span class="line">        shapeMap.put(rectangle.getId(), rectangle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="步骤4"><a href="#步骤4" class="headerlink" title="步骤4"></a>步骤4</h5><p>PrototypePatternDemo使用ShapeCache类来获取存储在Hashtable中的形状的克隆<br>PrototypePatternDemo.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypePatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShapeCache.loadCache();</span><br><span class="line"></span><br><span class="line">        Shape clonedShape = (Shape) ShapeCache.getShape(<span class="string">"1"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Shape : "</span> + clonedShape.getType());</span><br><span class="line"></span><br><span class="line">        Shape clonedShape2 = (Shape) ShapeCache.getShape(<span class="string">"2"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Shape : "</span> + clonedShape2.getType());</span><br><span class="line"></span><br><span class="line">        Shape clonedShape3 = (Shape) ShapeCache.getShape(<span class="string">"3"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Shape : "</span> + clonedShape3.getType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="步骤5"><a href="#步骤5" class="headerlink" title="步骤5"></a>步骤5</h5><p>执行输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Shape : Circle</span><br><span class="line">Shape : Square</span><br><span class="line">Shape : Rectangle</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。&lt;br&gt;这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。  &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式之建造者模式</title>
    <link href="https://dongme.site/2018/10/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongme.site/2018/10/17/设计模式之建造者模式/</id>
    <published>2018-10-16T17:04:55.000Z</published>
    <updated>2018-10-16T17:05:54.623Z</updated>
    
    <content type="html"><![CDATA[<p>建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。<br><a id="more"></a></p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><strong>意图：</strong> 将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br><strong>主要解决：</strong> 主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。<br><strong>何时使用：</strong> 一些基本部件不会变，而其组合经常变化的时候。<br><strong>如何解决：</strong> 将变与不变分离开。<br><strong>关键代码：</strong> 建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。<br><strong>应用实例：</strong> 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐”。 2、JAVA 中的 StringBuilder。<br><strong>优点：</strong> 1、建造者独立，易扩展。 2、便于控制细节风险。<br><strong>缺点：</strong> 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。<br><strong>使用场景：</strong> 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。<br><strong>注意事项：</strong> 与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。  </p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。<br>我们将创建一个表示食物条目（比如汉堡和冷饮）的 Item 接口和实现 Item 接口的实体类，以及一个表示食物包装的 Packing 接口和实现 Packing 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。<br>然后我们创建一个 Meal 类，带有 Item 的 ArrayList 和一个通过结合 Item 来创建不同类型的 Meal 对象的 MealBuilder。BuilderPatternDemo，我们的演示类使用 MealBuilder 来创建一个 Meal。  </p><p><img src="http://ombpxfki1.bkt.clouddn.com/builder-1.png" alt="">  </p><h5 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h5><p>创建一个包含事物条目和事物包装的接口。<br>Item.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Packing <span class="title">packing</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span></span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Packing.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Packing</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">pack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h5><p>创建实现Packing接口的实体类。<br>Wrapper.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> <span class="keyword">implements</span> <span class="title">Packing</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">pack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Wrapper"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Bottle.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bottle</span> <span class="keyword">implements</span> <span class="title">Packing</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">pack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Bottle"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="步骤3"><a href="#步骤3" class="headerlink" title="步骤3"></a>步骤3</h5><p>创建实现item接口的抽象类，该类提供了默认的功能。<br>Burger.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Burger</span> <span class="keyword">implements</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Packing <span class="title">packing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Wrapper();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ColdDrink.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ColdDrink</span> <span class="keyword">implements</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Packing <span class="title">packing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Bottle();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建扩展了Burger和ColdDrink的实体类。<br>VegBurger.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VegBurger</span> <span class="keyword">extends</span> <span class="title">Burger</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">25.0f</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Veg Burger"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ChickenBurger.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChickenBurger</span> <span class="keyword">extends</span> <span class="title">Burger</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">50.5f</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Chicken Burger"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Coke.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coke</span> <span class="keyword">extends</span> <span class="title">ColdDrink</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">30.0f</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Coke"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Pepsi.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pepsi</span> <span class="keyword">extends</span> <span class="title">ColdDrink</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">35.0f</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Pepsi"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="步骤5"><a href="#步骤5" class="headerlink" title="步骤5"></a>步骤5</h5><p>创建一个Meal类（套餐），带有上面定义的Item对象。<br>Meal.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Meal</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> List&lt;Item&gt; items = <span class="keyword">new</span> ArrayList&lt;Item&gt;();    </span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addItem</span><span class="params">(Item item)</span></span>&#123;</span><br><span class="line">      items.add(item);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getCost</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">float</span> cost = <span class="number">0.0f</span>;</span><br><span class="line">      <span class="keyword">for</span> (Item item : items) &#123;</span><br><span class="line">         cost += item.price();</span><br><span class="line">      &#125;        </span><br><span class="line">      <span class="keyword">return</span> cost;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showItems</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (Item item : items) &#123;</span><br><span class="line">         System.out.print(<span class="string">"Item : "</span>+item.name());</span><br><span class="line">         System.out.print(<span class="string">", Packing : "</span>+item.packing().pack());</span><br><span class="line">         System.out.println(<span class="string">", Price : "</span>+item.price());</span><br><span class="line">      &#125;        </span><br><span class="line">   &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="步骤6"><a href="#步骤6" class="headerlink" title="步骤6"></a>步骤6</h5><p>创建一个MealBuilder类，实际的builder类负责创建Meal对象。<br>MealBuilder.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MealBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Meal <span class="title">prepareVegMeal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Meal meal = <span class="keyword">new</span> Meal();</span><br><span class="line">        meal.addItem(<span class="keyword">new</span> VegBurger());</span><br><span class="line">        meal.addItem(<span class="keyword">new</span> Coke());</span><br><span class="line">        <span class="keyword">return</span> meal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Meal <span class="title">prepareNonVegMeal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Meal meal = <span class="keyword">new</span> Meal();</span><br><span class="line">        meal.addItem(<span class="keyword">new</span> ChickenBurger());</span><br><span class="line">        meal.addItem(<span class="keyword">new</span> Pepsi());</span><br><span class="line">        <span class="keyword">return</span> meal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="步骤7"><a href="#步骤7" class="headerlink" title="步骤7"></a>步骤7</h5><p>BuiderPatternDemo 使用 MealBuider 来演示建造者模式（Builder Pattern）。<br>BuilderPatternDemo.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuilderPatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      MealBuilder mealBuilder = <span class="keyword">new</span> MealBuilder();</span><br><span class="line"> </span><br><span class="line">      Meal vegMeal = mealBuilder.prepareVegMeal();</span><br><span class="line">      System.out.println(<span class="string">"Veg Meal"</span>);</span><br><span class="line">      vegMeal.showItems();</span><br><span class="line">      System.out.println(<span class="string">"Total Cost: "</span> +vegMeal.getCost());</span><br><span class="line"> </span><br><span class="line">      Meal nonVegMeal = mealBuilder.prepareNonVegMeal();</span><br><span class="line">      System.out.println(<span class="string">"\n\nNon-Veg Meal"</span>);</span><br><span class="line">      nonVegMeal.showItems();</span><br><span class="line">      System.out.println(<span class="string">"Total Cost: "</span> +nonVegMeal.getCost());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="步骤8"><a href="#步骤8" class="headerlink" title="步骤8"></a>步骤8</h5><p>执行输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Veg Meal</span><br><span class="line">Item : Veg Burger, Packing : Wrapper, Price : 25.0</span><br><span class="line">Item : Coke, Packing : Bottle, Price : 30.0</span><br><span class="line">Total Cost: 55.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Non-Veg Meal</span><br><span class="line">Item : Chicken Burger, Packing : Wrapper, Price : 50.5</span><br><span class="line">Item : Pepsi, Packing : Bottle, Price : 35.0</span><br><span class="line">Total Cost: 85.5</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。&lt;br&gt;一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式之单例模式</title>
    <link href="https://dongme.site/2018/10/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongme.site/2018/10/17/设计模式之单例模式/</id>
    <published>2018-10-16T17:02:49.000Z</published>
    <updated>2018-10-16T17:04:18.787Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。<br><a id="more"></a></p><p>注意：  </p><ol><li>单例类只能有一个实例。  </li><li>单例类必须自己创建自己的唯一实例。  </li><li>单例类必须给所有其他对象提供这一实例。  </li></ol><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><strong>意图：</strong> 保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br><strong>主要解决：</strong> 一个全局使用的类频繁地创建与销毁。<br><strong>何时使用：</strong> 当您想控制实例数目，节省系统资源的时候。<br><strong>如何解决：</strong> 判断系统是否已经有这个单例，如果有则返回，如果没有则创建。<br><strong>关键代码：</strong> 构造函数私有。<br><strong>优点：</strong> 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例。 2、避免对资源的多重占用（比如写文件操作）。<br><strong>缺点：</strong> 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。<br><strong>使用场景：</strong> 1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。<br><strong>注意事项：</strong> getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。  </p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>我们将创建一个 SingleObject 类。SingleObject 类有它的私有构造函数和本身的一个静态实例。<br>SingleObject 类提供了一个静态方法，供外界获取它的静态实例。SingletonPatternDemo，我们的演示类使用 SingleObject 类来获取 SingleObject 对象。  </p><p><img src="http://ombpxfki1.bkt.clouddn.com/singleton-1.png" alt="">  </p><h5 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h5><p>创建一个Singleton类。<br>SingleObject.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建SingleObject的一个对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleObject instance = <span class="keyword">new</span> SingleObject();</span><br><span class="line">    <span class="comment">//让构造函数为private，该类就不会被实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取唯一可用的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleObject <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h5><p>从singleton类获取唯一对象实例。<br>SingletonPatternDemo.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//不合法的构造函数</span></span><br><span class="line">        <span class="comment">//编译时错误：构造函数 SingleObject() 是不可见的</span></span><br><span class="line">        <span class="comment">//SingleObject object = new SingleObject();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取唯一可用的对象</span></span><br><span class="line">        SingleObject object = SingleObject.getInstance();</span><br><span class="line">        <span class="comment">//显示消息</span></span><br><span class="line">        object.showMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="步骤3"><a href="#步骤3" class="headerlink" title="步骤3"></a>步骤3</h5><p>执行输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Hello world</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">#### 单例模式的几种实现方式</span><br><span class="line"></span><br><span class="line">##### 1.懒汉式，线程不安全</span><br><span class="line"></span><br><span class="line">是否 Lazy 初始化：是  </span><br><span class="line">是否多线程安全：否  </span><br><span class="line">实现难度：易  </span><br><span class="line"></span><br><span class="line">**描述：** 这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。</span><br><span class="line">这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作  </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance;  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    public static Singleton getInstance() &#123;  </span><br><span class="line">    if (instance == null) &#123;  </span><br><span class="line">        instance = new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="2-懒汉式，线程安全"><a href="#2-懒汉式，线程安全" class="headerlink" title="2.懒汉式，线程安全"></a>2.懒汉式，线程安全</h5><p>是否 Lazy 初始化：是<br>是否多线程安全：是<br>实现难度：易  </p><p><strong>描述：</strong> 这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。<br><strong>优点：</strong> 第一次调用才初始化，避免内存浪费。<br><strong>缺点：</strong> 必须加锁 synchronized 才能保证单例，但加锁会影响效率。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-饿汉式"><a href="#3-饿汉式" class="headerlink" title="3.饿汉式"></a>3.饿汉式</h5><p>是否 Lazy 初始化：否<br>是否多线程安全：是<br>实现难度：易  </p><p><strong>描述：</strong> 这种方式比较常用，但容易产生垃圾对象。<br><strong>优点：</strong> 没有加锁，执行效率会提高。<br><strong>缺点：</strong> 类加载时就初始化，浪费内存。<br>它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-双重锁-双重校验锁（DCL，即double-checked-locking）"><a href="#4-双重锁-双重校验锁（DCL，即double-checked-locking）" class="headerlink" title="4.双重锁/双重校验锁（DCL，即double-checked locking）"></a>4.双重锁/双重校验锁（DCL，即double-checked locking）</h5><p>JDK 版本：JDK1.5 起<br>是否 Lazy 初始化：是<br>是否多线程安全：是<br>实现难度：较复杂  </p><p><strong>描述：</strong> 这种方式采用双锁机制，安全且在多线程情况下能保持高性能。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-登记式-静态内部类"><a href="#5-登记式-静态内部类" class="headerlink" title="5.登记式/静态内部类"></a>5.登记式/静态内部类</h5><p>是否 Lazy 初始化：是<br>是否多线程安全：是<br>实现难度：一般  </p><p><strong>描述：</strong> 这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。<br>这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">##### 6.枚举</span><br><span class="line"></span><br><span class="line">JDK 版本：JDK1.5 起  </span><br><span class="line">是否 Lazy 初始化：否  </span><br><span class="line">是否多线程安全：是  </span><br><span class="line">实现难度：易  </span><br><span class="line"></span><br><span class="line">**描述：** 这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。  </span><br><span class="line">这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 <span class="keyword">enum</span> 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。</span><br><span class="line">不能通过 reflection attack 来调用私有构造方法。  </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>建议：</strong> 一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。  </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。&lt;br&gt;这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式之抽象工厂模式</title>
    <link href="https://dongme.site/2018/10/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongme.site/2018/10/17/设计模式之抽象工厂模式/</id>
    <published>2018-10-16T17:00:25.000Z</published>
    <updated>2018-10-16T17:01:51.014Z</updated>
    
    <content type="html"><![CDATA[<p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。<br><a id="more"></a></p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><strong>意图：</strong> 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br><strong>主要解决：</strong> 主要解决接口选择的问题。<br><strong>何时使用：</strong> 系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。<br><strong>如何解决：</strong> 在一个产品族里，定义多个产品。<br><strong>关键代码：</strong> 在一个工厂里聚合多个同类产品。<br><strong>应用实例：</strong> 工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OO 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一工厂具体产品），裤子（某一工厂另一具体产品）。<br><strong>优点：</strong> 当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。<br><strong>缺点：</strong> 产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。<br><strong>使用场景：</strong> 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。<br><strong>注意事项：</strong> 产品族难扩展，产品等级易扩展。  </p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>我们将创建 Shape 和 Color 接口和实现这些接口的实体类。下一步是创建抽象工厂类 AbstractFactory。接着定义工厂类 ShapeFactory 和 ColorFactory，这两个工厂类都是扩展了 AbstractFactory。然后创建一个工厂创造器/生成器类 FactoryProducer。<br>AbstractFactoryPatternDemo，我们的演示类使用 FactoryProducer 来获取 AbstractFactory 对象。它将向 AbstractFactory 传递形状信息 Shape（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。同时它还向 AbstractFactory 传递颜色信息 Color（RED / GREEN / BLUE），以便获取它所需对象的类型。  </p><p><img src="http://ombpxfki1.bkt.clouddn.com/abstract-factory-1.png" alt="">  </p><h5 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h5><p>为形状创建一个接口。<br>Shape.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h5><p>创建实现形状接口的实体类。<br>Rectangle.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Inside Rectangle::draw() method."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Square.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Inside Square::draw() method."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Circle.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Inside Circle::draw() method."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="步骤3"><a href="#步骤3" class="headerlink" title="步骤3"></a>步骤3</h5><p>为颜色创建一个接口。<br>Color.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="步骤4"><a href="#步骤4" class="headerlink" title="步骤4"></a>步骤4</h5><p>创建实现颜色接口的类。<br>Red.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Red</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Inside Red::fill() method."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Green.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Green</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Inside Green::fill() method."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Blue.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blue</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Inside Blue::fill() method."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="步骤5"><a href="#步骤5" class="headerlink" title="步骤5"></a>步骤5</h5><p>为Shape和Color创建抽象类获取工厂。<br>AbstractFactory.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Color <span class="title">getColor</span><span class="params">(String color)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="步骤6"><a href="#步骤6" class="headerlink" title="步骤6"></a>步骤6</h5><p>创建扩展了AbstractFactory的工厂类，基于给定的信息生成实体类的对象。<br>ShapeFactory.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (shapeType == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (shapeType.equalsIgnoreCase(<span class="string">"CIRCLE"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeType.equalsIgnoreCase(<span class="string">"RECTANGLE"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeType.equalsIgnoreCase(<span class="string">"SQUARE"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ColorFactory.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (color == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (color.equalsIgnoreCase(<span class="string">"RED"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Red();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (color.equalsIgnoreCase(<span class="string">"GREEN"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Green();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (color.equalsIgnoreCase(<span class="string">"BLUE"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Blue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="步骤7"><a href="#步骤7" class="headerlink" title="步骤7"></a>步骤7</h5><p>创建一个工厂创造器/生成器类，通过传递形状或颜色来获取工厂。<br>FactoryProducer.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractFactory <span class="title">getFactory</span><span class="params">(String choice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(choice.equalsIgnoreCase(<span class="string">"SHAPE"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ShapeFactory();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(choice.equalsIgnoreCase(<span class="string">"COLOR"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ColorFactory();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">##### 步骤8</span><br><span class="line"></span><br><span class="line">使用FactoryProducer来获取AbstractFactory，通过传递类型信息来获取实体类的对象。  </span><br><span class="line">AbstractFactoryPatternDemo.java  </span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取形状工厂</span></span><br><span class="line">        AbstractFactory shapeFactory = FactoryProducer.getFactory(<span class="string">"SHAPE"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取形状为 Circle 的对象</span></span><br><span class="line">        Shape shape1 = shapeFactory.getShape(<span class="string">"CIRCLE"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用 Circle 的 draw 方法</span></span><br><span class="line">        shape1.draw();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取形状为 Rectangle 的对象</span></span><br><span class="line">        Shape shape2 = shapeFactory.getShape(<span class="string">"RECTANGLE"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用 Rectangle 的 draw 方法</span></span><br><span class="line">        shape2.draw();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取形状为 Square 的对象</span></span><br><span class="line">        Shape shape3 = shapeFactory.getShape(<span class="string">"SQUARE"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用 Square 的 draw 方法</span></span><br><span class="line">        shape3.draw();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取颜色工厂</span></span><br><span class="line">        AbstractFactory colorFactory = FactoryProducer.getFactory(<span class="string">"COLOR"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取颜色为 Red 的对象</span></span><br><span class="line">        Color color1 = colorFactory.getColor(<span class="string">"RED"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用 Red 的 fill 方法</span></span><br><span class="line">        color1.fill();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取颜色为 Green 的对象</span></span><br><span class="line">        Color color2 = colorFactory.getColor(<span class="string">"Green"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用 Green 的 fill 方法</span></span><br><span class="line">        color2.fill();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取颜色为 Blue 的对象</span></span><br><span class="line">        Color color3 = colorFactory.getColor(<span class="string">"BLUE"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用 Blue 的 fill 方法</span></span><br><span class="line">        color3.fill();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="步骤9"><a href="#步骤9" class="headerlink" title="步骤9"></a>步骤9</h5><p>执行，输出结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Inside Circle::draw() method.</span><br><span class="line">Inside Rectangle::draw() method.</span><br><span class="line">Inside Square::draw() method.</span><br><span class="line">Inside Red::fill() method.</span><br><span class="line">Inside Green::fill() method.</span><br><span class="line">Inside Blue::fill() method.</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。&lt;br&gt;在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式之工厂模式</title>
    <link href="https://dongme.site/2018/10/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongme.site/2018/10/17/设计模式之工厂模式/</id>
    <published>2018-10-16T16:57:18.000Z</published>
    <updated>2018-10-16T16:59:49.246Z</updated>
    
    <content type="html"><![CDATA[<p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。  </p><p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。<br><a id="more"></a> </p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><strong>意图：</strong> 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。<br><strong>主要解决：</strong> 主要解决接口选择的问题。<br><strong>何时使用：</strong> 我们明确地计划不同条件下创建不同实例时。<br><strong>如何解决：</strong> 让其子类实现工厂接口，返回的也是一个抽象的产品。<br><strong>关键代码：</strong> 创建过程在其子类进行。<br><strong>应用实例：</strong> 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。<br><strong>优点：</strong> 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。<br><strong>缺点：</strong> 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事<br><strong>使用场景：</strong> 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。<br><strong>注意事项：</strong> 作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。  </p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>我们将创建一个 Shape 接口和实现 Shape 接口的实体类。下一步是定义工厂类 ShapeFactory。<br>FactoryPatternDemo，我们的演示类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。<br><img src="http://ombpxfki1.bkt.clouddn.com/factorypattern-1.png" alt="">  </p><h5 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h5><p>创建一个接口 Shape.java：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h5><p>创建实现接口的实现类。  </p><p>Rectangle.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Inside Rectangle::draw() method."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Square.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Inside Square::draw() method."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Circle.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Inside Circle::draw() method."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="步骤3"><a href="#步骤3" class="headerlink" title="步骤3"></a>步骤3</h5><p>创建一个工厂，生成基于给定信息的实体类的对象。  </p><p>ShapeFactory.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用 getShape 方法获取形状类型的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (shapeType == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (shapeType.equalsIgnoreCase(<span class="string">"CIRCLE"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeType.equalsIgnoreCase(<span class="string">"RECTANGLE"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeType.equalsIgnoreCase(<span class="string">"SQUARE"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="步骤4"><a href="#步骤4" class="headerlink" title="步骤4"></a>步骤4</h5><p>使用该工厂，通过传递类型信息来获取实体类的对象。  </p><p>FactoryPatternDemo.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShapeFactory shapeFactory = <span class="keyword">new</span> ShapeFactory();</span><br><span class="line">        <span class="comment">//获取 Circle 的对象，并调用它的 draw 方法</span></span><br><span class="line">        Shape shape1 = shapeFactory.getShape(<span class="string">"CIRCLE"</span>);</span><br><span class="line">        <span class="comment">//调用 Circle 的 draw 方法</span></span><br><span class="line">        shape1.draw();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取 Rectangle 的对象，并调用它的 draw 方法</span></span><br><span class="line">        Shape shape2 = shapeFactory.getShape(<span class="string">"RECTANGLE"</span>);</span><br><span class="line">        <span class="comment">//调用 Rectangle 的 draw 方法</span></span><br><span class="line">        shape2.draw();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取 Square 的对象，并调用它的 draw 方法</span></span><br><span class="line">        Shape shape3 = shapeFactory.getShape(<span class="string">"SQUARE"</span>);</span><br><span class="line">        <span class="comment">//调用 Square 的 draw 方法</span></span><br><span class="line">        shape3.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。  &lt;/p&gt;
&lt;p&gt;在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>jdk新特性之jdk10</title>
    <link href="https://dongme.site/2018/10/16/jdk%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8Bjdk10/"/>
    <id>https://dongme.site/2018/10/16/jdk新特性之jdk10/</id>
    <published>2018-10-15T16:40:00.000Z</published>
    <updated>2018-10-16T16:16:10.144Z</updated>
    
    <content type="html"><![CDATA[<p>jdk10新特性。<br><a id="more"></a></p><h3 id="jdk10新特性"><a href="#jdk10新特性" class="headerlink" title="jdk10新特性"></a>jdk10新特性</h3><p>Java 在 2018 年 3 月 21 日发布了第十个大版本。为了更快地迭代、更好地跟进社区反馈，Java 语言版本发布周期调整为每隔 6 个月发布一次。<br>Java 10 是这一新规则之后，采用新发布周期的第一个大版本。Java 10 版本带来了很多新特性，其中最备受广大开发者关注的莫过于局部变量类型推断。<br>除此之外，还有其他包括垃圾收集器改善、GC 改进、性能提升、线程管控等一批新特性。  </p><h4 id="局部变量类型推断"><a href="#局部变量类型推断" class="headerlink" title="局部变量类型推断"></a>局部变量类型推断</h4><p>部变量类型推断是 Java 10 中最值得开发人员注意的新特性，允许开发人员省略通常不必要的局部变量类型初始化声明。<br>新的语法将减少 Java 代码的冗长度，同时保持对静态类型安全性的承诺。局部变量类型推断主要是向 Java 语法中引入<br>在其他语言（比如 C#、JavaScript）中很常见的保留类型名称 var。但需要特别注意的是：var 不是一个关键字，而是一个保留字。<br>只要编译器可以推断此种类型，开发人员不再需要专门声明一个局部变量的类型，也就是可以随意定义变量而不必指定变量的类型。<br>这种改进对于链式表达式来说，也会很方便。以下是一个简单的例子：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var list = new ArrayList&lt;String&gt;(); // ArrayList&lt;String&gt;</span><br><span class="line"></span><br><span class="line">var stream = list.stream(); //Stream&lt;String&gt;</span><br></pre></td></tr></table></figure><p>但这种 var 变量类型推断的使用也有局限性，仅局限于具有初始化器的局部变量、增强型 for 循环中的索引变量以及在传统 for 循环中声明的局部变量，<br>而不能用于推断方法的参数类型，不能用于构造函数参数类型推断，不能用于推断方法返回类型，也不能用于字段类型推断，同时还不能用于捕获表达式（或任何其他类型的变量声明）。  </p><h4 id="整合-JDK-代码仓库"><a href="#整合-JDK-代码仓库" class="headerlink" title="整合 JDK 代码仓库"></a>整合 JDK 代码仓库</h4><p>在已发布的 Java 版本中，JDK 的整套代码根据不同功能已被分别存储在多个 Mercurial 存储库，这八个 Mercurial 存储库分别是：root、corba、hotspot、jaxp、jaxws、jdk、langtools、nashorn。<br>虽然以上八个存储库之间相互独立以保持各组件代码清晰分离，但同时管理这些存储库存在许多缺点，并且无法进行相关联源代码的管理操作。其中最重要的一点是，涉及多个存储库的变更集无法进行原子提交 （atomic commit）。<br>例如，如果一个 bug 修复时需要对独立存储两个不同代码库的代码进行更改，那么必须创建两个提交：每个存储库中各一个。<br>这种不连续性很容易降低项目和源代码管理工具的可跟踪性和加大复杂性。特别是，不可能跨越相互依赖的变更集的存储库执行原子提交这种多次跨仓库的变化是常见现象。   </p><p>为了解决这个问题，JDK 10 中将所有现有存储库合并到一个 Mercurial 存储库中。这种合并的一个次生效应是，单一的 Mercurial 存储库比现有的八个存储库要更容易地被镜像(作为一个 Git 存储库)，<br>并且使得跨越相互依赖的变更集的存储库运行原子提交成为可能，从而简化开发和管理过程。虽然在整合过程中，外部开发人员有一些阻力，但是 JDK 开发团队已经使这一更改成为 JDK 10 的一部分。   </p><h4 id="统一的垃圾回收接口"><a href="#统一的垃圾回收接口" class="headerlink" title="统一的垃圾回收接口"></a>统一的垃圾回收接口</h4><p>在当前的 Java 结构中，组成垃圾回收器（GC）实现的组件分散在代码库的各个部分。尽管这些惯例对于使用 GC 计划的 JDK 开发者来说比较熟悉，但对新的开发人员来说，对于在哪里查找特定 GC 的源代码，或者实现一个新的垃圾收集器常常会感到困惑。更重要的是，随着 Java modules 的出现，我们希望在构建过程中排除不需要的 GC，但是当前 GC 接口的横向结构会给排除、定位问题带来困难。<br>为解决此问题，需要整合并清理 GC 接口，以便更容易地实现新的 GC，并更好地维护现有的 GC。Java 10 中，hotspot/gc 代码实现方面，引入一个干净的 GC 接口，改进不同 GC 源代码的隔离性，多个 GC 之间共享的实现细节代码应该存在于辅助类中。这种方式提供了足够的灵活性来实现全新 GC 接口，同时允许以混合搭配方式重复使用现有代码，并且能够保持代码更加干净、整洁，便于排查收集器问题。  </p><h4 id="并行全垃圾回收器-G1"><a href="#并行全垃圾回收器-G1" class="headerlink" title="并行全垃圾回收器 G1"></a>并行全垃圾回收器 G1</h4><p>大家如果接触过 Java 性能调优工作，应该会知道，调优的最终目标是通过参数设置来达到快速、低延时的内存垃圾回收以提高应用吞吐量，尽可能的避免因内存回收不及时而触发的完整 GC（Full GC 会带来应用出现卡顿）。<br>G1 垃圾回收器是 Java 9 中 Hotspot 的默认垃圾回收器，是以一种低延时的垃圾回收器来设计的，旨在避免进行 Full GC，但是当并发收集无法快速回收内存时，会触发垃圾回收器回退进行 Full GC。之前 Java 版本中的 G1 垃圾回收器执行 GC 时采用的是基于单线程标记扫描压缩算法（mark-sweep-compact）。为了最大限度地减少 Full GC 造成的应用停顿的影响，Java 10 中将为 G1 引入多线程并行 GC，同时会使用与年轻代回收和混合回收相同的并行工作线程数量，从而减少了 Full GC 的发生，以带来更好的性能提升、更大的吞吐量。<br>Java 10 中将采用并行化 mark-sweep-compact 算法，并使用与年轻代回收和混合回收相同数量的线程。具体并行 GC 线程数量可以通过：-XX：ParallelGCThreads 参数来调节，但这也会影响用于年轻代和混合收集的工作线程数。  </p><h4 id="应用程序类数据共享"><a href="#应用程序类数据共享" class="headerlink" title="应用程序类数据共享"></a>应用程序类数据共享</h4><p>在 Java 5 中就已经引入了类数据共享机制 (Class Data Sharing，简称 CDS)，允许将一组类预处理为共享归档文件，以便在运行时能够进行内存映射以减少 Java 程序的启动时间，当多个 Java 虚拟机（JVM）共享相同的归档文件时，还可以减少动态内存的占用量，同时减少多个虚拟机在同一个物理或虚拟的机器上运行时的资源占用。简单来说，Java 安装程序会把 rt.jar 中的核心类提前转化成内部表示，转储到一个共享存档（shared archive）中。多个 Java 进程（或者说 JVM 实例）可以共享这部分数据。为改善启动和占用空间，Java 10 在现有的 CDS 功能基础上再次拓展，以允许应用类放置在共享存档中。<br>CDS 特性在原来的 bootstrap 类基础之上，扩展加入了应用类的 CDS (Application Class-Data Sharing) 支持。<br>其原理为：在启动时记录加载类的过程，写入到文本文件中，再次启动时直接读取此启动文本并加载。设想如果应用环境没有大的变化，启动速度就会得到提升。<br>可以想像为类似于操作系统的休眠过程，合上电脑时把当前应用环境写入磁盘，再次使用时就可以快速恢复环境。<br>对大型企业应用程序的内存使用情况的分析表明，此类应用程序通常会将数以万计的类加载到应用程序类加载器中，如果能够将 AppCDS 应用于这些应用，将为每个 JVM 进程节省数十乃至数百兆字节的内存。另外对于云平台上的微服务分析表明，许多服务器在启动时会加载数千个应用程序类，AppCDS 可以让这些服务快速启动并改善整个系统响应时间。  </p><h4 id="线程-局部管控"><a href="#线程-局部管控" class="headerlink" title="线程-局部管控"></a>线程-局部管控</h4><p>在已有的 Java 版本中，JVM 线程只能全部启用或者停止，没法做到对单独某个线程的操作。为了能够对单独的某个线程进行操作，Java 10 中线程管控引入 JVM 安全点的概念，将允许在不运行全局 JVM 安全点的情况下实现线程回调，由线程本身或者 JVM 线程来执行，同时保持线程处于阻塞状态，这种方式使得停止单个线程变成可能，而不是只能启用或停止所有线程。通过这种方式显著地提高了现有 JVM 功能的性能开销，并且改变了到达 JVM 全局安全点的现有时间语义。<br>增加的参数为：-XX:ThreadLocalHandshakes (默认为开启)，将允许用户在支持的平台上选择安全点  </p><h4 id="移除-Native-Header-自动生成工具"><a href="#移除-Native-Header-自动生成工具" class="headerlink" title="移除 Native-Header 自动生成工具"></a>移除 Native-Header 自动生成工具</h4><p>自 Java 9 以来便开始了一些对 JDK 的调整，用户每次调用 javah 工具时会被警告该工具在未来的版本中将会执行的删除操作。当编译 JNI 代码时，已不再需要单独的 Native-Header 工具来生成头文件，因为这可以通过 Java 8（JDK-7150368）中添加的 javac 来完成。在未来的某一时刻，JNI 将会被 Panama 项目的结果取代，但是何时发生还没有具体时间表。  </p><h4 id="额外的-Unicode-语言标签扩展"><a href="#额外的-Unicode-语言标签扩展" class="headerlink" title="额外的 Unicode 语言标签扩展"></a>额外的 Unicode 语言标签扩展</h4><p>自 Java 7 开始支持 BCP 47 语言标记以来， JDK 中便增加了与日历和数字相关的 Unicode 区域设置扩展，在 Java 9 中，新增支持 ca 和 nu 两种语言标签扩展。而在 Java 10 中将继续增加 Unicode 语言标签扩展，具体为：增强 java.util.Locale 类及其相关的 API，以更方便的获得所需要的语言地域环境信息。同时在这次升级中还带来了如下扩展支持：  </p><p>表 1.Unicode 扩展表  </p><table><thead><tr><th style="text-align:left">编码</th><th style="text-align:left">注释</th></tr></thead><tbody><tr><td style="text-align:left">cu</td><td style="text-align:left">货币类型</td></tr><tr><td style="text-align:left">fw</td><td style="text-align:left">一周的第一天</td></tr><tr><td style="text-align:left">rg</td><td style="text-align:left">区域覆盖</td></tr><tr><td style="text-align:left">tz</td><td style="text-align:left">时区</td></tr></tbody></table><h4 id="备用存储装置上的堆分配"><a href="#备用存储装置上的堆分配" class="headerlink" title="备用存储装置上的堆分配"></a>备用存储装置上的堆分配</h4><p>硬件技术在持续进化，现在可以使用与传统 DRAM 具有相同接口和类似性能特点的非易失性 RAM。Java 10 中将使得 JVM 能够使用适用于不同类型的存储机制的堆，在可选内存设备上进行堆内存分配。<br>一些操作系统中已经通过文件系统提供了使用非 DRAM 内存的方法。例如：NTFS DAX 模式和 ext4 DAX。这些文件系统中的内存映射文件可绕过页面缓存并提供虚拟内存与设备物理内存的相互映射。与 DRAM 相比，NV-DIMM 可能具有更高的访问延迟，低优先级进程可以为堆使用 NV-DIMM 内存，允许高优先级进程使用更多 DRAM。<br>要在这样的备用设备上进行堆分配，可以使用堆分配参数 -XX：AllocateHeapAt = <path></path>，这个参数将指向文件系统的文件并使用内存映射来达到在备用存储设备上进行堆分配的预期结果。  </p><h4 id="基于-Java-的-实验性-JIT-编译器"><a href="#基于-Java-的-实验性-JIT-编译器" class="headerlink" title="基于 Java 的 实验性 JIT 编译器"></a>基于 Java 的 实验性 JIT 编译器</h4><p>Java 10 中开启了基于 Java 的 JIT 编译器 Graal，并将其用作 Linux/x64 平台上的实验性 JIT 编译器开始进行测试和调试工作，另外 Graal 将使用 Java 9 中引入的 JVM 编译器接口（JVMCI）。<br>Graal 是一个以 Java 为主要编程语言、面向 Java bytecode 的编译器。与用 C++实现的 C1 及 C2 相比，它的模块化更加明显，也更加容易维护。Graal 既可以作为动态编译器，在运行时编译热点方法；亦可以作为静态编译器，实现 AOT 编译。在 Java 10 中，Graal 作为试验性 JIT 编译器一同发布（JEP 317）。将 Graal 编译器研究项目引入到 Java 中，或许能够为 JVM 性能与当前 C++ 所写版本匹敌（或有幸超越）提供基础。<br>Java 10 中默认情况下 HotSpot 仍使用的是 C2 编译器，要启用 Graal 作为 JIT 编译器，请在 Java 命令行上使用以下参数：<br>启用 Graal 为 JIT 编译器示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX：+ UnlockExperimentalVMOptions -XX：+ UseJVMCICompiler</span><br></pre></td></tr></table></figure></p><h4 id="根证书认证"><a href="#根证书认证" class="headerlink" title="根证书认证"></a>根证书认证</h4><p>自 Java 9 起在 keytool 中加入参数 -cacerts，可以查看当前 JDK 管理的根证书。而 Java 9 中 cacerts 目录为空，这样就会给开发者带来很多不便。从 Java 10 开始，将会在 JDK 中提供一套默认的 CA 根证书。<br>作为 JDK 一部分的 cacerts 密钥库旨在包含一组能够用于在各种安全协议的证书链中建立信任的根证书。但是，JDK 源代码中的 cacerts 密钥库至目前为止一直是空的。因此，在 JDK 构建中，默认情况下，关键安全组件（如 TLS）是不起作用的。要解决此问题，用户必须使用一组根证书配置和 cacerts 密钥库下的 CA 根证书。  </p><h4 id="基于时间的版本发布模式"><a href="#基于时间的版本发布模式" class="headerlink" title="基于时间的版本发布模式"></a>基于时间的版本发布模式</h4><p>虽然 JEP 223中引入的版本字符串方案较以往有了显著的改进。但是，该方案并不适合以后严格按照六个月的节奏来发布 Java 新版本的这种情况。<br>按照 JEP 223 的语义中，每个基于 JDK 构建或使用组件的开发者（包括 JDK 的发布者）都必须提前敲定版本号，然后切换过去。开发人员则必须在代码中修改检查版本号的相关代码，这对所有参与者来说都很尴尬和混乱。<br>Java 10 中将重新编写之前 JDK 版本中引入的版本号方案，将使用基于时间模型定义的版本号格式来定义新版本。保留与 JEP 223 版本字符串方案的兼容性，同时也允许除当前模型以外的基于时间的发布模型。使开发人员或终端用户能够轻松找出版本的发布时间，以便开发人员能够判断是否将其升级到具有最新安全修补程序或可能的附加功能的新版本。<br>Oracle Java 平台组的首席架构师 Mark Reinhold 在博客上介绍了有关 Java 未来版本的一些想法（你能接受 Java 9 的下一个版本是 Java 18.3 吗？）。他提到，Java 计划按照时间来发布，每半年一个版本，而不是像之前那样按照重要特性来确定大版本，如果某个大的特性因故延期，这个版本可能一拖再拖。<br>当时，Mark 也提出来一种基于时间命名版本号的机制，比如下一个将于 2018 年 3 月发布的版本，就是 18.3，再下一个版本是 18.9，以后版本依此类推。<br>不过经过讨论，考虑和之前版本号的兼容等问题，最终选择的命名机制是：<br>$FEATURE.$INTERIM.$UPDATE.$PATCH<br>$FEATURE，每次版本发布加 1，不考虑具体的版本内容。2018 年 3 月的版本是 JDK 10，9 月的版本是 JDK 11，依此类推。<br>$INTERIM，中间版本号，在大版本中间发布的，包含问题修复和增强的版本，不会引入非兼容性修改。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jdk10新特性。&lt;br&gt;
    
    </summary>
    
    
      <category term="jdk" scheme="https://dongme.site/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>jdk新特性之jdk9</title>
    <link href="https://dongme.site/2018/10/16/jdk%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8Bjdk9/"/>
    <id>https://dongme.site/2018/10/16/jdk新特性之jdk9/</id>
    <published>2018-10-15T16:38:00.000Z</published>
    <updated>2018-10-16T16:40:02.565Z</updated>
    
    <content type="html"><![CDATA[<p>jdk9新特性。<br><a id="more"></a></p><h3 id="jdk9新特性"><a href="#jdk9新特性" class="headerlink" title="jdk9新特性"></a>jdk9新特性</h3><p>Java 9 发布于 2017 年 9 月 22 日，带来了很多新特性，其中最主要的变化是已经实现的模块化系统。接下来我们会详细介绍 Java 9 的新特性。  </p><ul><li><strong>模块系统：</strong> 模块是一个包的容器，Java 9 最大的变化之一是引入了模块系统（Jigsaw 项目）。  </li><li><strong>HTTP 2 客户端：</strong> HTTP/2标准是HTTP协议的最新版本，新的 HTTPClient API 支持 WebSocket 和 HTTP2 流以及服务器推送特性。  </li><li><strong>改进的 Javadoc：</strong> Javadoc 现在支持在 API 文档中的进行搜索。另外，Javadoc 的输出现在符合兼容 HTML5 标准。  </li><li><strong>多版本兼容 JAR 包：</strong> 多版本兼容 JAR 功能能让你创建仅在特定版本的 Java 环境中运行库程序时选择使用的 class 版本。  </li><li><strong>集合工厂方法：</strong> List，Set 和 Map 接口中，新的静态工厂方法可以创建这些集合的不可变实例。   </li><li><strong>私有接口方法：</strong> 在接口中使用private私有方法。我们可以使用 private 访问修饰符在接口中编写私有方法。  </li><li><strong>进程 API：</strong> 改进的 API 来控制和管理操作系统进程。引进 java.lang.ProcessHandle 及其嵌套接口 Info 来让开发者逃离时常因为要获取一个本地进程的 PID 而不得不使用本地代码的窘境。  </li><li><strong>改进的 Stream API：</strong> 改进的 Stream API 添加了一些便利的方法，使流处理更容易，并使用收集器编写复杂的查询。  </li><li><strong>改进 try-with-resources：</strong> 如果你已经有一个资源是 final 或等效于 final 变量,您可以在 try-with-resources 语句中使用该变量，而无需在 try-with-resources 语句中声明一个新变量。  </li><li><strong>改进的弃用注解 @Deprecated：</strong>  @Deprecated 可以标记 Java API 状态，可以表示被标记的 API 将会被移除，或者已经破坏。  </li><li><strong>改进钻石操作符(Diamond Operator) ：</strong> 匿名类可以使用钻石操作符(Diamond Operator)。  </li><li><strong>改进 Optional 类：</strong> java.util.Optional 添加了很多新的有用方法，Optional 可以直接转为 stream。    </li><li><strong>多分辨率图像 API：</strong> 定义多分辨率图像API，开发者可以很容易的操作和展示不同分辨率的图像了。   </li><li><strong>改进的 CompletableFuture API ：</strong> CompletableFuture 类的异步机制可以在 ProcessHandle.onExit 方法退出时执行操作。   </li><li><strong>轻量级的 JSON API：</strong> 内置了一个轻量级的JSON API  </li><li><strong>响应式流（Reactive Streams) API：</strong> Java 9中引入了新的响应式流 API 来支持 Java 9 中的响应式编程。  </li></ul><h4 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h4><p>Java 9 最大的变化之一是引入了模块系统（Jigsaw 项目）。<br>模块就是代码和数据的封装体。模块的代码被组织成多个包，每个包中包含Java类和接口；模块的数据则包括资源文件和其他静态信息。<br>Java 9 模块的重要特征是在其工件（artifact）的根目录中包含了一个描述模块的 module-info.class 文 件。 工件的格式可以是传统的 JAR 文件或是 Java 9 新增的 JMOD 文件。这个文件由根目录中的源代码文件 module-info.java 编译而来。该模块声明文件可以描述模块的不同特征。<br>在 module-info.java 文件中，我们可以用新的关键词module来声明一个模块，如下所示。下面给出了一个模块com.mycompany.mymodule的最基本的模块声明。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module com.alvin.mymodule &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h5><p>接下来我们创建一个com.alvin.greetings的模块。<br><strong>第一步</strong><br>创建文件夹 alvin/src，然后在src目录下创建与模块名相同的文件夹 com.alvin.greetings。  </p><p><strong>第二步</strong><br>在com.alvin.greetings文件夹下创建module-info.java文件，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module com.alvin.greetings &#123;&#125;</span><br></pre></td></tr></table></figure></p><p><strong>第三步</strong><br>在模块中添加源代码文件，在目录 alvin/src/com/alvin/greetings中创建文件Java9Demo.java，代码如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.alvin.greetings;</span><br><span class="line"></span><br><span class="line">public class Java9Demo &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第四步</strong><br>创建文件夹java/mods，然后在该目录下创建com.alvin.greetings文件夹，编译模块到这个目录下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javac -d mods/com.alvin.greetings </span><br><span class="line">  src/com.alvin.greetings/module-info.java </span><br><span class="line">  src/com.alvin.greetings/com/alvin/greetings/Java9Demo.java</span><br></pre></td></tr></table></figure><p><strong>第五步</strong><br>执行模块，查看输出结果：    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java --module-path mods -m com.alvin.greetings/com.alvin.greetings.Java9Demo</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><p><em>module-path</em> 指定了模块所在的路径。<br><em>-m</em> 指定主要模块。  </p><h4 id="Java-9-REPL-JShell"><a href="#Java-9-REPL-JShell" class="headerlink" title="Java 9 REPL (JShell)"></a>Java 9 REPL (JShell)</h4><p>REPL(Read Eval Print Loop)意为交互式的编程环境。<br>JShell 是 Java 9 新增的一个交互式的编程环境工具。它允许你无需使用类或者方法包装来执行 Java 语句。它与 Python 的解释器类似，可以直接 输入表达式并查看其执行结果。  </p><h5 id="执行-JSHELL"><a href="#执行-JSHELL" class="headerlink" title="执行 JSHELL"></a>执行 JSHELL</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ jshell</span><br><span class="line">|  Welcome to JShell -- Version 9-ea</span><br><span class="line">|  For an introduction type: /help intro</span><br><span class="line">jshell&gt;</span><br></pre></td></tr></table></figure><h5 id="查看-JShell-命令"><a href="#查看-JShell-命令" class="headerlink" title="查看 JShell 命令"></a>查看 JShell 命令</h5><p>输入 /help 可以查看 JShell相关的命令：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; /help</span><br><span class="line">|  Type a Java language expression, statement, or declaration.</span><br><span class="line">|  Or type one of the following commands:</span><br><span class="line">|  /list [&lt;name or id&gt;|-all|-start]</span><br><span class="line">|  list the source you have typed</span><br><span class="line">|  /edit &lt;name or id&gt;</span><br><span class="line">|  edit a source entry referenced by name or id</span><br><span class="line">|  /drop &lt;name or id&gt;</span><br><span class="line">|  delete a source entry referenced by name or id</span><br><span class="line">|  /save [-all|-history|-start] &lt;file&gt;</span><br><span class="line">|  Save snippet source to a file.</span><br><span class="line">|  /open &lt;file&gt;</span><br><span class="line">|  open a file as source input</span><br><span class="line">|  /vars [&lt;name or id&gt;|-all|-start]</span><br><span class="line">|  list the declared variables and their values</span><br><span class="line">|  /methods [&lt;name or id&gt;|-all|-start]</span><br><span class="line">|  list the declared methods and their signatures</span><br><span class="line">|  /types [&lt;name or id&gt;|-all|-start]</span><br><span class="line">|  list the declared types</span><br><span class="line">|  /imports </span><br><span class="line">|  list the imported items</span><br></pre></td></tr></table></figure><h5 id="执行-JShell-命令"><a href="#执行-JShell-命令" class="headerlink" title="执行 JShell 命令"></a>执行 JShell 命令</h5><p>/imports 命令用于查看已导入的包：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; /imports</span><br><span class="line">|    import java.io.*</span><br><span class="line">|    import java.math.*</span><br><span class="line">|    import java.net.*</span><br><span class="line">|    import java.nio.file.*</span><br><span class="line">|    import java.util.*</span><br><span class="line">|    import java.util.concurrent.*</span><br><span class="line">|    import java.util.function.*</span><br><span class="line">|    import java.util.prefs.*</span><br><span class="line">|    import java.util.regex.*</span><br><span class="line">|    import java.util.stream.*</span><br><span class="line">jshell&gt;</span><br></pre></td></tr></table></figure><h5 id="JShell-执行计算"><a href="#JShell-执行计算" class="headerlink" title="JShell 执行计算"></a>JShell 执行计算</h5><p>以下实例执行 JShell 简单计算：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; 3+1</span><br><span class="line">$1 ==&gt; 4</span><br><span class="line">jshell&gt; 13%7</span><br><span class="line">$2 ==&gt; 6</span><br><span class="line">jshell&gt; $2</span><br><span class="line">$2 ==&gt; 6</span><br><span class="line">jshell&gt;</span><br></pre></td></tr></table></figure><h5 id="JShell-创建与使用函数"><a href="#JShell-创建与使用函数" class="headerlink" title="JShell 创建与使用函数"></a>JShell 创建与使用函数</h5><p>创建一个函数 doubled() ，将传入的整型参数乘于 2 后返回：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; int doubled(int i)&#123; return i*2;&#125;</span><br><span class="line">|  created method doubled(int)</span><br><span class="line">jshell&gt; doubled(6)</span><br><span class="line">$3 ==&gt; 12</span><br><span class="line">jshell&gt;</span><br></pre></td></tr></table></figure><h5 id="退出-JShell"><a href="#退出-JShell" class="headerlink" title="退出 JShell"></a>退出 JShell</h5><p>输入 /exit 命令退出 jshell：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; /exit</span><br><span class="line">| Goodbye</span><br></pre></td></tr></table></figure><h5 id="多版本兼容-jar-包"><a href="#多版本兼容-jar-包" class="headerlink" title="多版本兼容 jar 包"></a>多版本兼容 jar 包</h5><p>多版本兼容 JAR 功能能让你创建仅在特定版本的 Java 环境中运行库程序时选择使用的 class 版本。<br>通过 <code>--release</code> 参数指定编译版本。<br>具体的变化就是 META-INF 目录下 MANIFEST.MF 文件新增了一个属性：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Multi-Release: true</span><br></pre></td></tr></table></figure><p>然后 META-INF 目录下还新增了一个 versions 目录，如果是要支持 java9，则在 versions 目录下有 9 的目录。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">multirelease.jar</span><br><span class="line">├── META-INF</span><br><span class="line">│   └── versions</span><br><span class="line">│       └── 9</span><br><span class="line">│           └── multirelease</span><br><span class="line">│               └── Helper.class</span><br><span class="line">├── multirelease</span><br><span class="line">    ├── Helper.class</span><br><span class="line">    └── Main.class</span><br></pre></td></tr></table></figure><p>在以下实例中，我们使用多版本兼容 JAR 功能将 Tester.java 文件生成了两个版本的 jar 包, 一个是 jdk 7，另一个是 jdk 9，然后我们再不同环境下执行。  </p><p><strong>第一步</strong>   </p><p>创建文件夹 c:/test/java7/com/alvin，并在该文件夹下创建 Test.java 文件，代码如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.alvin;</span><br><span class="line"></span><br><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      System.out.println(&quot;Inside java 7&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二步</strong>     </p><p>创建文件夹 c:/test/java9/com/alvin，并在该文件夹下创建 Test.java 文件，代码如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.alvin;</span><br><span class="line"></span><br><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      System.out.println(&quot;Inside java 9&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译源代码：   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\test &gt; javac --release 9 java9/com/alvin/Tester.java    C:\JAVA &gt; javac --release 7 java7/com/alvin/Tester.java</span><br></pre></td></tr></table></figure><p>创建多版本兼容 jar 包    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\JAVA &gt; jar -c -f test.jar -C java7 . --release 9 -C java9.</span><br><span class="line">Warning: entry META-INF/versions/9/com/alvin/Tester.java, </span><br><span class="line">   multiple resources with same name</span><br></pre></td></tr></table></figure><p>使用 JDK 7 执行：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\JAVA &gt; java -cp test.jar com.tutorialspoint.Tester</span><br><span class="line">Inside Java 7</span><br></pre></td></tr></table></figure><p>使用 JDK 9 执行：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\JAVA &gt; java -cp test.jar com.tutorialspoint.Tester</span><br><span class="line">Inside Java 9</span><br></pre></td></tr></table></figure><h4 id="集合工厂方法"><a href="#集合工厂方法" class="headerlink" title="集合工厂方法"></a>集合工厂方法</h4><p>Java 9 List，Set 和 Map 接口中，新的静态工厂方法可以创建这些集合的不可变实例。<br>这些工厂方法可以以更简洁的方式来创建集合。  </p><h5 id="旧方法创建集合"><a href="#旧方法创建集合" class="headerlink" title="旧方法创建集合"></a>旧方法创建集合</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Set;</span><br><span class="line"> </span><br><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String []args) &#123;</span><br><span class="line">      Set&lt;String&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">      set.add(&quot;A&quot;);</span><br><span class="line">      set.add(&quot;B&quot;);</span><br><span class="line">      set.add(&quot;C&quot;);</span><br><span class="line">      set = Collections.unmodifiableSet(set);</span><br><span class="line">      System.out.println(set);</span><br><span class="line">      List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">      list.add(&quot;A&quot;);</span><br><span class="line">      list.add(&quot;B&quot;);</span><br><span class="line">      list.add(&quot;C&quot;);</span><br><span class="line">      list = Collections.unmodifiableList(list);</span><br><span class="line">      System.out.println(list);</span><br><span class="line">      Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">      map.put(&quot;A&quot;,&quot;Apple&quot;);</span><br><span class="line">      map.put(&quot;B&quot;,&quot;Boy&quot;);</span><br><span class="line">      map.put(&quot;C&quot;,&quot;Cat&quot;);</span><br><span class="line">      map = Collections.unmodifiableMap(map);</span><br><span class="line">      System.out.println(map);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[A, B, C]</span><br><span class="line">[A, B, C]</span><br><span class="line">&#123;A=Apple, B=Boy, C=Cat&#125;</span><br></pre></td></tr></table></figure><h5 id="新方法创建集合"><a href="#新方法创建集合" class="headerlink" title="新方法创建集合"></a>新方法创建集合</h5><p>Java 9 中，以下方法被添加到 List，Set 和 Map 接口以及它们的重载对象。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3);</span><br><span class="line">static &lt;E&gt; Set&lt;E&gt;  of(E e1, E e2, E e3);</span><br><span class="line">static &lt;K,V&gt; Map&lt;K,V&gt; of(K k1, V v1, K k2, V v2, K k3, V v3);</span><br><span class="line">static &lt;K,V&gt; Map&lt;K,V&gt; ofEntries(Map.Entry&lt;? extends K,? extends V&gt;... entries)</span><br></pre></td></tr></table></figure><ul><li><p>List 和 Set 接口, of(…) 方法重载了 0 ~ 10 个参数的不同方法 。  </p></li><li><p>Map 接口, of(…) 方法重载了 0 ~ 10 个参数的不同方法 。  </p></li><li><p>Map 接口如果超过 10 个参数, 可以使用 ofEntries(…) 方法。  </p></li></ul><h5 id="新方法创建集合实例"><a href="#新方法创建集合实例" class="headerlink" title="新方法创建集合实例"></a>新方法创建集合实例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.AbstractMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Set;</span><br><span class="line"> </span><br><span class="line">public class Tester &#123;</span><br><span class="line"> </span><br><span class="line">   public static void main(String []args) &#123;</span><br><span class="line">      Set&lt;String&gt; set = Set.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);      </span><br><span class="line">      System.out.println(set);</span><br><span class="line">      List&lt;String&gt; list = List.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);</span><br><span class="line">      System.out.println(list);</span><br><span class="line">      Map&lt;String, String&gt; map = Map.of(&quot;A&quot;,&quot;Apple&quot;,&quot;B&quot;,&quot;Boy&quot;,&quot;C&quot;,&quot;Cat&quot;);</span><br><span class="line">      System.out.println(map);</span><br><span class="line">  </span><br><span class="line">      Map&lt;String, String&gt; map1 = Map.ofEntries (</span><br><span class="line">         new AbstractMap.SimpleEntry&lt;&gt;(&quot;A&quot;,&quot;Apple&quot;),</span><br><span class="line">         new AbstractMap.SimpleEntry&lt;&gt;(&quot;B&quot;,&quot;Boy&quot;),</span><br><span class="line">         new AbstractMap.SimpleEntry&lt;&gt;(&quot;C&quot;,&quot;Cat&quot;));</span><br><span class="line">      System.out.println(map1);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上输出：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[A, B, C]</span><br><span class="line">[A, B, C]</span><br><span class="line">&#123;A=Apple, B=Boy, C=Cat&#125;</span><br><span class="line">&#123;A=Apple, B=Boy, C=Cat&#125;</span><br></pre></td></tr></table></figure><h4 id="私有接口方法"><a href="#私有接口方法" class="headerlink" title="私有接口方法"></a>私有接口方法</h4><p>在 Java 8之前，接口可以有常量变量和抽象方法。如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface Logging &#123;</span><br><span class="line">   String ORACLE = &quot;Oracle_Database&quot;;</span><br><span class="line">   String MYSQL = &quot;MySql_Database&quot;;</span><br><span class="line"> </span><br><span class="line">   void logInfo(String message);</span><br><span class="line">   void logWarn(String message);</span><br><span class="line">   void logError(String message);</span><br><span class="line">   void logFatal(String message);</span><br><span class="line"> </span><br><span class="line">   void getConnection();</span><br><span class="line">   void closeConnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 8 接口引入了一些新功能——默认方法和静态方法。我们可以在Java SE 8的接口中编写方法实现，仅仅需要使用 default 关键字来定义它们。<br>在 Java 8 中，一个接口中能定义如下几种变量/方法：  </p><ul><li>常量  </li><li>抽象方法  </li><li>默认方法  </li><li>静态方法  </li></ul><p>如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">interface Logging &#123;</span><br><span class="line">   String ORACLE = &quot;Oracle_Database&quot;;</span><br><span class="line">   String MYSQL = &quot;MySql_Database&quot;;</span><br><span class="line"> </span><br><span class="line">   default void logInfo(String message) &#123;</span><br><span class="line">      getConnection();</span><br><span class="line">      System.out.println(&quot;Log Message : &quot; + &quot;INFO&quot;);</span><br><span class="line">      closeConnection();</span><br><span class="line">   &#125;</span><br><span class="line">   default void logWarn(String message) &#123;</span><br><span class="line">      getConnection();</span><br><span class="line">      System.out.println(&quot;Log Message : &quot; + &quot;WARN&quot;);</span><br><span class="line">      closeConnection();</span><br><span class="line">   &#125;</span><br><span class="line">   default void logError(String message) &#123;</span><br><span class="line">      getConnection();</span><br><span class="line">      System.out.println(&quot;Log Message : &quot; + &quot;ERROR&quot;);</span><br><span class="line">      closeConnection();</span><br><span class="line">   &#125;</span><br><span class="line">   default void logFatal(String message) &#123;</span><br><span class="line">      getConnection();</span><br><span class="line">      System.out.println(&quot;Log Message : &quot; + &quot;FATAL&quot;);</span><br><span class="line">      closeConnection();</span><br><span class="line">   &#125;</span><br><span class="line">   static void getConnection() &#123;</span><br><span class="line">      System.out.println(&quot;Open Database connection&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   static void closeConnection() &#123;</span><br><span class="line">      System.out.println(&quot;Close Database connection&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Java 9 不仅像 Java 8 一样支持接口默认方法，同时还支持私有方法<br>在 Java 9 中，一个接口中能定义如下几种变量/方法：  </p><ul><li>常量  </li><li>抽象方法  </li><li>默认方法  </li><li>静态方法  </li><li>私有方法  </li><li>私有静态方法  </li></ul><p>以下实例提取了冗余到通用方法，看起来明显更简洁：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String []args) &#123;</span><br><span class="line">      LogOracle log = new LogOracle();</span><br><span class="line">      log.logInfo(&quot;&quot;);</span><br><span class="line">      log.logWarn(&quot;&quot;);</span><br><span class="line">      log.logError(&quot;&quot;);</span><br><span class="line">      log.logFatal(&quot;&quot;);</span><br><span class="line">      </span><br><span class="line">      LogMySql log1 = new LogMySql();</span><br><span class="line">      log1.logInfo(&quot;&quot;);</span><br><span class="line">      log1.logWarn(&quot;&quot;);</span><br><span class="line">      log1.logError(&quot;&quot;);</span><br><span class="line">      log1.logFatal(&quot;&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">final class LogOracle implements Logging &#123; </span><br><span class="line">&#125;</span><br><span class="line">final class LogMySql implements Logging &#123; </span><br><span class="line">&#125;</span><br><span class="line">interface Logging &#123;</span><br><span class="line">   String ORACLE = &quot;Oracle_Database&quot;;</span><br><span class="line">   String MYSQL = &quot;MySql_Database&quot;;</span><br><span class="line"> </span><br><span class="line">   private void log(String message, String prefix) &#123;</span><br><span class="line">      getConnection();</span><br><span class="line">      System.out.println(&quot;Log Message : &quot; + prefix);</span><br><span class="line">      closeConnection();</span><br><span class="line">   &#125;</span><br><span class="line">   default void logInfo(String message) &#123;</span><br><span class="line">      log(message, &quot;INFO&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   default void logWarn(String message) &#123;</span><br><span class="line">      log(message, &quot;WARN&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   default void logError(String message) &#123;</span><br><span class="line">      log(message, &quot;ERROR&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   default void logFatal(String message) &#123;</span><br><span class="line">      log(message, &quot;FATAL&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   private static void getConnection() &#123;</span><br><span class="line">      System.out.println(&quot;Open Database connection&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   private static void closeConnection() &#123;</span><br><span class="line">      System.out.println(&quot;Close Database connection&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="改进的进程-API"><a href="#改进的进程-API" class="headerlink" title="改进的进程 API"></a>改进的进程 API</h4><p>在 Java 9 之前，Process API 仍然缺乏对使用本地进程的基本支持，例如获取进程的 PID 和所有者，进程的开始时间，进程使用了多少 CPU 时间，多少本地进程正在运行等。<br>Java 9 向 Process API 添加了一个名为 ProcessHandle 的接口来增强 java.lang.Process 类。<br>ProcessHandle 接口的实例标识一个本地进程，它允许查询进程状态并管理进程。<br>ProcessHandle 嵌套接口 Info 来让开发者逃离时常因为要获取一个本地进程的 PID 而不得不使用本地代码的窘境。<br>我们不能在接口中提供方法实现。如果我们要提供抽象方法和非抽象方法（方法与实现）的组合，那么我们就得使用抽象类。<br>ProcessHandle 接口中声明的 onExit() 方法可用于在某个进程终止时触发某些操作。  </p><p>实例：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.time.ZoneId;</span><br><span class="line">import java.util.stream.Stream;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"> </span><br><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) throws IOException &#123;</span><br><span class="line">      ProcessBuilder pb = new ProcessBuilder(&quot;notepad.exe&quot;);</span><br><span class="line">      String np = &quot;Not Present&quot;;</span><br><span class="line">      Process p = pb.start();</span><br><span class="line">      ProcessHandle.Info info = p.info();</span><br><span class="line">      System.out.printf(&quot;Process ID : %s%n&quot;, p.pid());</span><br><span class="line">      System.out.printf(&quot;Command name : %s%n&quot;, info.command().orElse(np));</span><br><span class="line">      System.out.printf(&quot;Command line : %s%n&quot;, info.commandLine().orElse(np));</span><br><span class="line"> </span><br><span class="line">      System.out.printf(&quot;Start time: %s%n&quot;,</span><br><span class="line">         info.startInstant().map(i -&gt; i.atZone(ZoneId.systemDefault())</span><br><span class="line">         .toLocalDateTime().toString()).orElse(np));</span><br><span class="line"> </span><br><span class="line">      System.out.printf(&quot;Arguments : %s%n&quot;,</span><br><span class="line">         info.arguments().map(a -&gt; Stream.of(a).collect(</span><br><span class="line">         Collectors.joining(&quot; &quot;))).orElse(np));</span><br><span class="line"> </span><br><span class="line">      System.out.printf(&quot;User : %s%n&quot;, info.user().orElse(np));</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上输出：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Process ID : 5800</span><br><span class="line">Command name : C:\Windows\System32\notepad.exe</span><br><span class="line">Command line : Not Present</span><br><span class="line">Start time: 2017-11-04T21:35:03.626</span><br><span class="line">Arguments : Not Present</span><br><span class="line">User: administrator</span><br></pre></td></tr></table></figure><h4 id="改进的-Stream-API"><a href="#改进的-Stream-API" class="headerlink" title="改进的 Stream API"></a>改进的 Stream API</h4><p>Java 9 改进的 Stream API 添加了一些便利的方法，使流处理更容易，并使用收集器编写复杂的查询。<br>Java 9 为 Stream 新增了几个方法：dropWhile、takeWhile、ofNullable，为 iterate 方法新增了一个重载方法。  </p><h5 id="takeWhile-方法"><a href="#takeWhile-方法" class="headerlink" title="takeWhile 方法"></a>takeWhile 方法</h5><p><strong>语法</strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default Stream&lt;T&gt; takeWhile(Predicate&lt;? super T&gt; predicate)</span><br></pre></td></tr></table></figure><p>takeWhile() 方法使用一个断言作为参数，返回给定 Stream 的子集直到断言语句第一次返回 false。如果第一个值不满足断言条件，将返回一个空的 Stream。<br>takeWhile() 方法在有序的 Stream 中，takeWhile 返回从开头开始的尽量多的元素；在无序的 Stream 中，takeWhile 返回从开头开始的符合 Predicate 要求的元素的子集。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import java.util.stream.Stream;</span><br><span class="line"> </span><br><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Stream.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;&quot;,&quot;e&quot;,&quot;f&quot;).takeWhile(s-&gt;!s.isEmpty())</span><br><span class="line">         .forEach(System.out::print);      </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实例 takeWhile 方法在碰到空字符串时停止循环输出，执行输出结果为：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abc</span><br></pre></td></tr></table></figure><h5 id="dropWhile-方法"><a href="#dropWhile-方法" class="headerlink" title="dropWhile 方法"></a>dropWhile 方法</h5><p><strong>语法</strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default Stream&lt;T&gt; dropWhile(Predicate&lt;? super T&gt; predicate)</span><br></pre></td></tr></table></figure><p>dropWhile 方法和 takeWhile 作用相反的，使用一个断言作为参数，直到断言语句第一次返回 true 才返回给定 Stream 的子集。<br>实例：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import java.util.stream.Stream;</span><br><span class="line"> </span><br><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Stream.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;&quot;,&quot;e&quot;,&quot;f&quot;).dropWhile(s-&gt; !s.isEmpty())</span><br><span class="line">         .forEach(System.out::print);</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实例 dropWhile 方法在碰到空字符串时开始循环输出，执行输出结果为：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ef</span><br></pre></td></tr></table></figure><h5 id="iterate-方法"><a href="#iterate-方法" class="headerlink" title="iterate 方法"></a>iterate 方法</h5><p><strong>语法</strong>   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; Stream&lt;T&gt; iterate(T seed, Predicate&lt;? super T&gt; hasNext, UnaryOperator&lt;T&gt; next)</span><br></pre></td></tr></table></figure><p>方法允许使用初始种子值创建顺序（可能是无限）流，并迭代应用指定的下一个方法。 当指定的 hasNext 的 predicate 返回 false 时，迭代停止。<br>实例：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.util.stream.IntStream;</span><br><span class="line"> </span><br><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      IntStream.iterate(3, x -&gt; x &lt; 10, x -&gt; x+ 3).forEach(System.out::println);</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">6</span><br><span class="line">9</span><br></pre></td></tr></table></figure><h5 id="ofNullable方法"><a href="#ofNullable方法" class="headerlink" title="ofNullable方法"></a>ofNullable方法</h5><p><strong>语法</strong>   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; Stream&lt;T&gt; ofNullable(T t)</span><br></pre></td></tr></table></figure><p>ofNullable 方法可以预防 NullPointerExceptions 异常， 可以通过检查流来避免 null 值。<br>如果指定元素为非 null，则获取一个元素并生成单个元素流，元素为 null 则返回一个空流。   </p><p>实例：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import java.util.stream.Stream;</span><br><span class="line"> </span><br><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      long count = Stream.ofNullable(100).count();</span><br><span class="line">      System.out.println(count);</span><br><span class="line">  </span><br><span class="line">      count = Stream.ofNullable(null).count();</span><br><span class="line">      System.out.println(count);</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行输出结果为：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h4 id="改进的-try-with-resources"><a href="#改进的-try-with-resources" class="headerlink" title="改进的 try-with-resources"></a>改进的 try-with-resources</h4><p>try-with-resources 是 JDK 7 中一个新的异常处理机制，它能够很容易地关闭在 try-catch 语句块中使用的资源。所谓的资源（resource）是指在程序完成后，必须关闭的对象。try-with-resources 语句确保了每个资源在语句结束时关闭。所有实现了 java.lang.AutoCloseable 接口（其中，它包括实现了 java.io.Closeable 的所有对象），可以使用作为资源。<br>try-with-resources 声明在 JDK 9 已得到改进。如果你已经有一个资源是 final 或等效于 final 变量,您可以在 try-with-resources 语句中使用该变量，而无需在 try-with-resources 语句中声明一个新变量。   </p><p>实例：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.Reader;</span><br><span class="line">import java.io.StringReader;</span><br><span class="line"> </span><br><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) throws IOException &#123;</span><br><span class="line">      System.out.println(readData(&quot;test&quot;));</span><br><span class="line">   &#125; </span><br><span class="line">   static String readData(String message) throws IOException &#123;</span><br><span class="line">      Reader inputString = new StringReader(message);</span><br><span class="line">      BufferedReader br = new BufferedReader(inputString);</span><br><span class="line">      try (BufferedReader br1 = br) &#123;</span><br><span class="line">         return br1.readLine();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test</span><br></pre></td></tr></table></figure><p>以上实例中我们需要在 try 语句块中声明资源 br1，然后才能使用它。<br>在 Java 9 中，我们不需要声明资源 br1 就可以使用它，并得到相同的结果。   </p><p>实例：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.Reader;</span><br><span class="line">import java.io.StringReader;</span><br><span class="line"> </span><br><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) throws IOException &#123;</span><br><span class="line">      System.out.println(readData(&quot;test&quot;));</span><br><span class="line">   &#125; </span><br><span class="line">   static String readData(String message) throws IOException &#123;</span><br><span class="line">      Reader inputString = new StringReader(message);</span><br><span class="line">      BufferedReader br = new BufferedReader(inputString);</span><br><span class="line">      try (br) &#123;</span><br><span class="line">         return br.readLine();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行输出结果为：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test</span><br></pre></td></tr></table></figure><p>在处理必须关闭的资源时，使用try-with-resources语句替代try-finally语句。 生成的代码更简洁，更清晰，并且生成的异常更有用。 try-with-resources语句在编写必须关闭资源的代码时会更容易，也不会出错，而使用try-finally语句实际上是不可能的。   </p><h4 id="钻石操作符-Diamond-Operator"><a href="#钻石操作符-Diamond-Operator" class="headerlink" title="钻石操作符(Diamond Operator)"></a>钻石操作符(Diamond Operator)</h4><p>钻石操作符是在 java 7 中引入的，可以让代码更易读，但它不能用于匿名的内部类。<br>在 java 9 中， 它可以与匿名的内部类一起使用，从而提高代码的可读性。<br>考虑以下 Java 9 之前的代码：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Handler&lt;Integer&gt; intHandler = new Handler&lt;Integer&gt;(1) &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void handle() &#123;</span><br><span class="line">            System.out.println(content);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      intHandler.handle();</span><br><span class="line">      Handler&lt;? extends Number&gt; intHandler1 = new Handler&lt;Number&gt;(2) &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void handle() &#123;</span><br><span class="line">            System.out.println(content);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      intHandler1.handle();</span><br><span class="line">      Handler&lt;?&gt; handler = new Handler&lt;Object&gt;(&quot;test&quot;) &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void handle() &#123;</span><br><span class="line">            System.out.println(content);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      handler.handle();    </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br><span class="line">abstract class Handler&lt;T&gt; &#123;</span><br><span class="line">   public T content;</span><br><span class="line"> </span><br><span class="line">   public Handler(T content) &#123;</span><br><span class="line">      this.content = content; </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   abstract void handle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">Test</span><br></pre></td></tr></table></figure><p>在 Java 9 中，我们可以在匿名类中使用 &lt;&gt; 操作符，如下所示：<br>实例：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Handler&lt;Integer&gt; intHandler = new Handler&lt;&gt;(1) &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void handle() &#123;</span><br><span class="line">            System.out.println(content);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      intHandler.handle();</span><br><span class="line">      Handler&lt;? extends Number&gt; intHandler1 = new Handler&lt;&gt;(2) &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void handle() &#123;</span><br><span class="line">            System.out.println(content);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      intHandler1.handle();</span><br><span class="line">      Handler&lt;?&gt; handler = new Handler&lt;&gt;(&quot;test&quot;) &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void handle() &#123;</span><br><span class="line">            System.out.println(content);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"> </span><br><span class="line">      handler.handle();    </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">abstract class Handler&lt;T&gt; &#123;</span><br><span class="line">   public T content;</span><br><span class="line"> </span><br><span class="line">   public Handler(T content) &#123;</span><br><span class="line">      this.content = content; </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   abstract void handle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">Test</span><br></pre></td></tr></table></figure><h4 id="改进的-Optional-类"><a href="#改进的-Optional-类" class="headerlink" title="改进的 Optional 类"></a>改进的 Optional 类</h4><p>Optional 类在 Java 8 中引入，Optional 类的引入很好的解决空指针异常。。在 java 9 中, 添加了三个方法来改进它的功能：   </p><ul><li>stream()  </li><li>ifPresentOrElse()  </li><li>or()  </li></ul><h5 id="stream-方法"><a href="#stream-方法" class="headerlink" title="stream() 方法"></a>stream() 方法</h5><p><strong>语法</strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Stream&lt;T&gt; stream()</span><br></pre></td></tr></table></figure><p>stream 方法的作用就是将 Optional 转为一个 Stream，如果该 Optional 中包含值，那么就返回包含这个值的 Stream，否则返回一个空的 Stream（Stream.empty()）。<br>实例：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Optional;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line">import java.util.stream.Stream;</span><br><span class="line"> </span><br><span class="line">public class Tester &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">   List&lt;Optional&lt;String&gt;&gt; list = Arrays.asList (</span><br><span class="line">      Optional.empty(), </span><br><span class="line">      Optional.of(&quot;A&quot;), </span><br><span class="line">      Optional.empty(), </span><br><span class="line">      Optional.of(&quot;B&quot;));</span><br><span class="line"> </span><br><span class="line">      //filter the list based to print non-empty values</span><br><span class="line">  </span><br><span class="line">      //if optional is non-empty, get the value in stream, otherwise return empty</span><br><span class="line">      List&lt;String&gt; filteredList = list.stream()</span><br><span class="line">         .flatMap(o -&gt; o.isPresent() ? Stream.of(o.get()) : Stream.empty())</span><br><span class="line">         .collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line">      //Optional::stream method will return a stream of either one </span><br><span class="line">      //or zero element if data is present or not.</span><br><span class="line">      List&lt;String&gt; filteredListJava9 = list.stream()</span><br><span class="line">         .flatMap(Optional::stream)</span><br><span class="line">         .collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line">      System.out.println(filteredList);</span><br><span class="line">      System.out.println(filteredListJava9);</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行输出结果为：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[A, B]</span><br><span class="line">[A, B]</span><br></pre></td></tr></table></figure><h5 id="ifPresentOrElse-方法"><a href="#ifPresentOrElse-方法" class="headerlink" title="ifPresentOrElse() 方法"></a>ifPresentOrElse() 方法</h5><p><strong>语法</strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void ifPresentOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction)</span><br></pre></td></tr></table></figure><p>ifPresentOrElse 方法的改进就是有了 else，接受两个参数 Consumer 和 Runnable。<br>ifPresentOrElse 方法的用途是，如果一个 Optional 包含值，则对其包含的值调用函数 action，即 action.accept(value)，这与 ifPresent 一致；与 ifPresent 方法的区别在于，ifPresentOrElse 还有第二个参数 emptyAction —— 如果 Optional 不包含值，那么 ifPresentOrElse 便会调用 emptyAction，即 emptyAction.run()。  </p><p>实例：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Optional;</span><br><span class="line"> </span><br><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Optional&lt;Integer&gt; optional = Optional.of(1);</span><br><span class="line"> </span><br><span class="line">      optional.ifPresentOrElse( x -&gt; System.out.println(&quot;Value: &quot; + x),() -&gt; </span><br><span class="line">         System.out.println(&quot;Not Present.&quot;));</span><br><span class="line"> </span><br><span class="line">      optional = Optional.empty();</span><br><span class="line"> </span><br><span class="line">      optional.ifPresentOrElse( x -&gt; System.out.println(&quot;Value: &quot; + x),() -&gt; </span><br><span class="line">         System.out.println(&quot;Not Present.&quot;));</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Value: 1</span><br><span class="line">Not Present.</span><br></pre></td></tr></table></figure><h4 id="or-方法"><a href="#or-方法" class="headerlink" title="or() 方法"></a>or() 方法</h4><p><strong>语法</strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Optional&lt;T&gt; or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier)</span><br></pre></td></tr></table></figure><p>如果值存在，返回 Optional 指定的值，否则返回一个预设的值。<br>实例：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Optional;</span><br><span class="line">import java.util.function.Supplier;</span><br><span class="line"> </span><br><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Optional&lt;String&gt; optional1 = Optional.of(&quot;Mahesh&quot;);</span><br><span class="line">      Supplier&lt;Optional&lt;String&gt;&gt; supplierString = () -&gt; Optional.of(&quot;Not Present&quot;);</span><br><span class="line">      optional1 = optional1.or( supplierString);</span><br><span class="line">      optional1.ifPresent( x -&gt; System.out.println(&quot;Value: &quot; + x));</span><br><span class="line">      optional1 = Optional.empty();    </span><br><span class="line">      optional1 = optional1.or( supplierString);</span><br><span class="line">      optional1.ifPresent( x -&gt; System.out.println(&quot;Value: &quot; + x));  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行输出结果为：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Value: Mahesh</span><br><span class="line">Value: Not Present</span><br></pre></td></tr></table></figure><h4 id="多分辨率图像-API"><a href="#多分辨率图像-API" class="headerlink" title="多分辨率图像 API"></a>多分辨率图像 API</h4><p>Java 9 定义多分辨率图像 API，开发者可以很容易的操作和展示不同分辨率的图像了。<br>以下是多分辨率图像的主要操作方法：  </p><ul><li><strong>Image getResolutionVariant(double destImageWidth, double destImageHeight)</strong> − 获取特定分辨率的图像变体-表示一张已知分辨率单位为DPI的特定尺寸大小的逻辑图像，并且这张图像是最佳的变体。</li><li><strong>List<image> getResolutionVariants()</image></strong> − 返回可读的分辨率的图像变体列表。<br>实例：  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.URL;</span><br><span class="line">import java.net.MalformedURLException;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.awt.Image;</span><br><span class="line">import java.awt.image.MultiResolutionImage;</span><br><span class="line">import java.awt.image.BaseMultiResolutionImage;</span><br><span class="line"> </span><br><span class="line">import javax.imageio.ImageIO;</span><br><span class="line"> </span><br><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) throws IOException, MalformedURLException &#123;</span><br><span class="line"> </span><br><span class="line">      List&lt;String&gt; imgUrls = List.of(&quot;http://www.runoob.com/wp-content/themes/runoob/assets/img/runoob-logo@2x.png&quot;,</span><br><span class="line">         &quot;http://www.runoob.com/wp-content/themes/runoob/assets/img/runoob-logo.png&quot;,</span><br><span class="line">         &quot;http://www.runoob.com/wp-content/themes/runoob/assets/images/qrcode.png&quot;);</span><br><span class="line"> </span><br><span class="line">      List&lt;Image&gt; images = new ArrayList&lt;Image&gt;();</span><br><span class="line"> </span><br><span class="line">      for (String url : imgUrls) &#123;</span><br><span class="line">         images.add(ImageIO.read(new URL(url)));</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      // 读取所有图片</span><br><span class="line">      MultiResolutionImage multiResolutionImage = </span><br><span class="line">         new BaseMultiResolutionImage(images.toArray(new Image[0]));</span><br><span class="line"> </span><br><span class="line">      // 获取图片的所有分辨率</span><br><span class="line">      List&lt;Image&gt; variants = multiResolutionImage.getResolutionVariants();</span><br><span class="line"> </span><br><span class="line">      System.out.println(&quot;Total number of images: &quot; + variants.size());</span><br><span class="line"> </span><br><span class="line">      for (Image img : variants) &#123;</span><br><span class="line">         System.out.println(img);</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      // 根据不同尺寸获取对应的图像分辨率</span><br><span class="line">      Image variant1 = multiResolutionImage.getResolutionVariant(156, 45);</span><br><span class="line">      System.out.printf(&quot;\nImage for destination[%d,%d]: [%d,%d]&quot;, </span><br><span class="line">         156, 45, variant1.getWidth(null), variant1.getHeight(null));</span><br><span class="line"> </span><br><span class="line">      Image variant2 = multiResolutionImage.getResolutionVariant(311, 89);</span><br><span class="line">      System.out.printf(&quot;\nImage for destination[%d,%d]: [%d,%d]&quot;, 311, 89, </span><br><span class="line">         variant2.getWidth(null), variant2.getHeight(null));</span><br><span class="line"> </span><br><span class="line">      Image variant3 = multiResolutionImage.getResolutionVariant(622, 178);</span><br><span class="line">      System.out.printf(&quot;\nImage for destination[%d,%d]: [%d,%d]&quot;, 622, 178, </span><br><span class="line">         variant3.getWidth(null), variant3.getHeight(null));</span><br><span class="line"> </span><br><span class="line">      Image variant4 = multiResolutionImage.getResolutionVariant(300, 300);</span><br><span class="line">      System.out.printf(&quot;\nImage for destination[%d,%d]: [%d,%d]&quot;, 300, 300, </span><br><span class="line">         variant4.getWidth(null), variant4.getHeight(null));</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="改进的-CompletableFuture-API"><a href="#改进的-CompletableFuture-API" class="headerlink" title="改进的 CompletableFuture API"></a>改进的 CompletableFuture API</h4><p>Java 8 引入了 CompletableFuture<t> 类，可能是 java.util.concurrent.Future<t> 明确的完成版（设置了它的值和状态），也可能被用作java.util.concurrent.CompleteStage 。支持 future 完成时触发一些依赖的函数和动作。Java 9 引入了一些CompletableFuture 的改进：<br>Java 9 对 CompletableFuture 做了改进：  </t></t></p><ul><li>支持 delays 和 timeouts  </li><li>提升了对子类化的支持  </li><li>新的工厂方法  </li></ul><h5 id="支持-delays-和-timeouts"><a href="#支持-delays-和-timeouts" class="headerlink" title="支持 delays 和 timeouts"></a>支持 delays 和 timeouts</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public CompletableFuture&lt;T&gt; completeOnTimeout(T value, long timeout, TimeUnit unit)</span><br></pre></td></tr></table></figure><p>在 timeout（单位在 java.util.concurrent.Timeunits units 中，比如 MILLISECONDS ）前以给定的 value 完成这个 CompletableFutrue。返回这个 CompletableFutrue。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public CompletableFuture&lt;T&gt; orTimeout(long timeout, TimeUnit unit)</span><br></pre></td></tr></table></figure><p>如果没有在给定的 timeout 内完成，就以 java.util.concurrent.TimeoutException 完成这个 CompletableFutrue，并返回这个 CompletableFutrue。  </p><h5 id="增强了对子类化的支持"><a href="#增强了对子类化的支持" class="headerlink" title="增强了对子类化的支持"></a>增强了对子类化的支持</h5><p>做了许多改进使得 CompletableFuture 可以被更简单的继承。比如，你也许想重写新的 public Executor defaultExecutor() 方法来代替默认的 executor。<br>另一个新的使子类化更容易的方法是：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; newIncompleteFuture()</span><br></pre></td></tr></table></figure><h5 id="新的工厂方法"><a href="#新的工厂方法" class="headerlink" title="新的工厂方法"></a>新的工厂方法</h5><p>Java 8引入了 <u> CompletableFuture<u> completedFuture(U value) 工厂方法来返回一个已经以给定 value 完成了的 CompletableFuture。<br>Java 9以 一个新的 <u> CompletableFuture<u> failedFuture(Throwable ex) 来补充了这个方法，可以返回一个以给定异常完成的 CompletableFuture。<br>除此以外，Java 9 引入了下面这对 stage-oriented 工厂方法，返回完成的或异常完成的 completion stages:  </u></u></u></u></p><ul><li><strong><u> CompletionStage<u> completedStage(U value):</u></u></strong> 返回一个新的以指定 value 完成的CompletionStage ，并且只支持 CompletionStage 里的接口。  </li><li><strong><u> CompletionStage<u> failedStage(Throwable ex):</u></u></strong> 返回一个新的以指定异常完成的CompletionStage ，并且只支持 CompletionStage 里的接口。  </li></ul><h4 id="改进的-Javadoc"><a href="#改进的-Javadoc" class="headerlink" title="改进的 Javadoc"></a>改进的 Javadoc</h4><h4 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jdk9新特性。&lt;br&gt;
    
    </summary>
    
    
      <category term="jdk" scheme="https://dongme.site/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>jdk新特性之jdk8</title>
    <link href="https://dongme.site/2018/10/15/jdk%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8Bjdk8/"/>
    <id>https://dongme.site/2018/10/15/jdk新特性之jdk8/</id>
    <published>2018-10-15T15:43:00.000Z</published>
    <updated>2018-10-16T16:52:56.097Z</updated>
    
    <content type="html"><![CDATA[<p>毫无疑问，Java 8是Java自Java 5（发布于2004年）之后的最重要的版本。这个版本包含语言、编译器、库、工具和JVM等方面的十多个新特性。<br><a id="more"></a></p><h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><p>Lambda表达式，也称为闭包。Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中）。<br>使用Lambda表达式可以使代码变的更加简洁紧凑。<br>Lambda 表达式免去了使用匿名方法的麻烦，并且给予Java简单但是强大的函数化的编程能力。  </p><p>语法：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br><span class="line">或</span><br><span class="line">(parameter) -&gt; &#123;expression;&#125;</span><br></pre></td></tr></table></figure><p>Lambda表达式的特征如下：  </p><blockquote><p>可选类型声明：不需要声明参数类型，编译器可以统一识别。<br>可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。<br>可选的大括号：如果主体包含了一个语句，就不需要使用大括号。<br>可选的返回关键字：如果主体只有一个表达式 。  </p></blockquote><p>简单例子：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 1. 不需要参数,返回值为 5  </span><br><span class="line">() -&gt; 5  </span><br><span class="line">  </span><br><span class="line">// 2. 接收一个参数(数字类型),返回其2倍的值  </span><br><span class="line">x -&gt; 2 * x  </span><br><span class="line">  </span><br><span class="line">// 3. 接受2个参数(数字),并返回他们的差值  </span><br><span class="line">(x, y) -&gt; x – y  </span><br><span class="line">  </span><br><span class="line">// 4. 接收2个int型整数,返回他们的和  </span><br><span class="line">(int x, int y) -&gt; x + y  </span><br><span class="line">  </span><br><span class="line">// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  </span><br><span class="line">(String s) -&gt; System.out.print(s)</span><br></pre></td></tr></table></figure><p>测试：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Java8Lambda &#123;</span><br><span class="line">    interface MathOperation &#123;</span><br><span class="line">        int operation(int a, int b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface GreetingService &#123;</span><br><span class="line">        void sayMessage(String message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int operate(int a, int b, MathOperation mathOperation) &#123;</span><br><span class="line">        return mathOperation.operation(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Java8Lambda java8Lambda = new Java8Lambda();</span><br><span class="line">        // 参数类型声明</span><br><span class="line">        MathOperation addition = (int a, int b) -&gt; a + b;</span><br><span class="line">        // 不用类型声明</span><br><span class="line">        MathOperation subtraction = (a, b) -&gt; a - b;</span><br><span class="line">        // 大括号中返回语句</span><br><span class="line">        MathOperation multiplication = (int a, int b) -&gt; &#123;</span><br><span class="line">            return a * b;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 没有大括号及返回语句</span><br><span class="line">        MathOperation division = (int a, int b) -&gt; a / b;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;6 + 2 = &quot; + java8Lambda.operate(6, 2, addition));</span><br><span class="line">        System.out.println(&quot;6 - 2 = &quot; + java8Lambda.operate(6, 2, subtraction));</span><br><span class="line">        System.out.println(&quot;6 * 2 = &quot; + java8Lambda.operate(6, 2, multiplication));</span><br><span class="line">        System.out.println(&quot;6 / 2 = &quot; + java8Lambda.operate(6, 2, division));</span><br><span class="line">        // 不用括号</span><br><span class="line">        GreetingService gs1 = message -&gt; System.out.println(&quot;hello, &quot; + message);</span><br><span class="line">        // 用括号</span><br><span class="line">        GreetingService gs2 = (message) -&gt; System.out.println(&quot;Hello,&quot; + message);</span><br><span class="line"></span><br><span class="line">        gs1.sayMessage(&quot;Runoob&quot;);</span><br><span class="line">        gs2.sayMessage(&quot;Google&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口默认方法"><a href="#接口默认方法" class="headerlink" title="接口默认方法"></a>接口默认方法</h4><p>简单说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。我们只需在方法名前面加个default关键字即可实现默认方法。</p><p><strong>为什么要有这个特性？</strong></p><blockquote><p>首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类，目前的java 8之前的集合框架没有foreach方法，通常能想到的解决办法是在JDK里给相关的接口添加新的方法及实现。然而，对于已经发布的版本，是没法在给接口添加新方法的同时不影响已有的实现。所以引进的默认方法。他们的目的是为了解决接口的修改与现有的实现不兼容的问题。</p></blockquote><p><strong>语法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Vehicle &#123;</span><br><span class="line">   default void print()&#123;</span><br><span class="line">      System.out.println(&quot;she is lily&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多个默认方法：</strong><br>一个接口有默认方法，考虑这样的情况，一个类实现了多个接口，且这些接口有相同的默认方法，以下实例说明了这种情况的解决方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface Vehicle &#123;</span><br><span class="line">   default void print()&#123;</span><br><span class="line">      System.out.println(&quot;我是一辆车!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface FourWheeler &#123;</span><br><span class="line">   default void print()&#123;</span><br><span class="line">      System.out.println(&quot;我是一辆四轮车!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个解决方案是创建自己的默认方法，来覆盖重写接口的默认方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Car implements Vehicle, FourWheeler &#123;</span><br><span class="line">   default void print()&#123;</span><br><span class="line">      System.out.println(&quot;我是一辆四轮汽车!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种解决方案可以使用 super 来调用指定接口的默认方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Car implements Vehicle, FourWheeler &#123;</span><br><span class="line">   public void print()&#123;</span><br><span class="line">      Vehicle.super.print();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>Java 8 的另一个特性是接口可以声明（并且可以提供实现）静态方法。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Java8Tester &#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      Vehicle vehicle = new Car();</span><br><span class="line">      vehicle.print();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Vehicle &#123;</span><br><span class="line">   default void print()&#123;</span><br><span class="line">      System.out.println(&quot;我是一辆车!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   static void blowHorn()&#123;</span><br><span class="line">      System.out.println(&quot;按喇叭!!!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface FourWheeler &#123;</span><br><span class="line">   default void print()&#123;</span><br><span class="line">      System.out.println(&quot;我是一辆四轮车!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Car implements Vehicle, FourWheeler &#123;</span><br><span class="line">   public void print()&#123;</span><br><span class="line">      Vehicle.super.print();</span><br><span class="line">      FourWheeler.super.print();</span><br><span class="line">      Vehicle.blowHorn();</span><br><span class="line">      System.out.println(&quot;我是一辆汽车!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p>函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。<br>函数式接口可以被隐式转换为lambda表达式。<br>函数式接口可以现有的函数友好地支持 lambda。  </p><ul><li>JDK 1.8之前已有的函数式接口  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Runnable</span><br><span class="line">java.util.concurrent.Callable</span><br><span class="line">java.security.PrivilegedAction</span><br><span class="line">java.util.Comparator</span><br><span class="line">java.io.FileFilter</span><br><span class="line">java.nio.file.PathMatcher</span><br><span class="line">java.lang.reflect.InvocationHandler</span><br><span class="line">java.beans.PropertyChangeListener</span><br><span class="line">java.awt.event.ActionListener</span><br><span class="line">javax.swing.event.ChangeListener</span><br></pre></td></tr></table></figure><ul><li>JDK 1.8 新增加的函数接口 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.function</span><br></pre></td></tr></table></figure><ul><li>java.util.function 它包含了很多类，用来支持 Java的 函数式编程，该包中的函数式接口有     </li></ul><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">接口 &amp; 描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">BiConsumer<t,u> 代表了一个接受两个输入参数的操作，并且不返回任何结果</t,u></td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">BiFunction<t,u,r> 代表了一个接受两个输入参数的方法，并且返回一个结果</t,u,r></td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">BinaryOperator<t> 代表了一个作用于于两个同类型操作符的操作，并且返回了操作符同类型的结果</t></td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">BiPredicate<t,u> 代表了一个两个参数的boolean值方法</t,u></td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">BooleanSupplier代表了boolean值结果的提供方</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">Consumer<t>代表了接受一个输入参数并且无返回的操作</t></td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">DoubleBinaryOperator 代表了作用于两个double值操作符的操作，并且返回了一个double值的结果。</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left">DoubleConsumer 代表一个接受double值参数的操作，并且不返回结果。</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left">DoubleFunction<r> 代表接受一个double值参数的方法，并且返回结果</r></td></tr><tr><td style="text-align:left">10</td><td style="text-align:left">DoublePredicate 代表一个拥有double值参数的boolean值方法</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left">DoubleSupplier 代表一个double值结构的提供方</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left">DoubleToIntFunction 接受一个double类型输入，返回一个int类型结果</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left">DoubleToLongFunction 接受一个double类型输入，返回一个long类型结果</td></tr><tr><td style="text-align:left">14</td><td style="text-align:left">DoubleUnaryOperator 接受一个参数同为类型double,返回值类型也为double</td></tr><tr><td style="text-align:left">15</td><td style="text-align:left">Function<t,r> 接受一个输入参数，返回一个结果</t,r></td></tr><tr><td style="text-align:left">16</td><td style="text-align:left">IntBinaryOperator 接受两个参数同为类型int,返回值类型也为int</td></tr><tr><td style="text-align:left">17</td><td style="text-align:left">IntConsumer 接受一个int类型的输入参数，无返回值</td></tr><tr><td style="text-align:left">18</td><td style="text-align:left">IntFunction<r> 接受一个int类型输入参数，返回一个结果</r></td></tr><tr><td style="text-align:left">19</td><td style="text-align:left">IntPredicate 接受一个int输入参数，返回一个布尔值的结果</td></tr><tr><td style="text-align:left">…</td><td style="text-align:left">…</td></tr></tbody></table><ul><li>函数式接口实例<br>redicate <t> 接口是一个函数式接口，它接受一个输入参数 T，返回一个布尔值结果。<br>该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）。<br>该接口用于测试对象是 true 或 false。<br>我们可以通过以下实例（Java8Tester.java）来了解函数式接口 Predicate <t> 的使用：    </t></t></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.function.Predicate;</span><br><span class="line"> </span><br><span class="line">public class Java8Tester &#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);</span><br><span class="line">        </span><br><span class="line">      // Predicate&lt;Integer&gt; predicate = n -&gt; true</span><br><span class="line">      // n 是一个参数传递到 Predicate 接口的 test 方法</span><br><span class="line">      // n 如果存在则 test 方法返回 true</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;输出所有数据:&quot;);</span><br><span class="line">        </span><br><span class="line">      // 传递参数 n</span><br><span class="line">      eval(list, n-&gt;true);</span><br><span class="line">        </span><br><span class="line">      // Predicate&lt;Integer&gt; predicate1 = n -&gt; n%2 == 0</span><br><span class="line">      // n 是一个参数传递到 Predicate 接口的 test 方法</span><br><span class="line">      // 如果 n%2 为 0 test 方法返回 true</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;输出所有偶数:&quot;);</span><br><span class="line">      eval(list, n-&gt; n%2 == 0 );</span><br><span class="line">        </span><br><span class="line">      // Predicate&lt;Integer&gt; predicate2 = n -&gt; n &gt; 3</span><br><span class="line">      // n 是一个参数传递到 Predicate 接口的 test 方法</span><br><span class="line">      // 如果 n 大于 3 test 方法返回 true</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;输出大于 3 的所有数字:&quot;);</span><br><span class="line">      eval(list, n-&gt; n &gt; 3 );</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   public static void eval(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate) &#123;</span><br><span class="line">      for(Integer n: list) &#123;</span><br><span class="line">        </span><br><span class="line">         if(predicate.test(n)) &#123;</span><br><span class="line">            System.out.println(n + &quot; &quot;);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>eval 函数可以写为如下格式  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static void eval(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate) &#123;</span><br><span class="line">    list.stream().filter(predicate).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者直接可以不用定义 eval 函数，使用:   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().filter(n -&gt; n &gt; 3).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>来输出所有大于 3 的数字。   </p><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>方法引用通过方法的名字来指向一个方法。<br>方法引用可以使语言的构造更紧凑简洁，减少冗余代码。<br>方法引用使用一对冒号<code>::</code>。  </p><p> 下面，我们在 Car 类中定义了 4 个方法作为例子来区分 Java 中 4 种不同方法的引用。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Supplier&lt;T&gt; &#123;</span><br><span class="line">    T get();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Car &#123;</span><br><span class="line">    //Supplier是jdk1.8的接口，这里和lamda一起使用了</span><br><span class="line">    public static Car create(final Supplier&lt;Car&gt; supplier) &#123;</span><br><span class="line">        return supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void collide(final Car car) &#123;</span><br><span class="line">        System.out.println(&quot;Collided &quot; + car.toString());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void follow(final Car another) &#123;</span><br><span class="line">        System.out.println(&quot;Following the &quot; + another.toString());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void repair() &#123;</span><br><span class="line">        System.out.println(&quot;Repaired &quot; + this.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>构造器引用：</strong> 它的语法是Class::new，或者更一般的Class&lt; T &gt;::new实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final Car car = Car.create( Car::new );</span><br><span class="line">final List&lt; Car &gt; cars = Arrays.asList( car );</span><br></pre></td></tr></table></figure><p><strong>静态方法引用：</strong>它的语法是Class::static_method，实例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cars.forEach( Car::collide );</span><br></pre></td></tr></table></figure></p><p><strong>特定类的任意对象的方法引用：</strong>它的语法是Class::method实例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cars.forEach( Car::repair );</span><br></pre></td></tr></table></figure></p><p><strong>特定对象的方法引用：</strong>它的语法是instance::method实例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final Car police = Car.create( Car::new );</span><br><span class="line">cars.forEach( police::follow );</span><br></pre></td></tr></table></figure></p><ul><li>方法引用实例     </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String args[])&#123;</span><br><span class="line">     List names = new ArrayList();</span><br><span class="line">       </span><br><span class="line">     names.add(&quot;Google&quot;);</span><br><span class="line">     names.add(&quot;Runoob&quot;);</span><br><span class="line">     names.add(&quot;Taobao&quot;);</span><br><span class="line">     names.add(&quot;Baidu&quot;);</span><br><span class="line">     names.add(&quot;Sina&quot;);</span><br><span class="line">       </span><br><span class="line">     names.forEach(System.out::println);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h4><p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明式的方式处理数据。<br>Stream使用一种类似用SQL语句从数据库查询数据的直观方式来提供一种对Java集合运算和表达的高阶抽象。<br>Stream API可以极大的提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。<br>这种风格将要处理的元素集合看作一种流，流在管道中传输，并且可以在管道的节点上进行处理，比如筛选、排序、聚合等。<br>元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作（terminal operation）得到前面处理的结果。   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+       +------+   +------+   +---+   +-------+</span><br><span class="line">| stream of elements +-----&gt; |filter+-&gt; |sorted+-&gt; |map+-&gt; |collect|</span><br><span class="line">+--------------------+       +------+   +------+   +---+   +-------+</span><br></pre></td></tr></table></figure><p>以上的流程转换为 Java 代码为： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; transactionsIds = </span><br><span class="line">widgets.stream()</span><br><span class="line">             .filter(b -&gt; b.getColor() == RED)</span><br><span class="line">             .sorted((x,y) -&gt; x.getWeight() - y.getWeight())</span><br><span class="line">             .mapToInt(Widget::getWeight)</span><br><span class="line">             .sum();</span><br></pre></td></tr></table></figure><ul><li>什么是 Stream？<br>Stream（流）是一个来自数据源的元素队列并支持聚合操作</li></ul><blockquote><p>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。<br><strong>数据源</strong> 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。<br><strong>聚合操作</strong> 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。   </p></blockquote><p>和以前的Collection操作不同， Stream操作还有两个基础的特征：   </p><blockquote><p><strong>Pipelining:</strong> 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。<br><strong>内部迭代：</strong> 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。   </p></blockquote><ul><li>生成流<br>在 Java 8 中, 集合接口有两个方法来生成流：<br>1）stream() − 为集合创建串行流。<br>2）parallelStream() − 为集合创建并行流。   </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><ul><li>forEach<br>Stream 提供了新的方法 ‘forEach’ 来迭代流中的每个数据。以下代码片段使用 forEach 输出了10个随机数：  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = new Random();</span><br><span class="line">random.ints().limit(10).forEach(System.out::println);</span><br></pre></td></tr></table></figure><ul><li>map<br>map 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：   </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);</span><br><span class="line">// 获取对应的平方数</span><br><span class="line">List&lt;Integer&gt; squaresList = numbers.stream().map( i -&gt; i*i).distinct().collect(Collectors.toList());</span><br></pre></td></tr></table></figure><ul><li>filter<br>filter 方法用于通过设置的条件过滤出元素。以下代码片段使用 filter 方法过滤出空字符串：  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">// 获取空字符串的数量</span><br><span class="line">int count = strings.stream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure><ul><li>limit<br>limit 方法用于获取指定数量的流。 以下代码片段使用 limit 方法打印出 10 条数据：  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = new Random();</span><br><span class="line">random.ints().limit(10).forEach(System.out::println);</span><br></pre></td></tr></table></figure><ul><li>sorted<br>sorted 方法用于对流进行排序。以下代码片段使用 sorted 方法对输出的 10 个随机数进行排序：   </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = new Random();</span><br><span class="line">random.ints().limit(10).sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure><ul><li>并行（parallel）程序<br>parallelStream 是流并行处理程序的代替方法。以下实例我们使用 parallelStream 来输出空字符串的数量： </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">// 获取空字符串的数量</span><br><span class="line">int count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure><ul><li>Collectors<br>Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors 可用于返回列表或字符串：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line">System.out.println(&quot;筛选列表: &quot; + filtered);</span><br><span class="line">String mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(&quot;, &quot;));</span><br><span class="line">System.out.println(&quot;合并字符串: &quot; + mergedString);</span><br></pre></td></tr></table></figure><ul><li>统计<br>另外，一些产生统计结果的收集器也非常有用。它们主要用于int、double、long等基本类型上，它们可以用来产生类似如下的统计结果。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);</span><br><span class="line">IntSummaryStatistics stats = integers.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line">System.out.println(&quot;列表中最大的数 : &quot; + stats.getMax());</span><br><span class="line">System.out.println(&quot;列表中最小的数 : &quot; + stats.getMin());</span><br><span class="line">System.out.println(&quot;所有数之和 : &quot; + stats.getSum());</span><br><span class="line">System.out.println(&quot;平均数 : &quot; + stats.getAverage());</span><br></pre></td></tr></table></figure><ul><li>Stream 完整实例    </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.IntSummaryStatistics;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Random;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line">import java.util.Map;</span><br><span class="line"> </span><br><span class="line">public class Java8Tester &#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      System.out.println(&quot;使用 Java 7: &quot;);</span><br><span class="line">        </span><br><span class="line">      // 计算空字符串</span><br><span class="line">      List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">      System.out.println(&quot;列表: &quot; +strings);</span><br><span class="line">      long count = getCountEmptyStringUsingJava7(strings);</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;空字符数量为: &quot; + count);</span><br><span class="line">      count = getCountLength3UsingJava7(strings);</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;字符串长度为 3 的数量为: &quot; + count);</span><br><span class="line">        </span><br><span class="line">      // 删除空字符串</span><br><span class="line">      List&lt;String&gt; filtered = deleteEmptyStringsUsingJava7(strings);</span><br><span class="line">      System.out.println(&quot;筛选后的列表: &quot; + filtered);</span><br><span class="line">        </span><br><span class="line">      // 删除空字符串，并使用逗号把它们合并起来</span><br><span class="line">      String mergedString = getMergedStringUsingJava7(strings,&quot;, &quot;);</span><br><span class="line">      System.out.println(&quot;合并字符串: &quot; + mergedString);</span><br><span class="line">      List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);</span><br><span class="line">        </span><br><span class="line">      // 获取列表元素平方数</span><br><span class="line">      List&lt;Integer&gt; squaresList = getSquares(numbers);</span><br><span class="line">      System.out.println(&quot;平方数列表: &quot; + squaresList);</span><br><span class="line">      List&lt;Integer&gt; integers = Arrays.asList(1,2,13,4,15,6,17,8,19);</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;列表: &quot; +integers);</span><br><span class="line">      System.out.println(&quot;列表中最大的数 : &quot; + getMax(integers));</span><br><span class="line">      System.out.println(&quot;列表中最小的数 : &quot; + getMin(integers));</span><br><span class="line">      System.out.println(&quot;所有数之和 : &quot; + getSum(integers));</span><br><span class="line">      System.out.println(&quot;平均数 : &quot; + getAverage(integers));</span><br><span class="line">      System.out.println(&quot;随机数: &quot;);</span><br><span class="line">        </span><br><span class="line">      // 输出10个随机数</span><br><span class="line">      Random random = new Random();</span><br><span class="line">        </span><br><span class="line">      for(int i=0; i &lt; 10; i++)&#123;</span><br><span class="line">         System.out.println(random.nextInt());</span><br><span class="line">      &#125;</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;使用 Java 8: &quot;);</span><br><span class="line">      System.out.println(&quot;列表: &quot; +strings);</span><br><span class="line">        </span><br><span class="line">      count = strings.stream().filter(string-&gt;string.isEmpty()).count();</span><br><span class="line">      System.out.println(&quot;空字符串数量为: &quot; + count);</span><br><span class="line">        </span><br><span class="line">      count = strings.stream().filter(string -&gt; string.length() == 3).count();</span><br><span class="line">      System.out.println(&quot;字符串长度为 3 的数量为: &quot; + count);</span><br><span class="line">        </span><br><span class="line">      filtered = strings.stream().filter(string -&gt;!string.isEmpty()).collect(Collectors.toList());</span><br><span class="line">      System.out.println(&quot;筛选后的列表: &quot; + filtered);</span><br><span class="line">        </span><br><span class="line">      mergedString = strings.stream().filter(string -&gt;!string.isEmpty()).collect(Collectors.joining(&quot;, &quot;));</span><br><span class="line">      System.out.println(&quot;合并字符串: &quot; + mergedString);</span><br><span class="line">        </span><br><span class="line">      squaresList = numbers.stream().map( i -&gt;i*i).distinct().collect(Collectors.toList());</span><br><span class="line">      System.out.println(&quot;Squares List: &quot; + squaresList);</span><br><span class="line">      System.out.println(&quot;列表: &quot; +integers);</span><br><span class="line">        </span><br><span class="line">      IntSummaryStatistics stats = integers.stream().mapToInt((x) -&gt;x).summaryStatistics();</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;列表中最大的数 : &quot; + stats.getMax());</span><br><span class="line">      System.out.println(&quot;列表中最小的数 : &quot; + stats.getMin());</span><br><span class="line">      System.out.println(&quot;所有数之和 : &quot; + stats.getSum());</span><br><span class="line">      System.out.println(&quot;平均数 : &quot; + stats.getAverage());</span><br><span class="line">      System.out.println(&quot;随机数: &quot;);</span><br><span class="line">        </span><br><span class="line">      random.ints().limit(10).sorted().forEach(System.out::println);</span><br><span class="line">        </span><br><span class="line">      // 并行处理</span><br><span class="line">      count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span><br><span class="line">      System.out.println(&quot;空字符串的数量为: &quot; + count);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private static int getCountEmptyStringUsingJava7(List&lt;String&gt; strings)&#123;</span><br><span class="line">      int count = 0;</span><br><span class="line">        </span><br><span class="line">      for(String string: strings)&#123;</span><br><span class="line">        </span><br><span class="line">         if(string.isEmpty())&#123;</span><br><span class="line">            count++;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return count;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private static int getCountLength3UsingJava7(List&lt;String&gt; strings)&#123;</span><br><span class="line">      int count = 0;</span><br><span class="line">        </span><br><span class="line">      for(String string: strings)&#123;</span><br><span class="line">        </span><br><span class="line">         if(string.length() == 3)&#123;</span><br><span class="line">            count++;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return count;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private static List&lt;String&gt; deleteEmptyStringsUsingJava7(List&lt;String&gt; strings)&#123;</span><br><span class="line">      List&lt;String&gt; filteredList = new ArrayList&lt;String&gt;();</span><br><span class="line">        </span><br><span class="line">      for(String string: strings)&#123;</span><br><span class="line">        </span><br><span class="line">         if(!string.isEmpty())&#123;</span><br><span class="line">             filteredList.add(string);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return filteredList;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private static String getMergedStringUsingJava7(List&lt;String&gt; strings, String separator)&#123;</span><br><span class="line">      StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">        </span><br><span class="line">      for(String string: strings)&#123;</span><br><span class="line">        </span><br><span class="line">         if(!string.isEmpty())&#123;</span><br><span class="line">            stringBuilder.append(string);</span><br><span class="line">            stringBuilder.append(separator);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      String mergedString = stringBuilder.toString();</span><br><span class="line">      return mergedString.substring(0, mergedString.length()-2);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private static List&lt;Integer&gt; getSquares(List&lt;Integer&gt; numbers)&#123;</span><br><span class="line">      List&lt;Integer&gt; squaresList = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">      for(Integer number: numbers)&#123;</span><br><span class="line">         Integer square = new Integer(number.intValue() * number.intValue());</span><br><span class="line">            </span><br><span class="line">         if(!squaresList.contains(square))&#123;</span><br><span class="line">            squaresList.add(square);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return squaresList;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private static int getMax(List&lt;Integer&gt; numbers)&#123;</span><br><span class="line">      int max = numbers.get(0);</span><br><span class="line">        </span><br><span class="line">      for(int i=1;i &lt; numbers.size();i++)&#123;</span><br><span class="line">        </span><br><span class="line">         Integer number = numbers.get(i);</span><br><span class="line">            </span><br><span class="line">         if(number.intValue() &gt; max)&#123;</span><br><span class="line">            max = number.intValue();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return max;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private static int getMin(List&lt;Integer&gt; numbers)&#123;</span><br><span class="line">      int min = numbers.get(0);</span><br><span class="line">        </span><br><span class="line">      for(int i=1;i &lt; numbers.size();i++)&#123;</span><br><span class="line">         Integer number = numbers.get(i);</span><br><span class="line">        </span><br><span class="line">         if(number.intValue() &lt; min)&#123;</span><br><span class="line">            min = number.intValue();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return min;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private static int getSum(List numbers)&#123;</span><br><span class="line">      int sum = (int)(numbers.get(0));</span><br><span class="line">        </span><br><span class="line">      for(int i=1;i &lt; numbers.size();i++)&#123;</span><br><span class="line">         sum += (int)numbers.get(i);</span><br><span class="line">      &#125;</span><br><span class="line">      return sum;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private static int getAverage(List&lt;Integer&gt; numbers)&#123;</span><br><span class="line">      return getSum(numbers) / numbers.size();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以上脚本，输出结果为：   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">$ javac Java8Tester.java </span><br><span class="line">$ java Java8Tester</span><br><span class="line">使用 Java 7: </span><br><span class="line">列表: [abc, , bc, efg, abcd, , jkl]</span><br><span class="line">空字符数量为: 2</span><br><span class="line">字符串长度为 3 的数量为: 3</span><br><span class="line">筛选后的列表: [abc, bc, efg, abcd, jkl]</span><br><span class="line">合并字符串: abc, bc, efg, abcd, jkl</span><br><span class="line">平方数列表: [9, 4, 49, 25]</span><br><span class="line">列表: [1, 2, 13, 4, 15, 6, 17, 8, 19]</span><br><span class="line">列表中最大的数 : 19</span><br><span class="line">列表中最小的数 : 1</span><br><span class="line">所有数之和 : 85</span><br><span class="line">平均数 : 9</span><br><span class="line">随机数: </span><br><span class="line">-393170844</span><br><span class="line">-963842252</span><br><span class="line">447036679</span><br><span class="line">-1043163142</span><br><span class="line">-881079698</span><br><span class="line">221586850</span><br><span class="line">-1101570113</span><br><span class="line">576190039</span><br><span class="line">-1045184578</span><br><span class="line">1647841045</span><br><span class="line">使用 Java 8: </span><br><span class="line">列表: [abc, , bc, efg, abcd, , jkl]</span><br><span class="line">空字符串数量为: 2</span><br><span class="line">字符串长度为 3 的数量为: 3</span><br><span class="line">筛选后的列表: [abc, bc, efg, abcd, jkl]</span><br><span class="line">合并字符串: abc, bc, efg, abcd, jkl</span><br><span class="line">Squares List: [9, 4, 49, 25]</span><br><span class="line">列表: [1, 2, 13, 4, 15, 6, 17, 8, 19]</span><br><span class="line">列表中最大的数 : 19</span><br><span class="line">列表中最小的数 : 1</span><br><span class="line">所有数之和 : 85</span><br><span class="line">平均数 : 9.444444444444445</span><br><span class="line">随机数: </span><br><span class="line">-1743813696</span><br><span class="line">-1301974944</span><br><span class="line">-1299484995</span><br><span class="line">-779981186</span><br><span class="line">136544902</span><br><span class="line">555792023</span><br><span class="line">1243315896</span><br><span class="line">1264920849</span><br><span class="line">1472077135</span><br><span class="line">1706423674</span><br><span class="line">空字符串的数量为: 2</span><br></pre></td></tr></table></figure><h4 id="Optional-类"><a href="#Optional-类" class="headerlink" title="Optional 类"></a>Optional 类</h4><blockquote><p>Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。<br>Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。<br>Optional 类的引入很好的解决空指针异常。  </p></blockquote><ul><li>类声明   </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public final class Optional&lt;T&gt;</span><br><span class="line">extends Object</span><br></pre></td></tr></table></figure><ul><li>类方法  </li></ul><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">方法 &amp; 描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">static <t> Optional<t> empty() 返回空的 Optional 实例。</t></t></td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">boolean equals(Object obj) 判断其他对象是否等于 Optional。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">Optional<t> filter(Predicate&lt;? super <t> predicate)  如果值存在，并且这个值匹配给定的 predicate，返回一个Optional用以描述这个值，否则返回一个空的Optional。</t></t></td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><u> Optional<u> flatMap(Function&lt;? super T,Optional<u>&gt; mapper) 如果值存在，返回基于Optional包含的映射方法的值，否则返回一个空的Optional</u></u></u></td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">T get() 如果在这个Optional中包含这个值，返回值，否则抛出异常：NoSuchElementException</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">int hashCode() 返回存在值的哈希码，如果值不存在 返回 0。</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">void ifPresent(Consumer&lt;? super T&gt; consumer) 如果值存在则使用该值调用 consumer , 否则不做任何事情。</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left">boolean isPresent() 如果值存在则方法会返回true，否则返回 false。</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><u>Optional<u> map(Function&lt;? super T,? extends U&gt; mapper) 如果存在该值，提供的映射方法，如果返回非null，返回一个Optional描述结果。</u></u></td></tr><tr><td style="text-align:left">10</td><td style="text-align:left">static <t> Optional<t> of(T value) 返回一个指定非null值的Optional。</t></t></td></tr><tr><td style="text-align:left">11</td><td style="text-align:left">static <t> Optional<t> ofNullable(T value) 如果为非空，返回 Optional 描述的指定值，否则返回空的 Optional。</t></t></td></tr><tr><td style="text-align:left">12</td><td style="text-align:left">T orElse(T other) 如果存在该值，返回值， 否则返回 other。</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left">T orElseGet(Supplier&lt;? extends T&gt; other) 如果存在该值，返回值， 否则触发 other，并返回 other 调用的结果。</td></tr><tr><td style="text-align:left">14</td><td style="text-align:left"><x extends="" throwable=""> T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) 如果存在该值，返回包含的值，否则抛出由 Supplier 继承的异常。</x></td></tr><tr><td style="text-align:left">15</td><td style="text-align:left">String toString()  返回一个Optional的非空字符串，用来调试</td></tr></tbody></table><p><strong>注意：</strong> 这些方法是从 java.lang.Object 类继承来的。  </p><ul><li>Optional 实例    </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Optional;</span><br><span class="line"> </span><br><span class="line">public class Java8Tester &#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">   </span><br><span class="line">      Java8Tester java8Tester = new Java8Tester();</span><br><span class="line">      Integer value1 = null;</span><br><span class="line">      Integer value2 = new Integer(10);</span><br><span class="line">        </span><br><span class="line">      // Optional.ofNullable - 允许传递为 null 参数</span><br><span class="line">      Optional&lt;Integer&gt; a = Optional.ofNullable(value1);</span><br><span class="line">        </span><br><span class="line">      // Optional.of - 如果传递的参数是 null，抛出异常 NullPointerException</span><br><span class="line">      Optional&lt;Integer&gt; b = Optional.of(value2);</span><br><span class="line">      System.out.println(java8Tester.sum(a,b));</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   public Integer sum(Optional&lt;Integer&gt; a, Optional&lt;Integer&gt; b)&#123;</span><br><span class="line">    </span><br><span class="line">      // Optional.isPresent - 判断值是否存在</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;第一个参数值存在: &quot; + a.isPresent());</span><br><span class="line">      System.out.println(&quot;第二个参数值存在: &quot; + b.isPresent());</span><br><span class="line">        </span><br><span class="line">      // Optional.orElse - 如果值存在，返回它，否则返回默认值</span><br><span class="line">      Integer value1 = a.orElse(new Integer(0));</span><br><span class="line">        </span><br><span class="line">      //Optional.get - 获取值，值需要存在</span><br><span class="line">      Integer value2 = b.get();</span><br><span class="line">      return value1 + value2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以上脚本，输出结果为：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一个参数值存在: false</span><br><span class="line">第二个参数值存在: true</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h4 id="Nashorn-JavaScript"><a href="#Nashorn-JavaScript" class="headerlink" title="Nashorn JavaScript"></a>Nashorn JavaScript</h4><p>Nashorn 一个 javascript 引擎。<br>从JDK 1.8开始，Nashorn取代Rhino(JDK 1.6, JDK1.7)成为Java的嵌入式JavaScript引擎。Nashorn完全支持ECMAScript 5.1规范以及一些扩展。它使用基于JSR 292的新语言特性，其中包含在JDK 7中引入的 invokedynamic，将JavaScript编译成Java字节码。<br>与先前的Rhino实现相比，这带来了2到10倍的性能提升。  </p><h5 id="jjs"><a href="#jjs" class="headerlink" title="jjs"></a>jjs</h5><p>jjs是个基于Nashorn引擎的命令行工具。它接受一些JavaScript源代码为参数，并且执行这些源代码。<br>例如，我们创建一个具有如下内容的example.js文件：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;Ping Pong&apos;)</span><br></pre></td></tr></table></figure><p>打开控制台，输入以下命令：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jjs example.js</span><br></pre></td></tr></table></figure><p>以上程序输出结果为：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ping Pong!</span><br></pre></td></tr></table></figure><h5 id="jjs交互式编程"><a href="#jjs交互式编程" class="headerlink" title="jjs交互式编程"></a>jjs交互式编程</h5><p>打开控制台，输入以下命令：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ jjs</span><br><span class="line">jjs&gt; print(&quot;Ping, Pong!&quot;)</span><br><span class="line">Ping, Pong!</span><br><span class="line">jjs&gt; quit()</span><br><span class="line">&gt;&gt;</span><br></pre></td></tr></table></figure><h5 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h5><p>打开控制台，输入以下命令：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jjs -- h i j k</span><br><span class="line">jjs&gt; print(&apos;字符：&apos; + arguments.join(&quot;,&quot;))</span><br><span class="line">字符：h,i,j,k</span><br></pre></td></tr></table></figure><h5 id="java中调用JavaScript"><a href="#java中调用JavaScript" class="headerlink" title="java中调用JavaScript"></a>java中调用JavaScript</h5><p>使用ScriptEngineManager，JavaScript代码可以在Java中执行，实例如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Jdk8Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ScriptEngineManager scriptEngineManager = new ScriptEngineManager();</span><br><span class="line">        ScriptEngine nashorn = scriptEngineManager.getEngineByName(&quot;nashorn&quot;);</span><br><span class="line"></span><br><span class="line">        String name = &quot;Nashorn&quot;;</span><br><span class="line">        Integer result = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            nashorn.eval(&quot;print(&apos;&quot; + name + &quot;&apos;)&quot;);</span><br><span class="line">            result = (Integer) nashorn.eval(&quot;6 + 2&quot;);</span><br><span class="line">        &#125; catch (ScriptException e) &#123;</span><br><span class="line">            System.out.println(&quot;js脚本执行异常：&quot; + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行脚本输出如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Nashorn</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h5 id="JavaScript中调用Java"><a href="#JavaScript中调用Java" class="headerlink" title="JavaScript中调用Java"></a>JavaScript中调用Java</h5><p>实例如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var BigDecimal = Java.type(&apos;java.math.BigDecimal&apos;);</span><br><span class="line"></span><br><span class="line">function calculate(amount, percentage) &#123;</span><br><span class="line">   var result = new BigDecimal(amount).multiply(</span><br><span class="line">   new BigDecimal(percentage)).divide(new BigDecimal(&quot;100&quot;), 2, BigDecimal.ROUND_HALF_EVEN);</span><br><span class="line">   return result.toPlainString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result = calculate(10086000000001,15.8);</span><br><span class="line">print(result);</span><br></pre></td></tr></table></figure><p>执行如上输出：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ jjs example.js</span><br><span class="line">1593588000000.16</span><br></pre></td></tr></table></figure><h4 id="日期时间-API"><a href="#日期时间-API" class="headerlink" title="日期时间 API"></a>日期时间 API</h4><p> Java 8通过发布新的Date-Time API (JSR 310)来进一步加强对日期与时间的处理。<br> 旧版时间API存在的问题主要有：  </p><ul><li><strong>非线程安全&gt; </strong> java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一。    </li><li><strong>设计很差&gt; </strong>Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计。  </li><li><p><strong>时区处理麻烦&gt; </strong>日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有的问题。  </p><p>Java8在java.time包下提供了很多新的API。以下为两个重要的比较：  </p></li><li><strong>Local(本地)&gt; </strong>简化了日期时间的处理，没有时区的问题。  </li><li><p><strong>Zoned(时区)&gt; </strong>通过制定的时区处理日期时间。  </p><p>新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。  </p><h5 id="本地化日期时间-API"><a href="#本地化日期时间-API" class="headerlink" title="本地化日期时间 API"></a>本地化日期时间 API</h5><p>LocalDate/LocalTime 和 LocalDateTime 类可以在处理时区不是必须的情况。代码如下：   </p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class Jdk8Demo &#123;</span><br><span class="line">     public static void main(String args[])&#123;</span><br><span class="line">         Jdk8Demo jdk8Demo = new Jdk8Demo();</span><br><span class="line">         jdk8Demo.testLocalDateTime();</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     public void testLocalDateTime()&#123;</span><br><span class="line"> </span><br><span class="line">         // 获取当前的日期时间</span><br><span class="line">         LocalDateTime currentTime = LocalDateTime.now();</span><br><span class="line">         System.out.println(&quot;当前时间: &quot; + currentTime);</span><br><span class="line"> </span><br><span class="line">         LocalDate date1 = currentTime.toLocalDate();</span><br><span class="line">         System.out.println(&quot;当前日期: &quot; + date1);</span><br><span class="line"> </span><br><span class="line">         Month month = currentTime.getMonth();</span><br><span class="line">         int day = currentTime.getDayOfMonth();</span><br><span class="line">         int seconds = currentTime.getSecond();</span><br><span class="line"> </span><br><span class="line">         System.out.println(&quot;月: &quot; + month.getValue() +&quot;, 日: &quot; + day +&quot;, 秒: &quot; + seconds);</span><br><span class="line"> </span><br><span class="line">         //修改当前时间 设置年月日</span><br><span class="line">         LocalDateTime date2 = currentTime.withDayOfMonth(10).withYear(2012).withMonth(10);</span><br><span class="line">         System.out.println(&quot;当前时间设置后: &quot; + date2);</span><br><span class="line"> </span><br><span class="line">         // 修改当前时间 设置年月日</span><br><span class="line">         LocalDate date3 = LocalDate.of(2014, Month.DECEMBER, 12);</span><br><span class="line">         System.out.println(&quot;当前时间设置后1: &quot; + date3);</span><br><span class="line"> </span><br><span class="line">         // 修改当前时间 设置时分</span><br><span class="line">         LocalTime date4 = LocalTime.of(22, 15);</span><br><span class="line">         System.out.println(&quot;当前时间设置后2: &quot; + date4);</span><br><span class="line"> </span><br><span class="line">         // 解析字符串</span><br><span class="line">         LocalTime date5 = LocalTime.parse(&quot;20:15:30&quot;);</span><br><span class="line">         System.out.println(&quot;解析字符时间为日期对象: &quot; + date5);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>以上执行输出：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当前时间: 2018-09-27T16:22:35.565</span><br><span class="line">当前日期: 2018-09-27</span><br><span class="line">月: 9, 日: 27, 秒: 35</span><br><span class="line">当前时间设置后: 2012-10-10T16:22:35.565</span><br><span class="line">当前时间设置后1: 2014-12-12</span><br><span class="line">当前时间设置后2: 22:15</span><br><span class="line">解析字符时间为日期对象: 20:15:30</span><br></pre></td></tr></table></figure><h5 id="使用时区的日期时间API"><a href="#使用时区的日期时间API" class="headerlink" title="使用时区的日期时间API"></a>使用时区的日期时间API</h5><p>如果我们需要考虑到时区，就可以使用时区的日期时间API：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Jdk8Demo &#123;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        Jdk8Demo jdk8Demo = new Jdk8Demo();</span><br><span class="line">        jdk8Demo.testZonedDateTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void testZonedDateTime()&#123;</span><br><span class="line"></span><br><span class="line">        // 解析字符串时间</span><br><span class="line">        ZonedDateTime date1 = ZonedDateTime.parse(&quot;2015-12-03T10:15:30+05:30[Asia/Shanghai]&quot;);</span><br><span class="line">        System.out.println(&quot;解析字符串时间: &quot; + date1);</span><br><span class="line"></span><br><span class="line">        //设置zoneid</span><br><span class="line">        ZoneId id = ZoneId.of(&quot;Europe/Paris&quot;);</span><br><span class="line">        System.out.println(&quot;输出zoneid: &quot; + id);</span><br><span class="line"></span><br><span class="line">        ZoneId currentZone = ZoneId.systemDefault();</span><br><span class="line">        System.out.println(&quot;默认当期时区: &quot; + currentZone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上执行输出：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解析字符串时间: 2015-12-03T10:15:30+08:00[Asia/Shanghai]</span><br><span class="line">输出zoneid: Europe/Paris</span><br><span class="line">默认当期时区: Asia/Shanghai</span><br></pre></td></tr></table></figure><h4 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h4><p>在Java8中，Base64编码已经成为Java类库的标准。<br>Java8内置了Base64编码的编码器和解码器。<br>Base64工具类提供了一套静态方法获取下面三种BASE64编解码器：  </p><ul><li><strong>基本：</strong> 输出被映射到一组字符A-Za-z0-9+/，编码不添加任何行标，输出的解码仅支持A-Za-z0-9+/  </li><li><strong>URL：</strong> 输出映射到一组字符A-Za-z0-9+_，输出是URL和文件。  </li><li><strong>MIME：</strong> 输出映射到MIME友好格式。输出每行不超过76字符，并且使用’\r’并跟随’\n’作为分割。编码输出最后没有行分割。  </li></ul><h5 id="内嵌类"><a href="#内嵌类" class="headerlink" title="内嵌类"></a>内嵌类</h5><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">内嵌类 &amp; 描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">static class Base64.Decoder 该类实现一个解码器用于，使用 Base64 编码来解码字节数据。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">static class Base64.Encoder 该类实现一个编码器，使用 Base64 编码来编码字节数据。</td></tr></tbody></table><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">方法 &amp; 描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">static Base64.Decoder getDecoder() 返回一个 Base64.Decoder ，解码使用基本型 base64 编码方案。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">static Base64.Encoder getEncoder() 返回一个 Base64.Encoder ，编码使用基本型 base64 编码方案。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">static Base64.Decoder getMimeDecoder() 返回一个 Base64.Decoder ，解码使用 MIME 型 base64 编码方案。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">static Base64.Encoder getMimeEncoder() 返回一个 Base64.Encoder ，编码使用 MIME 型 base64 编码方案。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">static Base64.Encoder getMimeEncoder(int lineLength, byte[] lineSeparator) 返回一个 Base64.Encoder ，编码使用 MIME 型 base64 编码方案，可以通过参数指定每行的长度及行的分隔符。</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">static Base64.Decoder getUrlDecoder() 返回一个 Base64.Decoder ，解码使用 URL 和文件名安全型 base64 编码方案。</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">static Base64.Encoder getUrlEncoder() 返回一个 Base64.Encoder ，编码使用 URL 和文件名安全型 base64 编码方案。</td></tr></tbody></table><blockquote><p>注意：Base64 类的很多方法从 java.lang.Object 类继承。  </p></blockquote><h5 id="Base64-实例"><a href="#Base64-实例" class="headerlink" title="Base64 实例"></a>Base64 实例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Jdk8Demo &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Jdk8Demo jdk8Demo = new Jdk8Demo();</span><br><span class="line">        jdk8Demo.testBase64();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void testBase64() &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">            // 基本编码</span><br><span class="line">            String base64encodedString = Base64.getEncoder().encodeToString(&quot;this 是 java8&quot;.getBytes(&quot;utf-8&quot;));</span><br><span class="line">            System.out.println(&quot;Base64字符串 (基本) :&quot; + base64encodedString);</span><br><span class="line"></span><br><span class="line">            // 解码</span><br><span class="line">            byte[] base64decodedBytes = Base64.getDecoder().decode(base64encodedString);</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;原始字符串: &quot; + new String(base64decodedBytes, &quot;utf-8&quot;));</span><br><span class="line">            base64encodedString = Base64.getUrlEncoder().encodeToString(&quot;url编码 &quot;.getBytes(&quot;utf-8&quot;));</span><br><span class="line">            System.out.println(&quot;Base64 编码字符串 (URL) :&quot; + base64encodedString);</span><br><span class="line"></span><br><span class="line">            StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">                stringBuilder.append(UUID.randomUUID().toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            byte[] mimeBytes = stringBuilder.toString().getBytes(&quot;utf-8&quot;);</span><br><span class="line">            String mimeEncodedString = Base64.getMimeEncoder().encodeToString(mimeBytes);</span><br><span class="line">            System.out.println(&quot;Base64 编码字符串 (MIME) :&quot; + mimeEncodedString);</span><br><span class="line"></span><br><span class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">            System.out.println(&quot;Error :&quot; + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Base64字符串 (基本) :dGhpcyDmmK8gamF2YTg=</span><br><span class="line">原始字符串: this 是 java8</span><br><span class="line">Base64 编码字符串 (URL) :dXJs57yW56CBIA==</span><br><span class="line">Base64 编码字符串 (MIME) :YTgxZDgxOTAtZTM3ZS00ODQ1LTk0YjEtOGI4MWViY2VlNmZmZmFhNTdiMTItZTI0NS00ZTJhLWIx</span><br><span class="line">OTQtNGQ4OTFmNTc4MjFiNmU1MGZlNjYtYzhmZS00OWIzLWIzMzItNzA4YWU0NTdhNDQ2MGZjNDg2</span><br><span class="line">NzYtNjc2ZS00M2Y0LWIwNjgtYWQ1ZTA5NTYzNWVlNjZmNTRkZjgtNDljNi00MmVlLTllMjUtZjRl</span><br><span class="line">ZjM3ZjQ3NDk0YjAwMjJhOGYtYjJkMC00MzNhLWEyNDktZGFhNTFiMzMwMTAyYWY1OGEwZmMtZDQ5</span><br><span class="line">MC00ZjUyLWFlYzYtNzk2OTNkZDUwMWEzYzk3OTI2NDUtN2Q5Ni00ZTEzLWFiZWUtNzFlNDMxNTY3</span><br><span class="line">Nzg2YjE2NTU3OTAtMGViOS00YmM4LTg1NjAtYzcxMmNmMDk0NTgxNjdiN2JkMzUtNDVjZS00MjZk</span><br><span class="line">LTgzZTktNmQ3ZGM5YzQ1Njk1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;毫无疑问，Java 8是Java自Java 5（发布于2004年）之后的最重要的版本。这个版本包含语言、编译器、库、工具和JVM等方面的十多个新特性。&lt;br&gt;
    
    </summary>
    
    
      <category term="jdk" scheme="https://dongme.site/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>jdk新特性之jdk7</title>
    <link href="https://dongme.site/2018/09/26/jdk%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8Bjdk7/"/>
    <id>https://dongme.site/2018/09/26/jdk新特性之jdk7/</id>
    <published>2018-09-26T09:07:00.000Z</published>
    <updated>2018-10-15T15:39:24.390Z</updated>
    
    <content type="html"><![CDATA[<p>jdk7新特性主要有switch中可以使用字串、泛型实例化类型自动推断、资源自动关闭、新增一些取环境信息的工具方法、Boolean类型反转，空指针安全，参与位运算、字符之间可以使用equals、安全的加减乘除、对Java集合（Collections）的增强支持、数值文本、支持二进制文字、在try catch异常扑捉中，一个catch可以写多个异常类型，用”|”隔开。<br><a id="more"></a>  </p><h4 id="jdk7新特性"><a href="#jdk7新特性" class="headerlink" title="jdk7新特性"></a>jdk7新特性</h4><hr><h5 id="switch中可以使用字串"><a href="#switch中可以使用字串" class="headerlink" title="switch中可以使用字串"></a>switch中可以使用字串</h5> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;a&quot;;</span><br><span class="line">switch (s) &#123;</span><br><span class="line">case &quot;a&quot; :</span><br><span class="line">System.out.println(&quot;a&quot;);</span><br><span class="line">break;</span><br><span class="line">case &quot;b&quot; :</span><br><span class="line">System.out.println(&quot;b&quot;);</span><br><span class="line">break;</span><br><span class="line">default :</span><br><span class="line">System.out.println(&quot;default&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="泛型实例化类型自动推断"><a href="#泛型实例化类型自动推断" class="headerlink" title="泛型实例化类型自动推断"></a>泛型实例化类型自动推断</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// java 7前，前后&lt;&gt;都必须声明类型</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">//java 7 &lt;&gt;不须声明类型，自动根据前面&lt;&gt;推断其类型</span><br><span class="line">List&lt;String&gt; list1 = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><h5 id="资源自动关闭"><a href="#资源自动关闭" class="headerlink" title="资源自动关闭"></a>资源自动关闭</h5><p>在Java中，有许多的资源在使用完成之后需要对其进行关闭操作。举个栗子，InputStream，Writer，Sockets，Connection等等。在Java 7 之前通常都是显示调用其close()方法，在Java 7，你可以不用理会其是否未关闭，我们可以使用try-with-resources代码块。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceCloseTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * java 7以前版本，关闭资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">oldCloseResource</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(path));</span><br><span class="line">            <span class="keyword">return</span> br.readLine();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"BufferedReader Exception"</span> + e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (br != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                    <span class="comment">//br.ready();//资源关闭后，访问资源抛出异常</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.err.println(<span class="string">"BufferedReader close Exception"</span> + e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * java 7版本关闭资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">newCloseResource</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 当try语句块运行结束时，FileInputStream 会被自动关闭。这是因为FileInputStream 实现了java中的java.lang.AutoCloseable接口。</span></span><br><span class="line"><span class="comment">         * 所有实现了这个接口的类都可以在try-with-resources结构中使用。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(path))) &#123;<span class="comment">//try()中可以定义多个资源</span></span><br><span class="line">            <span class="keyword">return</span> br.readLine();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"BufferedReader Exception"</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        oldCloseResource(<span class="string">"C:\\Users\\alvin\\Desktop\\a.txt"</span>);</span><br><span class="line">        newCloseResource(<span class="string">"C:\\Users\\alvin\\Desktop\\a.txt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="新增一些取环境信息的工具方法"><a href="#新增一些取环境信息的工具方法" class="headerlink" title="新增一些取环境信息的工具方法"></a>新增一些取环境信息的工具方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">File System.getUserHomeDir() // 当前用户目录</span><br><span class="line">File System.getUserDir() // 启动java进程时所在的目录</span><br><span class="line">File System.getJavaIoTempDir() // io临时文件夹</span><br><span class="line">File System.getJavaHomeDir() // jre的安装目录</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><h5 id="Boolean类型反转，空指针安全，参与位运算"><a href="#Boolean类型反转，空指针安全，参与位运算" class="headerlink" title="Boolean类型反转，空指针安全，参与位运算"></a>Boolean类型反转，空指针安全，参与位运算</h5><p>在java8中找不到Booleans这个类，是废弃了吗？  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Boolean Booleans.negate(Boolean booleanObj)</span><br><span class="line">True =&gt; False , False =&gt; True, Null =&gt; Null</span><br><span class="line">boolean Booleans.and(boolean[] array)</span><br><span class="line">boolean Booleans.or(boolean[] array)</span><br><span class="line">boolean Booleans.xor(boolean[] array)</span><br><span class="line">boolean Booleans.and(Boolean[] array)</span><br><span class="line">boolean Booleans.or(Boolean[] array)</span><br><span class="line">boolean Booleans.xor(Boolean[] array)</span><br></pre></td></tr></table></figure><h5 id="字符之间可以使用equals"><a href="#字符之间可以使用equals" class="headerlink" title="字符之间可以使用equals"></a>字符之间可以使用equals</h5><p>在java8中不管用呢，是废弃了吗？   </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean Character.equalsIgnoreCase(char ch1, char ch2)</span><br></pre></td></tr></table></figure><h5 id="安全的加减乘除"><a href="#安全的加减乘除" class="headerlink" title="安全的加减乘除"></a>安全的加减乘除</h5><p>在java8中不管用呢，是废弃了吗？  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int Math.safeToInt(long value)</span><br><span class="line">int Math.safeNegate(int value)</span><br><span class="line">long Math.safeSubtract(long value1, int value2)</span><br><span class="line">long Math.safeSubtract(long value1, long value2)</span><br><span class="line">int Math.safeMultiply(int value1, int value2)</span><br><span class="line">long Math.safeMultiply(long value1, int value2)</span><br><span class="line">long Math.safeMultiply(long value1, long value2)</span><br><span class="line">long Math.safeNegate(long value)</span><br><span class="line">int Math.safeAdd(int value1, int value2)</span><br><span class="line">long Math.safeAdd(long value1, int value2)</span><br><span class="line">long Math.safeAdd(long value1, long value2)</span><br><span class="line">int Math.safeSubtract(int value1, int value2)</span><br></pre></td></tr></table></figure><h5 id="对Java集合（Collections）的增强支持"><a href="#对Java集合（Collections）的增强支持" class="headerlink" title="对Java集合（Collections）的增强支持"></a>对Java集合（Collections）的增强支持</h5><p>jdk7以前：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//创建List接口对象</span><br><span class="line">List&lt;String&gt; list=new ArrayList&lt;String&gt;();</span><br><span class="line">list.add(&quot;item1&quot;); //用add()方法获取对象</span><br><span class="line">String Item=list.get(0); //用get()方法获取对象</span><br><span class="line"></span><br><span class="line">//创建Set接口对象</span><br><span class="line">Set&lt;String&gt; set=new HashSet&lt;String&gt;();</span><br><span class="line">set.add(&quot;item1&quot;); //用add()方法添加对象</span><br><span class="line"></span><br><span class="line">//创建Map接口对象</span><br><span class="line">Map&lt;String,String&gt; map=new HashMap&lt;String,String&gt;();</span><br><span class="line">map.put(&quot;key1&quot;, &quot;value1&quot;); //用put()方法添加对象</span><br><span class="line">String value=map.get(&quot;key1&quot;);</span><br></pre></td></tr></table></figure><p>jdk7：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list=[&quot;item1&quot;]; //向List集合中添加元素</span><br><span class="line">String item=list[0]; //从List集合中获取元素</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; set=&#123;&quot;item1&quot;&#125;; //向Set集合对象中添加元素</span><br><span class="line">Map&lt;String,String&gt; map=&#123;&quot;key1&quot;:&quot;value1&quot;&#125;; //向Map集合中添加对象</span><br><span class="line">String value=map[&quot;key1&quot;]; //从Map集合中获取对象</span><br></pre></td></tr></table></figure><p>but：在java8不管用呢。。。  </p><h5 id="数值文本"><a href="#数值文本" class="headerlink" title="数值文本"></a>数值文本</h5><p>未方便数0。。。，支持下划线划分。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如：int twoMillion = 2_000_000;</span><br><span class="line">或  </span><br><span class="line">int twoMillion = 200_0000;</span><br></pre></td></tr></table></figure></p><h5 id="支持二进制文字"><a href="#支持二进制文字" class="headerlink" title="支持二进制文字"></a>支持二进制文字</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例如：int binary = 0b1001_1001;</span><br><span class="line">//下划线可以划在ob1之后到0b10011001之前任何位置</span><br></pre></td></tr></table></figure><h5 id="在try-catch异常扑捉中，一个catch可以写多个异常类型，用”-”隔开"><a href="#在try-catch异常扑捉中，一个catch可以写多个异常类型，用”-”隔开" class="headerlink" title="在try catch异常扑捉中，一个catch可以写多个异常类型，用”|”隔开"></a>在try catch异常扑捉中，一个catch可以写多个异常类型，用”|”隔开</h5><p>jdk7之前：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   ......</span><br><span class="line">&#125; <span class="keyword">catch</span>(ClassNotFoundException ex) &#123;</span><br><span class="line">   ex.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span>(SQLException ex) &#123;</span><br><span class="line">   ex.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk7：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   ......</span><br><span class="line">&#125; <span class="keyword">catch</span>(ClassNotFoundException|SQLException ex) &#123;</span><br><span class="line">   ex.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jdk7新特性主要有switch中可以使用字串、泛型实例化类型自动推断、资源自动关闭、新增一些取环境信息的工具方法、Boolean类型反转，空指针安全，参与位运算、字符之间可以使用equals、安全的加减乘除、对Java集合（Collections）的增强支持、数值文本、支持二进制文字、在try catch异常扑捉中，一个catch可以写多个异常类型，用”|”隔开。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://dongme.site/categories/java/"/>
    
    
      <category term="jdk" scheme="https://dongme.site/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>jdk新特性之jdk6</title>
    <link href="https://dongme.site/2018/09/26/jdk%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8Bjdk6/"/>
    <id>https://dongme.site/2018/09/26/jdk新特性之jdk6/</id>
    <published>2018-09-26T08:53:00.000Z</published>
    <updated>2018-10-15T14:25:23.106Z</updated>
    
    <content type="html"><![CDATA[<p>jdk6新特性主要体现在如下模块：Desktop类和SystemTray类、使用JAXB2来实现对象与XML之间的映射、StAX、使用Compiler API、轻量级Http Server API、插入式注解处理API(Pluggable Annotation Processing API)、用Console开发控制台程序、对脚本语言的支持、Common Annotations及其它一些小改动。<br><a id="more"></a>  </p><h4 id="jdk6新特性"><a href="#jdk6新特性" class="headerlink" title="jdk6新特性"></a>jdk6新特性</h4><hr><h5 id="Desktop类和SystemTray类"><a href="#Desktop类和SystemTray类" class="headerlink" title="Desktop类和SystemTray类"></a>Desktop类和SystemTray类</h5><p>AWT新增加了两个类：Desktop和SystemTray<br>Desktop可以用来打开系统默认浏览器浏览指定的URL，打开系统默认邮件客户端给指定的邮箱发邮件，用默认应用程序打开或编辑文件，<br>用系统默认的打印机打印文档。<br>SystemTray可以在系统托盘区创建一个托盘程序。  </p><h5 id="使用JAXB2来实现对象与XML之间的映射"><a href="#使用JAXB2来实现对象与XML之间的映射" class="headerlink" title="使用JAXB2来实现对象与XML之间的映射"></a>使用JAXB2来实现对象与XML之间的映射</h5><p>JAXB是Java Architecture for XML Binding的缩写，可以将一个Java对象转变成为XML格式，反之亦然。<br>我们把对象与关系数据库之间的映射称为ORM，其实也可以把对象与XML之间的映射称为OXM（Object XML Mapping）。原来JAXB是Java EE<br>的一部分，在JDK1.6中，SUN将其放到了Java SE中，这也是SUN的一贯做法。JDK1.6中自带的这个JAXB版本是2.0，比起1.0来，JAXB2用JDK5<br>的新特性Annotation来标识要作绑定的类和属性，这就极大简化了开发的工作量。<br>实际上，在Java EE 5.0中，EJB和Web Services也通过Annotation来简化开发工作。另外，JAXB2在底层是用StAX(JSR 173)来处理XML文档。<br>除了JAXB之外，我们还可以通过XMLBeans和Castor等来实现同样的功能。  </p><h5 id="StAX"><a href="#StAX" class="headerlink" title="StAX"></a>StAX</h5><p>StAX(JSR 173)是JDK1.6.0中除了DOM和SAX之外的又一种处理XML文档的API。<br>StAX 的来历：在JAXP1.3(JSR 206)有两种处理XML文档的方法：DOM(Document Object Model)和SAX(Simple API for XML)。<br>由于JDK1.6.0中的JAXB2(JSR 222)和JAX-WS 2.0(JSR 224)都会用到StAX所以Sun决定把StAX加入到JAXP家族当中来，并将JAXP的版本升级到1.4(JAXP1.4是JAXP1.3的维护版本)。JDK1.6里面JAXP的版本就是1.4。<br>StAX是The Streaming API for XML的缩写，一种利用拉模式解析(pull-parsing)XML文档的API。StAX通过提供一种基于事件迭代器(Iterator)的API让程序员去控制xml文档解析过程，程序遍历这个事件迭代器去处理每一个解析事件，解析事件可以看做是程序拉出来的，也就是程序促使解析器产生一个解析事件然后处理该事件，之后又促使解析器产生下一个解析事件，如此循环直到碰到文档结束符；<br>SAX也是基于事件处理xml文档，但却是用推模式解析，解析器解析完整个xml文档后，才产生解析事件，然后推给程序去处理这些事件；DOM采用的方式是将整个xml文档映射到一颗内存树，这样就可以很容易地得到父节点和子结点以及兄弟节点的数据，但如果文档很大，将会严重影响性能。  </p><h5 id="使用Compiler-API"><a href="#使用Compiler-API" class="headerlink" title="使用Compiler API"></a>使用Compiler API</h5><p>现在我 们可以用JDK1.6 的Compiler API(JSR 199)去动态编译Java源文件，Compiler API结合反射功能就可以实现动态的产生Java代码并编译执行这些代码，有点动态语言的特征。<br>这个特性对于某些需要用到动态编译的应用程序相当有用，比如JSP Web Server，当我们手动修改JSP后，是不希望需要重启Web Server才可以看到效果的，这时候我们就可以用Compiler API来实现动态编译JSP文件，当然，现在的JSP Web Server也是支持JSP热部署的，现在的JSP Web Server通过在运行期间通过Runtime.exec或ProcessBuilder来调用javac来编译代码，这种方式需要我们产生另一个进程去做编译工作，不够优雅而且容易使代码依赖与特定的操作系统；Compiler API通过一套易用的标准的API提供了更加丰富的方式去做动态编译，而且是跨平台的。  </p><h5 id="轻量级Http-Server-API"><a href="#轻量级Http-Server-API" class="headerlink" title="轻量级Http Server API"></a>轻量级Http Server API</h5><p>JDK1.6 提供了一个简单的Http Server API，据此我们可以构建自己的嵌入式Http Server，它支持Http和Https协议，提供了HTTP1.1的部分实现，没有被实现的那部分可以通过扩展已有的Http Server API来实现，程序员必须自己实现HttpHandler接口，HttpServer会调用HttpHandler实现类的回调方法来处理客户端请求，在这里，我们把一个Http请求和它的响应称为一个交换，包装成HttpExchange类，HttpServer负责将HttpExchange传给HttpHandler实现类的回调方法。  </p><h5 id="插入式注解处理API-Pluggable-Annotation-Processing-API"><a href="#插入式注解处理API-Pluggable-Annotation-Processing-API" class="headerlink" title="插入式注解处理API(Pluggable Annotation Processing API)"></a>插入式注解处理API(Pluggable Annotation Processing API)</h5><p>插入式注解处理API(JSR 269)提供一套标准API来处理Annotations(JSR 175)。<br>实际上JSR 269不仅仅用来处理Annotation，我觉得更强大的功能是它建立了Java语言本身的一个模型，它把method，package，constructor，type，variable， enum，annotation等Java语言元素映射为Types和Elements(两者有什么区别?)，从而将Java语言的语义映射成为对象，我们可以在javax.lang.model包下面可以看到这些类。 所以我们可以利用JSR 269提供的API来构建一个功能丰富的元编程(metaprogramming)环境。<br>JSR 269用Annotation Processor在编译期间而不是运行期间处理Annotation，Annotation Processor相当于编译器的一个插件，所以称为插入式注解处理.如果Annotation Processor处理Annotation时(执行process方法)产生了新的Java代码，编译器会再调用一次Annotation Processor，如果第二次处理还有新代码产生，就会接着调用Annotation Processor，直到没有新代码产生为止.每执行一次process()方法被称为一个”round”，这样整个Annotation processing过程可以看作是一个round的序列。<br>JSR 269主要被设计成为针对Tools或者容器的API. 举个例子，我们想建立一套基于Annotation的单元测试框架(如TestNG)，在测试类里面用Annotation来标识测试期间需要执行的测试方法。  </p><h5 id="用Console开发控制台程序"><a href="#用Console开发控制台程序" class="headerlink" title="用Console开发控制台程序"></a>用Console开发控制台程序</h5><p>JDK1.6中提供了java.io.Console 类专用来访问基于字符的控制台设备。你的程序如果要与Windows下的cmd或者Linux下的Terminal交互，就可以用Console类代劳。但我们不总是能得到可用的Console，一个JVM是否有可用的Console依赖于底层平台和JVM如何被调用。如果JVM是在交互式命令行(比如Windows的cmd)中启动的，并且输入输出没有重定向到另外的地方，那么就可以得到一个可用的Console实例。  </p><h5 id="对脚本语言的支持"><a href="#对脚本语言的支持" class="headerlink" title="对脚本语言的支持"></a>对脚本语言的支持</h5><p>如：ruby，groovy，javascript。  </p><h5 id="Common-Annotations"><a href="#Common-Annotations" class="headerlink" title="Common Annotations"></a>Common Annotations</h5><p>Common annotations原本是Java EE 5.0(JSR 244)规范的一部分，现在SUN把它的一部分放到了Java SE 6.0中。<br>随着Annotation元数据功能(JSR 175)加入到Java SE 5.0里面，很多Java 技术(比如EJB，Web Services)都会用Annotation部分代替XML文件来配置运行参数（或者说是支持声明式编程,如EJB的声明式事务），如果这些技术为通用目的都单独定义了自己的Annotations,显然有点重复建设, 所以,为其他相关的Java技术定义一套公共的Annotation是有价值的，可以避免重复建设的同时，也保证Java SE和Java EE 各种技术的一致性。  </p><h5 id="有一些小的改动"><a href="#有一些小的改动" class="headerlink" title="有一些小的改动"></a>有一些小的改动</h5><p><strong>如下方法获取磁盘使用信息：</strong><br>getTotalSpace() - 返回此抽象路径名指定的分区大小。以字节为单位。  getFreeSpace() - 返回此抽象路径名指定的分区中未分配的字节数。<br>getUsableSpace() - 返回此抽象路径名指定的分区上可用于此虚拟机的字节数。若有可能，此方法将检查写权限和其他操作系统限制，因此与 getFreeSpace() 相比，此方法能更准确地估计可实际写入的新数据数。 </p><p><strong>如下方法获取文件权限：</strong><br>setWritable(boolean writable, boolean ownerOnly) 和 setWritable(boolean writable) - 设置此抽象路径名的所有者或所有用户的写权限。<br>setReadable(boolean readable, boolean ownerOnly) 和 setReadable(boolean readable) - 设置此抽象路径名的所有者或所有用户的读权限。<br>setExecutable(boolean executable, boolean ownerOnly) 和 setExecutable(boolean executable) - 设置此抽象路径名的所有者或所有用户的执行权限。<br>canExecute() - 测试应用程序是否可以执行此抽象路径名表示的文件。 </p><p><strong>IOException类增加构造函数</strong><br>IOException支持异常链通过新的构造函数：IOException(String, Throwable) 和IOException(Throwable)。<br>File.isFile()方法的行为发生变化。<br>Windows环境下对保留设备名如： CON, NUL, AUX, LPT, 等等，永远返回false。  </p><p><strong>java GUI界面的显示的改动</strong><br>JDK6.0（也就是JDK1.6）支持最新的windows vista系统的Windows Aero视窗效果，而JDK1.5不支持。<br>你要在vista环境下编程的话最好装jdk6.0，否则它总是换到windows basic视窗效果。  </p><p><strong>java.nio模块，增加java.nio.channels.SelectorProvider实现类等</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jdk6新特性主要体现在如下模块：Desktop类和SystemTray类、使用JAXB2来实现对象与XML之间的映射、StAX、使用Compiler API、轻量级Http Server API、插入式注解处理API(Pluggable Annotation Processing API)、用Console开发控制台程序、对脚本语言的支持、Common Annotations及其它一些小改动。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://dongme.site/categories/java/"/>
    
    
      <category term="jdk" scheme="https://dongme.site/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>java编程思想[21]-并发</title>
    <link href="https://dongme.site/2018/09/26/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-21/"/>
    <id>https://dongme.site/2018/09/26/java编程思想-21/</id>
    <published>2018-09-26T05:23:00.000Z</published>
    <updated>2018-10-15T14:26:06.723Z</updated>
    
    <content type="html"><![CDATA[<p>并发老生常谈，确实也是java中十分重要的模块，该部分重点讲解并发相关的零碎知识点。<br><a id="more"></a>   </p><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><hr><h5 id="并发的多面性"><a href="#并发的多面性" class="headerlink" title="并发的多面性"></a>并发的多面性</h5><p>用并发解决的问题大体上可以分为速度和设计可管理性两种。  </p><ul><li>更快的执行<br>为了程序运行的更快，并发充分利用这些额外的处理器。<br>单核处理器上并发带来的开销比顺序执行大，因为其中增加了大量的上下文切换。但在单核上使用并发可以防止程序停止，即使一个任务阻塞了，其它任务可以继续执行。  </li><li>改进代码设计<br>单核机器通过并发可以仿真，仿真目标一般都是多任务的，每个线程处理单独的任务。  </li></ul><h5 id="基本的线程机制"><a href="#基本的线程机制" class="headerlink" title="基本的线程机制"></a>基本的线程机制</h5><p>并发编程使我们可以将程序划分为多个分离的、独立运行的任务。通过使用多线程机制，这些独立任务中的每一个都将由执行线程来驱动。  </p><ul><li>定义任务<br>实现Runnable接口，实现方法run。<br>在main方法中直接调用run方法，是顺序执行，并不会启动一个新的线程处理。  </li><li>Thread类<br>将Runnable对象转变为工作任务的传统方式是把它提交给一个Thread构造器。  </li><li><p>使用Executor  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">for()&#123;</span><br><span class="line">   exec.execute(实现Runnable的对象实例);</span><br><span class="line">&#125;</span><br><span class="line">exec.shutdown();</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">可以将上面的CachedThreadPool替换为不同类型的Executor。FixedThreadPool使用了有限的线程集来执行所提交的任务。  </span><br><span class="line">``` </span><br><span class="line">ExecutorService exec = Executor.newFixedThreadPool(5);</span><br><span class="line">for()&#123;</span><br><span class="line">    exec.execute(实现Runnable的对象实例);</span><br><span class="line">&#125;</span><br><span class="line">exec.shutdown();</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">SingleThreadExecutor就像是线程数量为1的FixedTreadPool。这对于希望在另一个线程中连续运行的事物来说，都是很有用的。  </span><br><span class="line">``` </span><br><span class="line">ExecutorService exec = Executor.SingleThreadExecutor();</span><br><span class="line">for()&#123;</span><br><span class="line">    exec.execute(实现Runnable的对象实例);</span><br><span class="line">&#125;</span><br><span class="line">exec.shutdown();</span><br></pre></td></tr></table></figure></li><li><p>从任务中产生返回值<br>Runnable独立执行任务，不返回值。Callable是一种具有类型参数的泛型，它的类型参数表示的是从call()方法返回的值，并且必须使用ExecutorService.submit()方法调用它。如下： </p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line">class TaskWithResult implements Callable&lt;String&gt; &#123;</span><br><span class="line">    private int id;</span><br><span class="line"></span><br><span class="line">    public TaskWithResult(int id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        return &quot;result of TaskWithResult &quot; + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CallableDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        ArrayList&lt;Future&lt;String&gt;&gt; results = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            results.add(exec.submit(new TaskWithResult(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        for (Future&lt;String&gt; fs : results) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(fs.get());</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">                return;</span><br><span class="line">            &#125; catch (ExecutionException e) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;finally &#123;</span><br><span class="line">                exec.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">+ 休眠  </span><br><span class="line">sleep(long)将使任务中止执行指定时间。  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">try &#123;</span><br><span class="line">  TimeUnit.MILLISECONDS.sleep(100);</span><br><span class="line">&#125; catch (InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">+ 优先级  </span><br><span class="line">线程的优先级将该线程的重要性传递给了调度器。优先级较低的线程仅仅是执行的频率较低。  </span><br><span class="line">设置线程的优先级通过setPriority()方法进行设置。  </span><br><span class="line"></span><br><span class="line">+ 后台线程即守护线程  </span><br><span class="line">当所有非后台线程结束时，程序也就终止了，同时会杀死进程中所有的后台线程。  </span><br><span class="line">只要有任何非后台线程还在执行，程序就不好终止。  </span><br><span class="line">通过setDeamon()方法设置为后台线程。</span><br><span class="line"></span><br><span class="line">+ 让步</span><br><span class="line">调用yield()时，你也是在建议具有相同优先级的其他线程可以运行。</span><br><span class="line"></span><br><span class="line">+ 编码的变体</span><br><span class="line">通过继承Thread创建线程类。通过构造器设置线程名。</span><br><span class="line"></span><br><span class="line">+ 术语</span><br><span class="line">任务和线程并不等价。在描述将要执行的任务时使用术语&quot;任务&quot;，只有在引用到驱动任务的具体机制时，才使用线程。只在概念</span><br><span class="line">级别上讨论系统，就可以只使用任务，而不需要提及驱动机制。</span><br><span class="line"></span><br><span class="line">+ 加入一个线程</span><br><span class="line">一个线程可以在其他线程之上调用join()方法，其效果是等待一段时间直到第二个线程结束才继续执行。如果某个线程在另一个线程t上调用</span><br><span class="line">t.join()，此线程将被挂起，直到目标t结束才恢复（即t.isAlive()返回为false）。</span><br><span class="line">也可以在调用join()时带上一个超时参数，如果目标线程在这段时间到期时还没有结束，join()总能返回。</span><br><span class="line">对join()对方法调用可以被中断，做法是在调用线程上调用interrupt()方法，这时需要用到try-catch字句。  </span><br><span class="line"></span><br><span class="line">+ 线程组  </span><br><span class="line">线程组持有一个线程集合。可以把线程组看成是一次不成功的尝试，忽略就好。  </span><br><span class="line"></span><br><span class="line">+ 捕获异常  </span><br><span class="line">由于线程的本质特性，使得你不能捕获从线程中逃逸的异常。一旦异常逃出任务的run()方法，它就会向外传播到控制台。可以用Executor来解决这个问题。</span><br><span class="line">通过在每个Thread对象上都附着一个异常处理器。Thread.UncaughtExceptionHandler.uncaughtException()会在线程因未捕获的异常而临近死亡时被调用。创建一个新类型的ThreadFactory，</span><br><span class="line">它将在每个新创建的Thread对象上附着一个Thread.UncaughtExceptionHandler。  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">class ExceptionThread2 implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        System.out.println(&quot;run() by &quot; + t);</span><br><span class="line">        System.out.println(&quot;eh = &quot; + t.getUncaughtExceptionHandler());</span><br><span class="line">        throw new RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void uncaughtException(Thread t, Throwable e) &#123;</span><br><span class="line">        System.out.println(&quot;caught &quot; + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HandlerThreadFactory implements ThreadFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Thread newThread(Runnable r) &#123;</span><br><span class="line">        System.out.println(this + &quot;creating new Thread&quot;);</span><br><span class="line">        Thread t = new Thread(r);</span><br><span class="line">        System.out.println(&quot;created &quot; + t);</span><br><span class="line">        t.setUncaughtExceptionHandler(new MyUncaughtExceptionHandler());</span><br><span class="line">        System.out.println(&quot;eh = &quot; + t.getUncaughtExceptionHandler());</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CaptureUncaughtException &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool(new HandlerThreadFactory());</span><br><span class="line">        exec.execute(new ExceptionThread2());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">##### 共享受限资源  </span><br><span class="line">基本上所有的并发模式在解决线程冲突问题的时候，都是采用序列化访问共享资源的方案。  </span><br><span class="line">在共享资源的代码前加锁语句来实现，使得一段时间内只有一个任务访问共享资源。锁语句产生了一种互相排斥的效果，所以这种机制常常称为互斥量。  </span><br><span class="line"></span><br><span class="line">+ 描述  </span><br><span class="line"></span><br><span class="line">屋子里的浴室实例：房子里的多个人都希望单独使用浴室。为了使用浴室，一个人先敲门，看看能否使用。如果没人的话，他就进入浴室锁上门。这时其它人</span><br><span class="line">要使用浴室的话，就会被阻挡，所以他们要在门口等待，直到浴室可用。  </span><br><span class="line">当浴室使用完毕，当锁住浴室门的那个人打开锁准备离开的时候，簇拥在门口的人中，离门口最近的那个最有可能成为下一个进入浴室的人。可以通过yield</span><br><span class="line">和setPriority来给线程调度器建议，但这些建议未必有多大效果，这取决于具体的平台和JVM实现。  </span><br><span class="line"></span><br><span class="line">共享资源一般是以对象存在的内存片段，但也可以是文件、输入/输出端口、或者是打印机。要控制对共享资源的访问，得先把它包装成对象，然后把所有要</span><br><span class="line">访问这个资源的方法都标记为synchronized。  </span><br><span class="line"></span><br><span class="line">在使用并发时，将域设置为private是非常重要的。否则，synchronized就不能防止其它任务直接访问域，这样就会产生冲突。  </span><br><span class="line"></span><br><span class="line">一个任务可以多次获得对象的锁，如果调用了一个对象的同步方法，方法中又调用了同一对象的另一个同步方法，JVM负责跟踪统计对象加锁的次数，每进入这个对象</span><br><span class="line">的同步方法，计数加1；每退出这个对象的同步方法，计数减一。如果对象被解锁，计数为0。  </span><br><span class="line"></span><br><span class="line">针对每个类，也有一个锁（作为类的Class对象的一部分），所以synchronized static可以在类的范围内防止对static数据的并发访问。  </span><br><span class="line"></span><br><span class="line">每个访问临界共享资源的方法都应该被同步，否则它们就不能正确的工作。  </span><br><span class="line"></span><br><span class="line">+ 使用显式的Lock对象  </span><br><span class="line"></span><br><span class="line">java.util.concurrent类库包含定义在java.util.concurrent.locks中显示的互斥机制。Lock对象必须被显式地创建、锁定</span><br><span class="line">和释放。与内建的锁形式相比，代码缺乏优雅性，出错的可能性比较大。但是，对于解决某些类型的问题来说，它更加灵活。  </span><br><span class="line"></span><br><span class="line">+ 原子性与易变性  </span><br><span class="line"></span><br><span class="line">原子操作是不能被线程调度机制中断的操作；一旦操作开始，那么它一定在 &quot;上下文切换&quot; 之前执行完毕。原子性不能替代同步，除非</span><br><span class="line">有十足的把握。  </span><br><span class="line">原子性可以应用于除long和double之外的所有基本类型之上的简单操作。当你定义long或double变量时，如果使用volatitle</span><br><span class="line">关键字，就会获得原子性。  </span><br><span class="line"></span><br><span class="line">在多处理器系统上，相对于单处理器系统而言，可视性问题远比原子性问题多得多。一个任务做出的修改，即使在不中断的意义上讲</span><br><span class="line">是原子性的，对其他任务也可能是不可视的。  </span><br><span class="line"></span><br><span class="line">volatitle确保了应用中的可视性。一个域声明为volatitle的，那么只要对这个域产生了写操作，那么所有的读操作就都可以看到</span><br><span class="line">这个修改。volatitle域会立即被写入到主内存中，而读取操作就发生在主内存中。  </span><br><span class="line"></span><br><span class="line">synchronized会将工作内存变量值刷新到主内存中，用synchronized一般不需要volatitle。  </span><br><span class="line"></span><br><span class="line">使用volatile而不是synchronized关键字的唯一安全的情况是类中只有一个可变的域。再次提醒，你的第一选择应该是使用synchronized</span><br><span class="line">关键字，这是最安全的方式，而尝试其他任何方式都是有风险的。</span><br><span class="line"></span><br><span class="line">+ 原子类  </span><br><span class="line"></span><br><span class="line">AtomicInteger、AtomicLong、AtomicReference等原子变量类，一般涉及到性能调优会用到。常规编程也很少用到。  </span><br><span class="line"></span><br><span class="line">+ 临界区  </span><br><span class="line"></span><br><span class="line">也称为同步代码块；防止多个线程同时访问方法内部的部分代码而不是防止访问整个方法。通过这种方式分离出的代码段被称为</span><br><span class="line">临界区，形式如下：  </span><br><span class="line">``` </span><br><span class="line">synchronized(syncObject) &#123;</span><br><span class="line">  //</span><br><span class="line">  //</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在其他对象上同步   </li></ul><p>synchronized块必须给定一个在其上进行同步的对象，使用synchronized(this)时，其他synchronized方法和临界区就不能<br>被调用。因此一般设置一个私有成员变量，以该变量作为同步对象。  </p><ul><li>线程本地存储  </li></ul><p>线程本地存储是一种自动化机制，可以为使用相同变量的每个不同的线程都创建不同的存储。<br>创建和管理本地存储一般使用java.lang.ThreadLocal类来实现。<br>ThreadLocal对象通常当作静态域存储。在创建ThreadLocal时，你只能通过get()和set()方法来访问该对象内容。<br>其中get()方法将返回与其线程相关联的对象的副本，而set()会将参数插入到为其线程存储的对象中，并返回存储中<br>原有的对象。  </p><h5 id="终结任务"><a href="#终结任务" class="headerlink" title="终结任务"></a>终结任务</h5><ul><li>装饰性花园  </li><li>在阻塞时终结  </li></ul><p>sleep()的一种情况，它使任务从执行状态变为被阻塞状态，而有时你必须终止被阻塞的任务。  </p><p><strong>线程状态</strong><br>1）新建（New）:当线程被创建时，它只会短暂地处于这种状态。此时它已经分配了必须的系统资源，并执行了<br>初始化。此刻线程已有资格获得CPU时间了，之后调度器将把这个线程转变为可运行状态或阻塞状态。<br>2）就绪（Runnable）：在这种状态下，只要调度器把时间片分配给线程，线程就可以运行。<br>3）阻塞（Blocked）：线程能够运行，但有某个条件阻止它的运行。当线程处于阻塞状态时，调度器将忽略线程，不会<br>分配线程任何cpu时间。直到线程重新进入就绪状态。<br>4）死亡（Dead）：处于死亡或终止状态的线程将不再是可调度的，并且再也不会得到cpu时间，它的任务已结束，或不再<br>是可运行的。任务死亡的通常方式是从run()方法返回，但是任务的线程还可以被中断。  </p><p><strong>进入阻塞状态</strong><br>进入阻塞状态的原因有如下：<br>1）通过调用sleep(milliseconds)使任务进入休眠状态，在这种情况下，任务在指定时间内不会运行。<br>2）调用wait()使线程挂起。直到线程得到了notify()或notifyAll()的消息（或在java.util.concurrent类库中等价的signal()或signalAll()消息），<br>线程才会进入就绪状态。<br>3）任务在等待某个输入/输出完成。<br>4）任务试图在某个对象上调用其同步控制方法，但是对象锁不可用，因为另一个任务已经获取了这个锁。<br>在较早的代码中可能看到suspend()和resume()来阻塞和唤醒线程，因为可能导致死锁，现在已经废弃了。stop()<br>方法也已经被弃用了，因为它不释放线程获得的锁，并且如果线程处于不一致状态，其它任务可以在这种状态下浏览并<br>修改它们，造成的问题难以发现。  </p><ul><li><p>中断<br>异常中断通过调用Thread的interrupt()方法。<br>当线程抛出异常InterruptedException或调用中断方法时，中断状态将被复位。<br>SleepBlocked是可中断，IOBlocked和SynchronizedBlocked是不可以中断的，对于这类问题可以关闭任务在其上发生阻塞的底层资源。  </p></li><li><p>被互斥所阻塞  </p></li><li>检查中断<br>通过调用interrupted()来检查中断状态。  </li></ul><h5 id="线程之间的协作"><a href="#线程之间的协作" class="headerlink" title="线程之间的协作"></a>线程之间的协作</h5><ul><li>wait()与notifyAll()<br>调用sleep()和yield()时候锁并没有被释放。<br>wait()调用时，线程将被挂起，对象上的锁被释放。在该对象上的其它synchronized方法在wait()期间被调用。<br>两种形式的wait：第一种接受毫秒作为参数，意为在此期间等待；第二种没有参数，一直等待。两种方式都可以通过notify和notifyAll恢复执行。<br>wait、notify、notifyAll这些方法是基类Object的一部分。在调用这些方法前必须先获取该对象的锁。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sychronized(x) &#123;</span><br><span class="line">    x.notifyAll();</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">+ 错失的信号  </span><br><span class="line">+ notify()与nitifyAll()  </span><br><span class="line">使用nitify()而不是nitifyAll()是一种优化。  </span><br><span class="line">使用notify()时，在众多等待同一个锁的任务中只有一个会被唤醒，因此要使用notify就必须保证被唤醒的是恰当的任务。  </span><br><span class="line"></span><br><span class="line">+ 生产者与消费者  </span><br><span class="line"></span><br><span class="line">+ 使用显示的Lock和Condition对象</span><br></pre></td></tr></table></figure></li></ul><p>private Lock lock = new ReentrantLock();<br>private Condition condition = lock.newCondition();<br>public void test() {<br>    lock.lock();<br>    try {<br>      condition.await();<br>      condition.signalAll();//<br>    } finally {<br>      lock.unlock();<br>    }<br>}<br>```  </p><ul><li>生产者-消费者队列  </li><li>任务间使用管道进行输入/输出  </li></ul><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><h5 id="新类库中的构件"><a href="#新类库中的构件" class="headerlink" title="新类库中的构件"></a>新类库中的构件</h5><ul><li>CountDownLatch<br>它被用来同步一个或多个任务，强制它们等待由其他任务执行的一组操作完成。不能充值。  </li><li>CyclicBarrier<br>你希望创建一组任务，它们并行地执行工作，然后在进行下一个步骤之前等待，直至所有任务都完成。可以重置。  </li><li>DelayQueue<br>一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象的延迟<br>到期的时间最长。如果没有任何延迟到期，那么就不会有任何头元素。  </li><li>PriorityBlockingQueue<br>这是一个很基础的优先级队列，它具有可阻塞的读取操作。  </li><li>使用ScheduledExecutor的温室控制器  </li><li>Semaphore<br>计数信号量允许n个任务同时访问这个资源。  </li><li>Exchanger<br>Exchanger是在两个任务之间交换对象的栅栏。当这些任务进入栅栏时，它们各自拥有一个对象，当它们离开时，它们都拥有之前由对象持有的对象。  </li></ul><h5 id="仿真"><a href="#仿真" class="headerlink" title="仿真"></a>仿真</h5><h5 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h5><h5 id="活动对象"><a href="#活动对象" class="headerlink" title="活动对象"></a>活动对象</h5>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并发老生常谈，确实也是java中十分重要的模块，该部分重点讲解并发相关的零碎知识点。&lt;br&gt;
    
    </summary>
    
    
      <category term="编程思想" scheme="https://dongme.site/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>java编程思想[17]-容器</title>
    <link href="https://dongme.site/2018/09/25/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-17/"/>
    <id>https://dongme.site/2018/09/25/java编程思想-17/</id>
    <published>2018-09-25T10:32:00.000Z</published>
    <updated>2018-10-15T14:26:29.570Z</updated>
    
    <content type="html"><![CDATA[<p>在Java当中，如果有一个类专门用来存放其它类的对象，这个类就叫做容器，或者就叫做集合，集合就是将若干性质相同或相近的类对象组合在一起而形成的一个整体。<br><a id="more"></a> </p><h4 id="容器深入研究"><a href="#容器深入研究" class="headerlink" title="容器深入研究"></a>容器深入研究</h4><hr><h5 id="完整的容器分类法"><a href="#完整的容器分类法" class="headerlink" title="完整的容器分类法"></a>完整的容器分类法</h5><h5 id="填充容器"><a href="#填充容器" class="headerlink" title="填充容器"></a>填充容器</h5><p>使用Collections.nCopies()进行填充，可以自定义添加填充个数，而Collections.fill()只能替换元素不能添加元素。  </p><h5 id="Collections的功能方法"><a href="#Collections的功能方法" class="headerlink" title="Collections的功能方法"></a>Collections的功能方法</h5><p>如下Collection所有操作，也是可以通过Set或List执行的所有操作（List还有额外功能）。Map不是继承自Collecion所以不使用下面方法。  </p><ul><li>boolean add(T) 确保容器持有具有泛型类型T的参数。如果没有将此参数添加进容器，则返回false。  </li><li>boolean addAll(Collection&lt;? extends T&gt;) 添加参数中的所有元素，只要添加了任意元素就返回true。  </li><li>void clear()  移除容器中的所有元素。  </li><li>boolean contains(T) 如果容器已经持有具有泛型类型T此参数，则返回true。  </li><li>Boolean containsAll(Collecion&lt;?&gt;) 如果容器持有此参数的所有元素，则返回true。  </li><li>boolean isEmpty() 容器中没有任何元素返回true。  </li><li>Iterator<t> iterator() 返回一个Iterator<t>，可以用来遍历容器中的元素。  </t></t></li><li>Boolean remove(Object) 如果参数在容器中，则移除此元素一个实例。如果做了移除动作，返回true。  </li><li>boolean removeAll(Collection&lt;?&gt;) 移除参数中的所有元素。只要有移除动作发生就返回true。  </li><li>Boolean retainAll(Collection&lt;?&gt;) 只保存参数中的元素（应用集合论的”交集”概念）。 只要集合发生了改变就返回true。  </li><li>int size()返回容器中元素数目。  </li><li>Object[] toArray() 返回一个数组，该数组包含容器中的所有元素。  </li><li><t> T[] toArray(T[] a) 返回一个数组，该数组包含容器中的所有元素。返回结果的运行时类型与参数数组a的相同，而不是单纯的Object。  </t></li></ul><h5 id="可选操作"><a href="#可选操作" class="headerlink" title="可选操作"></a>可选操作</h5><h5 id="List的功能方法"><a href="#List的功能方法" class="headerlink" title="List的功能方法"></a>List的功能方法</h5><h5 id="Set和存储顺序"><a href="#Set和存储顺序" class="headerlink" title="Set和存储顺序"></a>Set和存储顺序</h5><p>Set中的存储顺序如何维护，Set的不同实现之间有所变化。因此不同Set实现不仅有不同的行为，而且它们对于可以在特定的Set中放置的元素的类型也有不同的要求  </p><blockquote><p><strong>Set（interface）:</strong>存入Set的每个元素必须是唯一的，因为Set不保存重复元素。加入Set的元素必须定义equals()方法以确保对象的唯一性。Set与Collection有完全一样的接口。Set接口不保证维护元素的次序。<br><strong>HashSet：</strong>为快速查找而设计的Set，存入HashSet的元素必须定义hashCode()，没有其他的限制，应默认采取该方式，对速度进行了优化。<br><strong>TreeSet：</strong>保持次序的Set，底层为树结构。使用它可以从Set中提取有序的序列。元素必须实现Comparable<br><strong>LinkedHashSet：</strong>具有HashSet的查询速度，且内部使用链表维护元素的顺序（插入的次序）。于是在使用迭代器遍历Set时，结果会按元素插入的次序显示，元素也必须定义hashCode()方法   </p></blockquote><ul><li>SortedSet<br>SortedSet中的元素可以保证处于排序状态，具有如下方法提供的附加功能：<br><strong>Comparator comparator()</strong>返回当前Set使用的Comparator。<br><strong>Object first()</strong>返回容器中的第一个元素。<br><strong>Object last()</strong>返回容器中的最末一个元素。<br><strong>SortedSet subSet(fromElement, toElement)</strong>返回从fromElement（包含）到toElement（不包含）<br><strong>SortedSet headSet(toElement)</strong>生成此Set的子集，由小于toElement的元素组成。<br><strong>SortedSet tailSet(fromElement)</strong>生成此Set的子集，由大于或等于fromElement的元素组成。  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">public class SortedSetDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SortedSet&lt;String&gt; sortedSet = new TreeSet&lt;&gt;();</span><br><span class="line">        Collections.addAll(sortedSet, &quot;one two three four five six seven eight&quot;.split(&quot; &quot;));</span><br><span class="line">        System.out.println(sortedSet);</span><br><span class="line">        String low = sortedSet.first();</span><br><span class="line">        String high = sortedSet.last();</span><br><span class="line">        System.out.println(low);</span><br><span class="line">        System.out.println(high);</span><br><span class="line">        Iterator&lt;String&gt; it = sortedSet.iterator();</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt;= 6; i++) &#123;</span><br><span class="line">    if (i == 3) &#123;</span><br><span class="line">    low = it.next();</span><br><span class="line">    System.out.println(&quot;i==3 low:&quot; + low);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    if (i == 6) &#123;</span><br><span class="line">    high = it.next();</span><br><span class="line">    System.out.println(&quot;i==6 high:&quot; + high);</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    String temp =  it.next();</span><br><span class="line">    System.out.println(&quot;temp:&quot; + temp);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(low);</span><br><span class="line">    System.out.println(high);</span><br><span class="line">    System.out.println(sortedSet.subSet(low,high));</span><br><span class="line">    System.out.println(sortedSet.headSet(high));</span><br><span class="line">    System.out.println(sortedSet.tailSet(low));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// output : </span><br><span class="line">[eight, five, four, one, seven, six, three, two]</span><br><span class="line">eight</span><br><span class="line">two</span><br><span class="line">temp:eight</span><br><span class="line">temp:five</span><br><span class="line">temp:four</span><br><span class="line">i==3 low:one</span><br><span class="line">temp:seven</span><br><span class="line">temp:six</span><br><span class="line">temp:three</span><br><span class="line">i==6 high:two</span><br><span class="line">one</span><br><span class="line">two</span><br><span class="line">[one, seven, six, three]</span><br><span class="line">[eight, five, four, one, seven, six, three]</span><br><span class="line">[one, seven, six, three, two]</span><br><span class="line">```  </span><br><span class="line">注意：SortedSet是按照元素的比较函数对元素排序，而不是元素插入的顺序。出入顺序可以用LinkedHashSet保存。   </span><br><span class="line"></span><br><span class="line">##### 队列  </span><br><span class="line">+ Java SE5中仅有的两个实现是LinkedList和PriorityQueue，它们差异在于排序行为而不是性能。  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">public class QueueBehavior &#123;</span><br><span class="line">    private static int count = 10;</span><br><span class="line"></span><br><span class="line">    static &lt;T&gt; void test(Queue&lt;T&gt; queue, Generator&lt;T&gt; gen) &#123;</span><br><span class="line">        for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            queue.offer(gen.next());//队尾添加元素，队满返回false</span><br><span class="line">        &#125;</span><br><span class="line">        while (queue.peek() != null) &#123;//取队头，没有返回null</span><br><span class="line">            System.out.print(queue.remove() + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    static class Gen implements Generator&lt;String&gt; &#123;</span><br><span class="line">        String[] s = (&quot;one two three four five six seven eight nine ten&quot;).split(&quot; &quot;);</span><br><span class="line">        int i;</span><br><span class="line">        public String next() &#123;</span><br><span class="line">            return s[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        test(new LinkedList&lt;String&gt;(), new Gen());</span><br><span class="line">        test(new PriorityQueue&lt;String&gt;(), new Gen());//优先队列的作用是能保证每次取出的元素都是队列中权值最小的</span><br><span class="line">        test(new ArrayBlockingQueue&lt;&gt;(count), new Gen());//阻塞队列</span><br><span class="line">        test(new ConcurrentLinkedDeque&lt;&gt;(), new Gen());//非阻塞线程安全队列</span><br><span class="line">        test(new LinkedBlockingDeque&lt;&gt;(), new Gen());//基于链表的双端阻塞队列，支持FIFO和FILO，线程安全</span><br><span class="line">        test(new PriorityBlockingQueue&lt;&gt;(), new Gen());//阻塞优先级队列，线程安全</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">+ 双向队列   </span><br><span class="line">ArrayDeque不是线程安全的，可以双向（队头和队尾操作），主要方法：</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">1.添加元素</span><br><span class="line">        addFirst(E e)在数组前面添加元素</span><br><span class="line">        addLast(E e)在数组后面添加元素</span><br><span class="line">        offerFirst(E e) 在数组前面添加元素，并返回是否添加成功</span><br><span class="line">        offerLast(E e) 在数组后天添加元素，并返回是否添加成功</span><br><span class="line"></span><br><span class="line">  2.删除元素</span><br><span class="line">        removeFirst()删除第一个元素，并返回删除元素的值,如果元素为null，将抛出异常</span><br><span class="line">        pollFirst()删除第一个元素，并返回删除元素的值，如果元素为null，将返回null</span><br><span class="line">        removeLast()删除最后一个元素，并返回删除元素的值，如果为null，将抛出异常</span><br><span class="line">        pollLast()删除最后一个元素，并返回删除元素的值，如果为null，将返回null</span><br><span class="line">        removeFirstOccurrence(Object o) 删除第一次出现的指定元素</span><br><span class="line">        removeLastOccurrence(Object o) 删除最后一次出现的指定元素</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   3.获取元素</span><br><span class="line">        getFirst() 获取第一个元素,如果没有将抛出异常</span><br><span class="line">        getLast() 获取最后一个元素，如果没有将抛出异常</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    4.队列操作</span><br><span class="line">        add(E e) 在队列尾部添加一个元素</span><br><span class="line">        offer(E e) 在队列尾部添加一个元素，并返回是否成功</span><br><span class="line">        remove() 删除队列中第一个元素，并返回该元素的值，如果元素为null，将抛出异常(其实底层调用的是removeFirst())</span><br><span class="line">        poll()  删除队列中第一个元素，并返回该元素的值,如果元素为null，将返回null(其实调用的是pollFirst())</span><br><span class="line">        element() 获取第一个元素，如果没有将抛出异常</span><br><span class="line">        peek() 获取第一个元素，如果返回null</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">    5.栈操作</span><br><span class="line">        push(E e) 栈顶添加一个元素</span><br><span class="line">        pop(E e) 移除栈顶元素,如果栈顶没有元素将抛出异常</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    6.其他</span><br><span class="line">        size() 获取队列中元素个数</span><br><span class="line">        isEmpty() 判断队列是否为空</span><br><span class="line">        iterator() 迭代器，从前向后迭代</span><br><span class="line">        descendingIterator() 迭代器，从后向前迭代</span><br><span class="line">        contain(Object o) 判断队列中是否存在该元素</span><br><span class="line">        toArray() 转成数组</span><br><span class="line">        clear() 清空队列</span><br><span class="line">        clone() 克隆(复制)一个新的队列</span><br></pre></td></tr></table></figure><h5 id="理解Map"><a href="#理解Map" class="headerlink" title="理解Map"></a>理解Map</h5><ul><li>性能<br>HashMap是使用对象的hashCode()进行快速查询的，此方法能够显著提高性能。<br>下面是基本的Map实现。在HashMap上打星号表示如果没有其他的限制，它就应该成为你的默认选择，因为它对速度进行了优化。其它实现强调了其他的特性，因此都不如HashMap快。  </li></ul><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">HashMap</td><td style="text-align:left">Map基于散列表的实现。插入和查询键值对的开销是固定的。可以通过构造器设置容量和负载因子，以调整容器的性能。</td></tr><tr><td style="text-align:left">LinkedHashMap</td><td style="text-align:left">类似于HashMap，但是迭代遍历它时，取得键值对的顺序是其插入次序，或者是最近最少使用的次序。只比HashMap慢一点，而在迭代访问时反而更快，因为它使用链表维护内部次序。</td></tr><tr><td style="text-align:left">TreeMap</td><td style="text-align:left">基于红黑树的实现。查看键或键值对时，它们会被排序（有Comparable或Comparator决定）。TreeMap的特点在于，所得到的结果是经过排序的。唯一带有subMap()方法的Map。</td></tr><tr><td style="text-align:left">WeakHashMap</td><td style="text-align:left">弱键映射，允许释放映射所指向的对象；为解决某类特殊问题而设计的。如果映射之外没有引用指向某个键，则此键可以被垃圾回收器回收。</td></tr><tr><td style="text-align:left">ConcurrentHashMap</td><td style="text-align:left">一种线程安全的Map，它不涉及同步加锁。</td></tr><tr><td style="text-align:left">IdentityHashMap</td><td style="text-align:left">使用==代替equals对键进行比较的散列映射。</td></tr></tbody></table><ul><li><p>SortedMap<br>使用SortedMap（TreeMap是现阶段唯一实现），可以确保键处于排序状态。  </p><pre><code>//返回元素比较器。如果是自然顺序，则返回null；  Comparator&lt;? super K&gt; comparator();  //返回从fromKey到toKey的集合：含头不含尾  java.util.SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey);  //返回从头到toKey的集合：不包含toKey  java.util.SortedMap&lt;K,V&gt; headMap(K toKey);  //返回从fromKey到结尾的集合：包含fromKey  java.util.SortedMap&lt;K,V&gt; tailMap(K fromKey);  //返回集合中的第一个元素：  K firstKey();  //返回集合中的最后一个元素：  K lastKey();  //返回集合中所有key的集合：  Set&lt;K&gt; keySet();  //返回集合中所有value的集合：  Collection&lt;V&gt; values();  //返回集合中的元素映射：  Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</code></pre></li><li>LinkedHashMap<br>LinkedHashMap 是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，<br>按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。  </li></ul><h5 id="散列和散列码"><a href="#散列和散列码" class="headerlink" title="散列和散列码"></a>散列和散列码</h5><p>假如键没有按照一定的顺序进行保存，那么查询的时候就只能按照顺序进行线性查询，然而，线性查询是最慢的查询方式。所以，将键值按照一定的顺序排序，并且使用二分查找能购有效的提升速度。散列在此之上，更近一步，他将键保存在数组中(数组的查询速度最快)，用数组来表示键的信息，但是由于Map的容量是可变的，而数组的容量是不变的。要解决这个问题，数组中存的并不是键本身，而是键对象生成的一个数字，将其作为数组的下标，这个数字就是散列码。<br>而这种办法所产生的问题就是下标重复。而我们的解决办法就是配合equals来确定键值。<br>查询的过程首先就是计算散列码，然后用散列码来查询函数(下标)，通常，我们的数组中保存的是值的list，因此，我们计算出散列码之后，通过下表取到的对应部分的list，然后通过equals就可以快速找到键值。  </p><p>散列码：通过hashCode返回int类型的数值，即为对象的散列码。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Java当中，如果有一个类专门用来存放其它类的对象，这个类就叫做容器，或者就叫做集合，集合就是将若干性质相同或相近的类对象组合在一起而形成的一个整体。&lt;br&gt;
    
    </summary>
    
    
      <category term="编程思想" scheme="https://dongme.site/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>java编程思想[16]-数组</title>
    <link href="https://dongme.site/2018/08/23/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-16/"/>
    <id>https://dongme.site/2018/08/23/java编程思想-16/</id>
    <published>2018-08-23T07:34:00.000Z</published>
    <updated>2018-10-15T14:26:47.016Z</updated>
    
    <content type="html"><![CDATA[<p>泛型对数组是极大的威胁，带有泛型的容器拥有更强大的适用性。只有在证明性能受限时，才会考虑使用数组，但数组还是必须掌握的基础知识。<br><a id="more"></a>  </p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><hr><h5 id="数组为什么特殊"><a href="#数组为什么特殊" class="headerlink" title="数组为什么特殊"></a>数组为什么特殊</h5><ul><li>数组是一种效率最高的存储和随机访问对象引用序列的方式。数组就是一个简单的线性序列，这使得元素访问非常快速。数据大小固定。  </li></ul><p>数组与泛型容器比较：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class BerylliumSphere &#123;</span><br><span class="line">private static long counter;</span><br><span class="line">private final long id = counter++;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;Sphere &quot; + id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ContainerComparison &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">BerylliumSphere[] spheres = new BerylliumSphere[10];</span><br><span class="line">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">spheres[i] = new BerylliumSphere();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(spheres));</span><br><span class="line">System.out.println(spheres[4]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">List&lt;BerylliumSphere&gt; sphereList = new ArrayList&lt;&gt;();</span><br><span class="line">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">sphereList.add(new BerylliumSphere());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sphereList);</span><br><span class="line">System.out.println(sphereList.get(4));</span><br><span class="line"></span><br><span class="line">int[] integers = &#123;0, 1, 2, 3, 4, 5&#125;;</span><br><span class="line">System.out.println(Arrays.toString(integers));</span><br><span class="line">System.out.println(integers[4]);</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; intList = new ArrayList&lt;&gt;(Arrays.asList(0, 1, 2, 3, 4, 5));</span><br><span class="line">intList.add(97);</span><br><span class="line">System.out.println(intList);</span><br><span class="line">System.out.println(intList.get(4));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h5><p>初始化赋值，也可以循环赋。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MultidimensionalPrimitiveArray &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  int[][] a = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;&#125;;</span><br><span class="line">  System.out.println(Arrays.deepToString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="数组与泛型"><a href="#数组与泛型" class="headerlink" title="数组与泛型"></a>数组与泛型</h5><p>不能实例化具有参数化类型的数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">Peel&lt;Banana&gt;[] peels = new Peel&lt;Banana&gt;[10];//Illegal</span><br><span class="line">```  </span><br><span class="line">擦除会移除参数类型信息，而数组必须知道它们所持有的确切类型，以强制保证类型安全。  </span><br><span class="line">但是，可以参数化数组本身的类型：  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">class ClassParameter&lt;T&gt; &#123;</span><br><span class="line">    public T[] f(T[] arg) &#123;</span><br><span class="line">        return arg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MethodParameter &#123;</span><br><span class="line">    public static &lt;T&gt; T[] f(T[] arg) &#123;</span><br><span class="line">        return arg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ParameteriaedArrayType &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer[] ints = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">        Double[] doubles = &#123;1.1, 2.2, 3.3, 4.4, 5.5&#125;;</span><br><span class="line">        Integer[] ints2 = new ClassParameter&lt;Integer&gt;().f(ints);</span><br><span class="line">        Double[] doubles2 = new ClassParameter&lt;Double&gt;().f(doubles);</span><br><span class="line">        ints2 = MethodParameter.f(ints);</span><br><span class="line">        doubles = MethodParameter.f(doubles);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">##### 创建测试数据  </span><br><span class="line">+ Arrays.fill()  </span><br><span class="line">只能用同一个值填充各个位置，而针对对象而言，就是复制同一个引用进行填充。  </span><br><span class="line">``` </span><br><span class="line">public class FillingArrays &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int size = 6;</span><br><span class="line">        boolean[] a1 = new boolean[size];</span><br><span class="line">        byte[] a2 = new byte[size];</span><br><span class="line">        char[] a3 = new char[size];</span><br><span class="line">        short[] a4 = new short[size];</span><br><span class="line">        int[] a5 = new int[size];</span><br><span class="line">        long[] a6 = new long[size];</span><br><span class="line">        float[] a7 = new float[size];</span><br><span class="line">        double[] a8 = new double[size];</span><br><span class="line">        String[] a9 = new String[size];</span><br><span class="line">        Arrays.fill(a1, true);</span><br><span class="line">        System.out.println(&quot;a1 = &quot; + Arrays.toString(a1));</span><br><span class="line">        Arrays.fill(a2, (byte)11);</span><br><span class="line">        System.out.println(&quot;a2 = &quot; + Arrays.toString(a2));</span><br><span class="line">        Arrays.fill(a3, &apos;x&apos;);</span><br><span class="line">        System.out.println(&quot;a3 = &quot; + Arrays.toString(a3));</span><br><span class="line">        Arrays.fill(a4, (short)17);</span><br><span class="line">        System.out.println(&quot;a4 = &quot; + Arrays.toString(a4));</span><br><span class="line">        Arrays.fill(a5, 19);</span><br><span class="line">        System.out.println(&quot;a5 = &quot; + Arrays.toString(a5));</span><br><span class="line">        Arrays.fill(a6, 23);</span><br><span class="line">        System.out.println(&quot;a6 = &quot; + Arrays.toString(a6));</span><br><span class="line">        Arrays.fill(a7, 29);</span><br><span class="line">        System.out.println(&quot;a7 = &quot; + Arrays.toString(a7));</span><br><span class="line">        Arrays.fill(a8, 47);</span><br><span class="line">        System.out.println(&quot;a8 = &quot; + Arrays.toString(a8));</span><br><span class="line">        Arrays.fill(a9, &quot;hello&quot;);</span><br><span class="line">        System.out.println(&quot;a9 = &quot; + Arrays.toString(a9));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="Arrays实用功能"><a href="#Arrays实用功能" class="headerlink" title="Arrays实用功能"></a>Arrays实用功能</h5><ul><li>数组复制  </li></ul><blockquote><p>Java标准类库提供有static方法 <code>System.arraycopy()</code>，用它复制数组比用for循环快很多。<br>该方法不会执行自动拆包和自动包装，两个数组必须具有相同的确切类型。<br>如果数组存储的是对象，则拷贝属于浅复制，仅复制对象引用。</p></blockquote><p>参数详解：<br> <code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code> 其中，src表示源数组，srcPos表示源数组要复制的起始位置，dest表示目标数组，<br>destPos表示目标数组开始复制的起始位置，length表示要复制的长度。  </p><ul><li>数组的比较  </li></ul><blockquote><p>Arrays类提供了重载后的equals()方法，用来比较整个数组。<br>数组相等的条件是个数必须相等，并且对于位置的元素也相等，对每一个元素使用equals()作比较来判断。  </p></blockquote><p>参数详解：<br><code>Arrays.equals(a1, a2)</code>其中，a1为数组1，a2为数组2。  </p><ul><li>数组元素的比较  </li></ul><blockquote><p>基本数据类型的数组不需要实现自己的比较器，java提供默认比较器。  </p></blockquote><p>提供两种实现方式，对象实现接口java.lang.Comparable接口，使你的类天生具有”天生”比较能力。此方法要实现compareTo()一个方法。此方法接收另一个Object为参数，如果当前对象小于参数则返回负值，<br>如果相等就返回零，如果当前对象大于参数则返回正值。数组排序依赖于数组元素的比较，在数组对象实现Comparable接口后，调用<code>Arrays.sort(object)</code>其中object为目标数组，进行排序，只提供了升序排列。  </p><p>第二种也可以实现自己的比较器Comparator。然后调用<code>Arrays.sort(object, 比较器)</code>其中object为目标数组，比较器是自己实现的比较器。如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ComTypeComparator implements Comparator&lt;Object&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Object o1, Object o2) &#123;</span><br><span class="line">        return o1.hashCode() &lt; o2.hashCode() ? -1 : o1.hashCode() == o2.hashCode() ? 0 : 1 ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在已排序的数组中查找<br><code>Arrays.binarySearch(object[], object key)</code>其中object[]为查找的目标数组，key为要查找的值。如果key在数组中，则返回搜索值的索引；否则返回-1或者”-“(插入点)。插入点是索引键将要插入数组的那一点，即第一个大于该键的元素索引。  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int a[] = new int[] &#123;1, 3, 4, 6, 8, 9&#125;;</span><br><span class="line">    int x1 = Arrays.binarySearch(a, 5);</span><br><span class="line">    int x2 = Arrays.binarySearch(a, 4);</span><br><span class="line">    int x3 = Arrays.binarySearch(a, 0);</span><br><span class="line">    int x4 = Arrays.binarySearch(a, 10);</span><br><span class="line">    System.out.println(&quot;x1:&quot; + x1 + &quot;, x2:&quot; + x2);</span><br><span class="line">    System.out.println(&quot;x3:&quot; + x3 + &quot;, x4:&quot; + x4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;泛型对数组是极大的威胁，带有泛型的容器拥有更强大的适用性。只有在证明性能受限时，才会考虑使用数组，但数组还是必须掌握的基础知识。&lt;br&gt;
    
    </summary>
    
    
      <category term="编程思想" scheme="https://dongme.site/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>java编程思想[15]-范型</title>
    <link href="https://dongme.site/2018/08/23/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-15/"/>
    <id>https://dongme.site/2018/08/23/java编程思想-15/</id>
    <published>2018-08-23T07:32:00.000Z</published>
    <updated>2018-10-15T14:27:03.398Z</updated>
    
    <content type="html"><![CDATA[<p>泛型正如其名称暗示的：它是一种方法，通过它可以写出更泛化的代码，这些代码对于它们所操作的类型有更少的限制，因此单个代码段可以应用到更多的类型上，减少重复编码。<br><a id="more"></a></p><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><h5 id="简单泛型"><a href="#简单泛型" class="headerlink" title="简单泛型"></a>简单泛型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public calss Holder&lt;T&gt; &#123;</span><br><span class="line"> private T a;</span><br><span class="line"> public Holder(T a) &#123;</span><br><span class="line">  this.a = a;</span><br><span class="line"> &#125;</span><br><span class="line"> public T get() &#123;</span><br><span class="line">  return a;</span><br><span class="line"> &#125;</span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">  Holder&lt;Automobile&gt; h = </span><br><span class="line">    new Holder&lt;Automobile&gt;(new Automobile);</span><br><span class="line">  Automobile a = h.get();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有了泛型，可以很容易地创建元组，令其返回一组任意类型的对象。通过元组的方式实现返回多个对象的功能  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class TwoTuple&lt;A, B&gt; &#123;</span><br><span class="line">    public final A first;</span><br><span class="line">    public  final B second;</span><br><span class="line"></span><br><span class="line">    public TwoTuple(A a, B b) &#123;</span><br><span class="line">        this.first = a;</span><br><span class="line">        this.second = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;(&quot; + first + &quot;，&quot; + second + &quot;)&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TwoTuple&lt;String, Integer&gt; ttsi = new TwoTuple&lt;&gt;(&quot;hi&quot;, 666);</span><br><span class="line">        System.out.println(ttsi.first);</span><br><span class="line">        System.out.println(ttsi.second);</span><br><span class="line">        System.out.println(ttsi.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">**可以通过继承实现更长的元组：**</span><br></pre></td></tr></table></figure><p>public class ThreeTuple<a, b,="" c=""> extends TwoTuple<a, b=""> {<br>    public final C c;<br>    public ThreeTuple(A a, B b, C c) {<br>        super(a, b);<br>        this.c = c;<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ 泛型实现一个堆栈类  </span><br><span class="line">不使用已有的Stack和LinkedList实现一个堆栈类  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">public class LinkedStack&lt;T&gt; &#123;</span><br><span class="line">    private static class Node&lt;U&gt; &#123;</span><br><span class="line">        U item;</span><br><span class="line">        Node&lt;U&gt; next;</span><br><span class="line">        Node() &#123;</span><br><span class="line">            item = null;</span><br><span class="line">            next = null;</span><br><span class="line">        &#125;</span><br><span class="line">        Node(U item, Node&lt;U&gt; next) &#123;</span><br><span class="line">            this.item = item;</span><br><span class="line">            this.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        boolean end() &#123;</span><br><span class="line">            return item == null &amp;&amp; next == null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Node&lt;T&gt; top = new Node&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void push(T item) &#123;</span><br><span class="line">        top = new Node&lt;&gt;(item, top);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T pop() &#123;</span><br><span class="line">        T result = top.item;</span><br><span class="line">        if (!top.end()) &#123;</span><br><span class="line">            top = top.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></a,></a,></p><h5 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h5><p>泛型也可以应用于接口。如生成器</p><p>接口类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Generator&lt;T&gt; &#123;</span><br><span class="line">    T next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以生成各类咖啡对象为例，这里准备一些Coffee类：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Coffee &#123;</span><br><span class="line">    private static long counter = 0;</span><br><span class="line">    private final long id = counter++;</span><br><span class="line"></span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return getClass().getSimpleName() + &quot; &quot; + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Americano extends Coffee &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Breve extends Coffee &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Cappuccino extends Coffee &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Latte extends Coffee &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Mocha extends Coffee &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写CoffeeGenerator类实现Generator<coffee>接口，随机生成不同类型的Coffee对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class CoffeeGenerator implements Generator&lt;Coffee&gt;, Iterable&lt;Coffee&gt;&#123;</span><br><span class="line"></span><br><span class="line">    private Class[] types = &#123;Latte.class, Mocha.class, Cappuccino.class, Americano.class, Breve.class&#125;;</span><br><span class="line">    private static Random rand = new Random(47);</span><br><span class="line"></span><br><span class="line">    public CoffeeGenerator() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int size = 0;</span><br><span class="line"></span><br><span class="line">    public CoffeeGenerator(int sz) &#123;</span><br><span class="line">        this.size = sz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Iterator&lt;Coffee&gt; iterator() &#123;</span><br><span class="line">        return new CoffeeIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Coffee next() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Coffee)types[rand.nextInt(types.length)].newInstance();</span><br><span class="line">        &#125;  catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class CoffeeIterator implements Iterator&lt;Coffee&gt; &#123;</span><br><span class="line">        int count = size;</span><br><span class="line">        @Override</span><br><span class="line">        public Coffee next() &#123;</span><br><span class="line">            count--;</span><br><span class="line">            return CoffeeGenerator.this.next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void remove() &#123;</span><br><span class="line">            throw new UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean hasNext() &#123;</span><br><span class="line">            return count &gt; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CoffeeGenerator gen = new CoffeeGenerator();</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            System.out.println(gen.next());</span><br><span class="line">        &#125;</span><br><span class="line">        for (Coffee c : new CoffeeGenerator(5)) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></coffee></p><h5 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h5><blockquote><p>泛型方法所在的类可以是泛型类，也可以不是泛型类<br>能用泛型方法，尽量不用泛型类，更清楚明白<br>static方法无法使用泛型类的类型参数，static要使用泛型能力，就必须成为泛型方法  </p></blockquote><p>要定义泛型方法，只需将泛型参数列表置于返回值之前：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class GenericMethods &#123;</span><br><span class="line">    public &lt;T&gt; void f(T x) &#123;</span><br><span class="line">        System.out.println(x.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        GenericMethods gm = new GenericMethods();</span><br><span class="line">        gm.f(&quot;&quot;);</span><br><span class="line">        gm.f(1);</span><br><span class="line">        gm.f(1.0);</span><br><span class="line">        gm.f(1.0f);</span><br><span class="line">        gm.f(&apos;c&apos;);</span><br><span class="line">        gm.f(gm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ 类型参数推断  </span><br><span class="line">当使用泛型类时，必须在创建对象的时候指定类型参数的值，而使用泛型方法的时候，通常不必指明参数类型，因为编译器会为我们找出具体的类型。  </span><br><span class="line"></span><br><span class="line">+ 可变参数与泛型方法  </span><br><span class="line">泛型方法与可变参数列表可以很好的共存  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">public class GenericVarargs &#123;</span><br><span class="line">    public static &lt;T&gt; List&lt;T&gt; makeList(T... args) &#123;</span><br><span class="line">        List&lt;T&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        for (T item : args) &#123;</span><br><span class="line">            result.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; ls = makeList(&quot;A&quot;);</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">        ls = makeList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">        ls = makeList(&quot;ABCDEFGHIJKLMNOPQ&quot;.split(&quot;&quot;));</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="泛型应用到内部类及匿名内部类"><a href="#泛型应用到内部类及匿名内部类" class="headerlink" title="泛型应用到内部类及匿名内部类"></a>泛型应用到内部类及匿名内部类</h5><p>Customer和Teller只有private构造器，必须使用Generator对象。Customer中generator方法，每次生成一个Generator<customer>对象。<br>其实不需要这么多Generator对象，Teller只创建了一个public的generator对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Customer &#123;</span><br><span class="line">    private static long counter = 1;</span><br><span class="line">    private final long id = counter++;</span><br><span class="line">    private Customer() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Customer &quot; + id;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Generator&lt;Customer&gt; generator() &#123;</span><br><span class="line">        return new Generator&lt;Customer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Customer next() &#123;</span><br><span class="line">                return new Customer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Teller &#123;</span><br><span class="line">    private static long counter = 1;</span><br><span class="line">    private final long id = counter++;</span><br><span class="line"></span><br><span class="line">    private Teller() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;teller: &quot; + id;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Generator&lt;Teller&gt; generator =</span><br><span class="line">            new Generator&lt;Teller&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public Teller next() &#123;</span><br><span class="line">                    return new Teller();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BankTeller &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></customer></p><h5 id="擦除的神秘之处"><a href="#擦除的神秘之处" class="headerlink" title="擦除的神秘之处"></a>擦除的神秘之处</h5><p>ArrayList<string>和ArrayList<integer>很容易被认为是不同的类型，其实不然：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">public class ErasedTypeEquivalence &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Class c1 = new ArrayList&lt;String&gt;().getClass();</span><br><span class="line">        Class c2 = new ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">        System.out.println(c1 == c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line">上面运行返回true，下面示例是解答：  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">class Frob &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Fnorkle &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Quark&lt;Q&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Particle&lt;POSITION, MOMENTUM&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class LostInformation &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Frob&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;Frob, Fnorkle&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        Quark&lt;Fnorkle&gt; quark = new Quark&lt;&gt;();</span><br><span class="line">        Particle&lt;Long, Double&gt; p = new Particle&lt;&gt;();</span><br><span class="line">        System.out.println(Arrays.toString(list.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(map.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(quark.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(p.getClass().getTypeParameters()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/* Output</span><br><span class="line">[E]</span><br><span class="line">[K, V]</span><br><span class="line">[Q]</span><br><span class="line">[POSITION, MOMENTUM]</span><br><span class="line">*///:~</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; Class.getTypeParameters()将返回一个TypeVariable对象数组，表示有泛型声明所声明的类型参数。但是从输出可以看出，返回的仅仅的是参数占位符并不是具体的参数类型。  </span><br><span class="line">&gt; Java泛型是使用擦除实现的，但使用泛型时，任何具体的类型信息都被擦除了。因此List&lt;String&gt;和List&lt;Integer&gt;在运行时是相同的类型，因为运行时都被擦除为原生类型即List。</span><br><span class="line"></span><br><span class="line">##### 擦除的补偿  </span><br><span class="line">为了确定参数类型，通过显示的传递类型的Class对象。  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">class Building &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class House extends Building &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class ClassTypeCapture&lt;T&gt; &#123;</span><br><span class="line">    Class&lt;T&gt; kind;</span><br><span class="line"></span><br><span class="line">    public ClassTypeCapture(Class&lt;T&gt; kind) &#123;</span><br><span class="line">        this.kind = kind;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean f(Object arg) &#123;</span><br><span class="line">        return kind.isInstance(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ClassTypeCapture&lt;Building&gt; ctt1 = new ClassTypeCapture&lt;&gt;(Building.class);</span><br><span class="line">        System.out.println(ctt1.f(new Building()));</span><br><span class="line">        System.out.println(ctt1.f(new House()));</span><br><span class="line">        ClassTypeCapture&lt;House&gt; ctt2 = new ClassTypeCapture&lt;&gt;(House.class);</span><br><span class="line">        System.out.println(ctt2.f(new Building()));</span><br><span class="line">        System.out.println(ctt2.f(new House()));</span><br><span class="line">    &#125;</span><br><span class="line">    /*output</span><br><span class="line">    true</span><br><span class="line">    true</span><br><span class="line">    false</span><br><span class="line">    true</span><br><span class="line">     */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></integer></string></p><h5 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h5><p>为了将泛型参数限定为某个类型子集，那么你就可以用这些类型子集来调用方法。为了执行限制，java泛型重用了extends关键字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">interface HasColor &#123;</span><br><span class="line">    Color getColor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Colored&lt;T extends HasColor&gt; &#123;</span><br><span class="line">    T item;</span><br><span class="line"></span><br><span class="line">    Colored(T item) &#123;</span><br><span class="line">        this.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T getItem() &#123;</span><br><span class="line">        return item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Color color() &#123;</span><br><span class="line">        return item.getColor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dimension &#123;</span><br><span class="line">    public int x,y, z;</span><br><span class="line">&#125;</span><br><span class="line">class ColoredDimension&lt;T extends Dimension &amp; HasColor&gt;&#123;</span><br><span class="line">    T item;</span><br><span class="line"></span><br><span class="line">    ColoredDimension(T item) &#123;</span><br><span class="line">        this.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T getItem() &#123;</span><br><span class="line">        return item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Color color() &#123;</span><br><span class="line">        return item.getColor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getX() &#123;</span><br><span class="line">        return item.x;</span><br><span class="line">    &#125;</span><br><span class="line">    int getY() &#123;</span><br><span class="line">        return item.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getZ() &#123;</span><br><span class="line">        return item.z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Weight &#123;</span><br><span class="line">    int weight();</span><br><span class="line">&#125;</span><br><span class="line">class Solid&lt;T extends Dimension &amp; HasColor &amp; Weight&gt;&#123;</span><br><span class="line">    T item;</span><br><span class="line"></span><br><span class="line">    Solid(T item) &#123;</span><br><span class="line">        this.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T getItem() &#123;</span><br><span class="line">        return item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Color color() &#123;</span><br><span class="line">        return item.getColor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getX() &#123;</span><br><span class="line">        return item.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getY() &#123;</span><br><span class="line">        return item.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getZ() &#123;</span><br><span class="line">        return item.z;</span><br><span class="line">    &#125;</span><br><span class="line">    int weight() &#123;</span><br><span class="line">        return item.weight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bounded extends Dimension implements HasColor, Weight &#123;</span><br><span class="line">   public Color getColor() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int weight() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class BasicBounds &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Solid&lt;Bounded&gt; solid = new Solid&lt;&gt;(new Bounded());</span><br><span class="line">        solid.color();</span><br><span class="line">        solid.getY();</span><br><span class="line">        solid.weight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h5><p>如下方式在编译器中是不通过的：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class NonCovariantGenerics &#123;</span><br><span class="line">//    List&lt;Fruit&gt; flist = new ArrayList&lt;Apple&gt;();//编译错误</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通配符为?，例如 <code>List&lt;? extends Fruit&gt;</code> 指具有任何从Fruit继承的类型的列表。但最终需要具体的继承自Fruit的对象数组被该引用所引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class GenericsAndCovariance &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;? extends Fruit&gt; flist = new ArrayList&lt;Apple&gt;(); //一旦向上转型就不能添加任何对象，不过可以将任何继承自Fruit的list对象数组赋值给该数组</span><br><span class="line">        //下面编译出错，不能添加任何对象</span><br><span class="line">//        flist.add(new Apple());</span><br><span class="line">//        flist.add(new Fruit());</span><br><span class="line">//        flist.add(new Object());</span><br><span class="line">//        flist.add(null);//合法但无意义</span><br><span class="line">        Fruit f = flist.get(0);</span><br><span class="line"></span><br><span class="line">        flist.clear();</span><br><span class="line">        List&lt;Apple&gt; appleList = new ArrayList&lt;&gt;();</span><br><span class="line">        appleList.add(new Apple());</span><br><span class="line">        flist = appleList;</span><br><span class="line">        Fruit fruit = flist.get(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>超类型通配符<br>可以声明通配符是由某个特定类的任何基类来界定的，方法是指定 <code>&lt;? super MyClass&gt;</code>，甚至或者使用类型参数：&lt;? super T&gt;，但不能声明 <code>T super MyClass</code>。  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class SuperTypeWildCards &#123;</span><br><span class="line">    static void writeTo(List&lt;? super Apple&gt; apples) &#123;</span><br><span class="line">        apples.add(new Apple());</span><br><span class="line">        apples.add(new Jonathan());</span><br><span class="line">        // apples.add(new Fruit()); // Error</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>无界通配符<br>无界通配符&lt;?&gt;意味着 “任何事物”，因此使用无界通配符好像等价于使用原生类型。事实上，编译器是支持这种判断的。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class UnboundedWildcards1 &#123;</span><br><span class="line">    static List list1;</span><br><span class="line">    static List&lt;?&gt; list2;</span><br><span class="line">    static List&lt;? extends Object&gt; list3;</span><br><span class="line">    static void assign1(List list) &#123;</span><br><span class="line">        list1 = list;</span><br><span class="line">        list2 = list;</span><br><span class="line">        list3 = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void assign2(List&lt;?&gt; list) &#123;</span><br><span class="line">        list1 = list;</span><br><span class="line">        list2 = list;</span><br><span class="line">        list3 = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void assign3(List&lt;? extends Object&gt; list) &#123;</span><br><span class="line">        list1 = list;</span><br><span class="line">        list2 = list;</span><br><span class="line">        list3 = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        assign1(new ArrayList());</span><br><span class="line">        assign2(new ArrayList());</span><br><span class="line">        assign3(new ArrayList());</span><br><span class="line">        assign1(new ArrayList&lt;String&gt;());</span><br><span class="line">        assign2(new ArrayList&lt;String&gt;());</span><br><span class="line">        assign3(new ArrayList&lt;String&gt;());</span><br><span class="line"></span><br><span class="line">        List&lt;?&gt; wildList = new ArrayList();</span><br><span class="line">        wildList = new ArrayList&lt;String&gt;();</span><br><span class="line">        assign1(wildList);</span><br><span class="line">        assign2(wildList);</span><br><span class="line">        assign3(wildList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ul><li>任何基本类型不能用作类型参数，不如不能创建 <code>ArrayList&lt;Integer&gt;</code>  </li><li><p>一个类不能实现同一个泛型接口的两种变体<br>下面的写法会产生冲突：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Payable&lt;T&gt; &#123;&#125;</span><br><span class="line">class Employee implements Payable&lt;Employee&gt; &#123;&#125;</span><br><span class="line">class Hourly extends Employee implements Payable&lt;Hourly&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>转型和警告<br>使用带有泛型类型参数的转型或instanceof不会有任何效果。  </p></li><li>重载<br>由于擦除的原因，重载方法将产生相同的类型签名。  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class UseList&lt;W, T&gt; &#123;</span><br><span class="line">    void f(List&lt;T&gt; v) &#123;&#125;;</span><br><span class="line">    void f(List&lt;W&gt; v) &#123;&#125;;//两种方法签名一样</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自限定的类型<br><code>class SelfBounded&lt;T extends SelfBounded&lt;T&gt;&gt; {</code> SelfBounded类接受泛型参数T，而T由一个边界类限定，这个边界就是拥有T作为其参数的SelfBounded。<br>它强调的是当extends关键字用于边界与用来创建子类明显是不同的。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;泛型正如其名称暗示的：它是一种方法，通过它可以写出更泛化的代码，这些代码对于它们所操作的类型有更少的限制，因此单个代码段可以应用到更多的类型上，减少重复编码。&lt;br&gt;
    
    </summary>
    
    
      <category term="编程思想" scheme="https://dongme.site/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>java编程思想[14]-RTTI</title>
    <link href="https://dongme.site/2018/08/16/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-14/"/>
    <id>https://dongme.site/2018/08/16/java编程思想-14/</id>
    <published>2018-08-16T10:13:00.000Z</published>
    <updated>2018-10-15T14:27:27.232Z</updated>
    
    <content type="html"><![CDATA[<p>RTTI，运行时类型信息。可以使你在程序运行时发现和使用类型信息。<br><a id="more"></a>  </p><h4 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h4><hr><p><strong>RTTI：</strong>Runtime Type Identification，即运行时类型识别。</p><h5 id="class-对象"><a href="#class-对象" class="headerlink" title="class 对象"></a>class 对象</h5><ul><li>class对象就是用来创建类的所有常规对象的，每个类都有一个class对象。换言之，每当编写并且编译了一个新类，就会产生一个class对象  </li><li>类中static成员初始化，是在类加载时进行的，<code>Class.forName(&quot; 类名 &quot;)</code>根据类名获取类对象，需要try块  </li><li>在知道具体的类型的对象时，获取类对象通过 <code>getClass()</code>方法  </li><li>类字面常量：java提供的另一种方法来生产class对象的引用。类似：<code>FancyToy.class</code>，该方式编译时受到检查，更简单，更安全  </li><li>类字面变量不仅可以应用于普通类，也可以应用于接口、数组以及基本数据类型  </li><li><p>使用 <code>.class</code>来创建class对象引用时，不会自动地初始化该Class对象，为使用类需做如下准备：  </p><ol><li>加载，由类加载器执行的。查找字节码（.class文件），并从字节码中创建一个Class对象</li><li>链接，该阶段将验证类中字节码，为静态域分配存储空间，如果必需的话，将解析这个类创建的对其它类的所有引用</li><li>初始化，若该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。首次引用静态方法（构造器隐式静态）或非常数静态域才执行初始化。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Initable</span> </span>&#123;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> staticFianl = <span class="number">47</span>;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> staticFinal2 = ClassInitialzation.rand.nextInt(<span class="number">1000</span>);</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">static</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">"Initializing Initable"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Initable2</span> </span>&#123;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">int</span> staticNoFinal = <span class="number">147</span>;</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">static</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">"Initializing Initable2"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Initable3</span> </span>&#123;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">int</span> staticNoFinal = <span class="number">74</span>;</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">static</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">"Initializing Initable3"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInitialzation</span> </span>&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">   </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">           Class initable = Initable.class;</span><br><span class="line">           System.out.println(<span class="string">"After creating Initable ref"</span>);</span><br><span class="line">           <span class="comment">//不触发初始化</span></span><br><span class="line">           System.out.println(Initable.staticFianl);</span><br><span class="line">           <span class="comment">//触发初始化</span></span><br><span class="line">           System.out.println(Initable.staticFinal2);</span><br><span class="line">           <span class="comment">//触发初始化</span></span><br><span class="line">           System.out.println(Initable2.staticNoFinal);</span><br><span class="line">           <span class="comment">//触发初始化</span></span><br><span class="line">           Class initable3 = Class.forName(<span class="string">"me.donge.factorypackage.Initable3"</span>);</span><br><span class="line">           System.out.println(<span class="string">"Afer creating Initable3 ref"</span>);</span><br><span class="line">           <span class="comment">//已经被初始化过的 不会再次触发初始化</span></span><br><span class="line">           System.out.println(Initable3.staticNoFinal);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  ```  </span><br><span class="line">+ 泛化的Class引用  </span><br><span class="line">  <span class="number">1</span>. 使用泛化的Class引用时放松限制，使用通配符，<span class="string">"?"</span>表示任何事物</span><br></pre></td></tr></table></figure><p>Class&lt;?&gt; intClass = int.class;<br>intClass = double.class;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. `newInstance()`方法可以创建某个类类型的实例对象</span><br></pre></td></tr></table></figure><p>Class<integer> intClass = int.class;<br>int a = intClass.newInstance();</integer></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">3. 类型转换前先做检查  </span><br><span class="line">**3.1 RTTI形式：**  </span><br><span class="line">3.1.1 传统的类型转换，即强制类型转换，如果执行了一个错误的类型转换，就会抛出一个ClassCastException异常。  </span><br><span class="line">3.1.2 代表对象的类型的Class对象。通过查询Class对象可以获取运行时所需的信息。  </span><br><span class="line">3.1.3 instanceof关键字，如判断x对象实例变量是否属于类Apple的实例，使用 `x instanceof Apple` 返回true or false，该方式不推荐使用，</span><br><span class="line">该方式只可将其与命名类进行比较，而不能与Class对象作比较。  </span><br><span class="line">但是 instanceof 在 java 的编译状态和运行状态是有区别的：  </span><br><span class="line">在编译状态中 class 可以是 object 对象的父类、自身类、子类，在这三种情况下 java 编译时不会报错；    </span><br><span class="line">在运行转态中 class 可以是 object 对象的父类、自身类，但不能是子类，当为父类、自身类的情况下 result 结果为 true，为子类的情况下为 false。  </span><br><span class="line">3.1.4 动态的instanceof  </span><br><span class="line">Class.isInstance方法提供了一种动态地测试对象的方法，可替换单调的instanceof语句。语法：`class.isInstance(obj)`，表明这个对象能不能</span><br><span class="line">被转化为这个类  </span><br><span class="line">**3.2 反射：运行时的类信息 **  </span><br><span class="line">RTTI和反射的区别在于，对RTTI来说，编译器在编译时打开和检查.class文件（可以用普通方式调用对象所有方法）；对于反射机制来说，.class文件在</span><br><span class="line">编译时是不可获取的，所以是在运行时打开和检查.class文件。  </span><br><span class="line">3.2.1 类方法提取器  </span><br><span class="line">3.2.1.1 提取类方法包括基类的方法</span><br></pre></td></tr></table></figure><p>Class&lt;?&gt; c = Class.forName(args[0]);<br>Method[] methods = c.getMethods();<br>Constructor[] ctors = c.getConstructors();</p><pre><code>3.2.1.2 动态代理  不直接操作实际对象，而是通过代理对象简介操作实际对象，充当着中间人的角色。</code></pre><p>interface Interface {</p><pre><code>void doSomething();void somethingElse(String arg);</code></pre><p>}</p><p>class RealObject implements Interface {</p><pre><code>@Overridepublic void doSomething() {    System.out.println(&quot;doSomething&quot;);}@Overridepublic void somethingElse(String arg) {    System.out.println(&quot;somethingElse &quot; + arg);}</code></pre><p>}</p><p>class SimpleProxy implements Interface {</p><pre><code>private Interface proxied;public SimpleProxy(Interface proxied) {    this.proxied = proxied;}@Overridepublic void doSomething() {    System.out.println(&quot;SimpleProxy doSomething&quot;);    proxied.doSomething();}@Overridepublic void somethingElse(String arg) {    System.out.println(&quot;SimpleProxy somethingElse &quot; + arg);    proxied.somethingElse(arg);}</code></pre><p>}</p><p>class SimpleProxyDemo {</p><pre><code>public static void consumer(Interface iface) {    iface.doSomething();    iface.somethingElse(&quot;bonobo&quot;);}public static void main(String[] args) {    consumer(new RealObject());    consumer(new SimpleProxy(new RealObject()));}</code></pre><p>}<br>```  </p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RTTI，运行时类型信息。可以使你在程序运行时发现和使用类型信息。&lt;br&gt;
    
    </summary>
    
    
      <category term="编程思想" scheme="https://dongme.site/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>java编程思想[10-13]-内部类、持有对象、异常</title>
    <link href="https://dongme.site/2018/08/16/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-10-13/"/>
    <id>https://dongme.site/2018/08/16/java编程思想-10-13/</id>
    <published>2018-08-16T09:52:00.000Z</published>
    <updated>2018-10-15T14:30:55.212Z</updated>
    
    <content type="html"><![CDATA[<p>继续看java编程思想，这篇主要记录了书中第十章：内部类、第十一章：持有对象、第十二章：通过异常处理错误中的碎片知识。<br><a id="more"></a>  </p><h4 id="1-内部类"><a href="#1-内部类" class="headerlink" title="1.内部类"></a>1.内部类</h4><ul><li>内部类拥有对外部类所有元素的访问权限</li><li>利用内部类实现迭代器模式  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Selector</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">current</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sequence</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        items = <span class="keyword">new</span> Object[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.items[next++] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceSelector</span> <span class="keyword">implements</span> <span class="title">Selector</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i == items.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">current</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> items[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; items.length) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Selector <span class="title">selector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SequenceSelector();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Sequence sequence = <span class="keyword">new</span> Sequence(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            sequence.add(Integer.toString(i));</span><br><span class="line">        &#125;</span><br><span class="line">        Selector selector = sequence.selector();</span><br><span class="line">        <span class="keyword">while</span> (!selector.end()) &#123;</span><br><span class="line">            System.out.println(selector.current() + <span class="string">" "</span>);</span><br><span class="line">            selector.next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>内外类互调，假如Outer为外部类，Inner为内部类<br><strong>内部类调用外部类:</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Outer outer = Outer.this;</span><br></pre></td></tr></table></figure><p> <strong>外部类调用内部类</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">外部类调用:</span><br><span class="line">Inner inner = new Inner();</span><br><span class="line"></span><br><span class="line">其它类调用:</span><br><span class="line">Outer.Inner inner = new Outer.Inner();//内部类为static才可以这样创建</span><br><span class="line">或</span><br><span class="line">Outer outer = new Outer();//通用</span><br><span class="line">Outer.Inner inner = outer.new Inner();</span><br></pre></td></tr></table></figure></p><ul><li>在方法和作用域内的内部类  <blockquote><p>作用:实现了某类型的接口，于是可以创建并返回对其的引用；需要解决一个复杂问题，想创建一个辅助类解决，又不想该类暴露出去；内部类使多重继承更加丰富。</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> public interface Destination &#123;</span><br><span class="line">    String readLabel();</span><br><span class="line">&#125;</span><br><span class="line">public interface Contents &#123;</span><br><span class="line">    int value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1) 一个定义在方法中的类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Parcel5 &#123;</span><br><span class="line">    public Destination destination(String s) &#123;</span><br><span class="line">        class PDestination implements Destination &#123;</span><br><span class="line">            private String label;</span><br><span class="line"></span><br><span class="line">            private PDestination(String whereTo) &#123;</span><br><span class="line">                label = whereTo;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public String readLabel() &#123;</span><br><span class="line">                return label;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new PDestination(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Parcel5 parcel5 = new Parcel5();</span><br><span class="line">        Destination destination = parcel5.destination(&quot;alvin&quot;);</span><br><span class="line">        System.out.println(destination.readLabel());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 2) 一个定义在作用域内的类，此作用域在方法的内部</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> public class Parcel6 &#123;</span><br><span class="line">    private void internalTracking(boolean b) &#123;</span><br><span class="line">        if (b) &#123;</span><br><span class="line">            class TrackingSlip &#123;</span><br><span class="line">                private String id;</span><br><span class="line"></span><br><span class="line">                TrackingSlip(String s) &#123;</span><br><span class="line">                    id = s;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                String getSlip() &#123;</span><br><span class="line">                    return id;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            TrackingSlip ts = new TrackingSlip(&quot;slip&quot;);</span><br><span class="line">            String s = ts.getSlip();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void track() &#123;</span><br><span class="line">        internalTracking(true);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Parcel6 parcel6 = new Parcel6();</span><br><span class="line">        parcel6.track();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 3) 实现了接口的匿名类<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> public class Parcel7 &#123;</span><br><span class="line">    public Contents contents() &#123;</span><br><span class="line">        return new Contents() &#123;</span><br><span class="line">            private int i = 11;</span><br><span class="line"></span><br><span class="line">            public int value() &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Parcel7 parcel7 = new Parcel7();</span><br><span class="line">        Contents contents = parcel7.contents();</span><br><span class="line">        System.out.println(contents.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 等价于</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Parcel7b &#123;</span><br><span class="line">    class MyContents implements Contents &#123;</span><br><span class="line">        private int i = 11;</span><br><span class="line"></span><br><span class="line">        public int value() &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public Contents contents() &#123;</span><br><span class="line">        return new MyContents();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Parcel7b parcel7b = new Parcel7b();</span><br><span class="line">        Contents contents = parcel7b.contents();</span><br><span class="line">        System.out.println(contents.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 4) 一个匿名类，它扩展了具有非默认构造器的类<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> public class Parcel8 &#123;</span><br><span class="line">    public Wrapping wrapping(int x) &#123;</span><br><span class="line">        return new Wrapping(x) &#123;</span><br><span class="line">            public int value() &#123;</span><br><span class="line">                return super.value() * 47;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Parcel8 parcel8 = new Parcel8();</span><br><span class="line">        Wrapping wrapping = parcel8.wrapping(10);</span><br><span class="line">        System.out.println(wrapping.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 尽管Wrapping只是一个具有具体实现的普通类，但它还是被其导出类当做”公共接口”使用:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> public class Wrapping &#123;</span><br><span class="line">    private int i;</span><br><span class="line">    public Wrapping(int x) &#123;</span><br><span class="line">        i = x;</span><br><span class="line">    &#125;</span><br><span class="line">    public int value() &#123;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 5）一个匿名类，它执行字段初始化<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> public class Parcel9 &#123;</span><br><span class="line">    public Destination destination(final String dest) &#123;</span><br><span class="line">        return new Destination() &#123;</span><br><span class="line">            private String label = dest;</span><br><span class="line">            @Override</span><br><span class="line">            public String readLabel() &#123;</span><br><span class="line">                return dest;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Parcel9 parcel9 = new Parcel9();</span><br><span class="line">        Destination destination = parcel9.destination(&quot;alvin&quot;);</span><br><span class="line">        System.out.println(destination.readLabel());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>内部类使用外部对象作为参数，要将参数声明为final类型，否则编译报错。注意必须内部类内部使用到才必须声明为final。</p></blockquote><p> 6）一个匿名类，它通过实例初始化实现构造(匿名类不可能有匿名构造器)<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">abstract class Base &#123;</span><br><span class="line">    public Base(int i) &#123;</span><br><span class="line">        System.out.println(&quot;Base Constructor. i=&quot; + i);</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract void f();</span><br><span class="line">&#125;</span><br><span class="line">public class AnonymousConstructor &#123;</span><br><span class="line">    public static Base getBase(int i) &#123;</span><br><span class="line">        return new Base(i) &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(&quot;Inside instance initializer&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            public void f() &#123;</span><br><span class="line">                System.out.println(&quot;In anonymous f()&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Base base = getBase(47);</span><br><span class="line">        base.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>匿名内部类实现工厂方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"> interface Service &#123;</span><br><span class="line">    void method1();</span><br><span class="line"></span><br><span class="line">    void method2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface ServiceFactory &#123;</span><br><span class="line">    Service getService();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Implementation1 implements Service &#123;</span><br><span class="line">    public void method1() &#123;</span><br><span class="line">        System.out.println(&quot;Implementation1 method1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void method2() &#123;</span><br><span class="line">        System.out.println(&quot;Implementation1 method2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static ServiceFactory factory = new ServiceFactory() &#123;</span><br><span class="line">        public Service getService() &#123;</span><br><span class="line">            return new Implementation1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">class Implementation2 implements Service &#123;</span><br><span class="line">    public void method1() &#123;</span><br><span class="line">        System.out.println(&quot;Implementation2 method1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void method2() &#123;</span><br><span class="line">        System.out.println(&quot;Implementation2 method2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static ServiceFactory factory = new ServiceFactory() &#123;</span><br><span class="line">        public Service getService() &#123;</span><br><span class="line">            return new Implementation2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">public class Factories &#123;</span><br><span class="line">    public static void serviceConsumer(ServiceFactory factory) &#123;</span><br><span class="line">        Service s = factory.getService();</span><br><span class="line">        s.method1();</span><br><span class="line">        s.method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        serviceConsumer(Implementation1.factory);</span><br><span class="line">        serviceConsumer(Implementation2.factory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>嵌套类</li></ul><blockquote><p>如果不需要内部类对象与其外围类对象之间有联系，那么可以将内部类声明为static.即为嵌套类<br>普通的内部类对象隐式地保存了一个引用，指向创建它的外围类对象。然而，当内部类是static时，就不是这样了。</p></blockquote><p>嵌套类意味着:<br>1) 要创建嵌套类的对象，并不需要其外围类的对象。<br>2）不能从嵌套类的对象中访问非静态的外围类对象。<br>3）普通的内部类不能有static数据和static字段，也不能包含嵌套类。但嵌套类可以。</p><p><strong>接口中的内部类</strong><br>放到接口中的任何类都是public和static的。嵌套类可以作为接口的一部分。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public interface ClassInInterface &#123;</span><br><span class="line">    void howdy();</span><br><span class="line"></span><br><span class="line">    class Test implements ClassInInterface &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void howdy() &#123;</span><br><span class="line">            System.out.println(&quot;howdy&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">            new Test().howdy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接口中的内部类，可以被所有实现共用。</p><ul><li>内部类存是多态性的体现，变向的实现了多重继承，外部类的继承或实现对内部类没有影响</li><li><p>闭包和回调<br><strong>闭包</strong><br>是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。内部类属于面向对象的闭包（隐式外部类对象引用）<br><strong>内部类闭包实现回调</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Callee1</span> <span class="keyword">implements</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIncrement</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"other operation"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(MyIncrement mi)</span> </span>&#123;</span><br><span class="line">        mi.increment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Callee2</span> <span class="keyword">extends</span> <span class="title">MyIncrement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.increment();</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure</span> <span class="keyword">implements</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Callee2.<span class="keyword">this</span>.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Incrementable <span class="title">getCallbackReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Closure();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Caller</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Incrementable callbackReference;</span><br><span class="line"></span><br><span class="line">    Caller(Incrementable cbh) &#123;</span><br><span class="line">        callbackReference = cbh;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        callbackReference.increment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Callbacks</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Callee1 c1 = <span class="keyword">new</span> Callee1();</span><br><span class="line">        Callee2 c2 = <span class="keyword">new</span> Callee2();</span><br><span class="line">        MyIncrement.f(c2);</span><br><span class="line">        Caller caller1 = <span class="keyword">new</span> Caller(c1);</span><br><span class="line">        Caller caller2 = <span class="keyword">new</span> Caller(c2.getCallbackReference());</span><br><span class="line">        caller1.go();</span><br><span class="line">        caller1.go();</span><br><span class="line">        caller2.go();</span><br><span class="line">        caller2.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>内部类与控制框架</p></li></ul><p><strong>应用程序框架:</strong></p><blockquote><p>就是被设计用以解决某类特定问题的一个类或一组类。<br>要运用某个应用框架，通常是继承一个或多个类，并覆盖某些方法。在覆盖后的方法中，编写代码定制应用程序框架提供的通用解决方案，以解决特定问题—设计模式中模板方法的例子</p></blockquote><p><strong>控制框架:</strong></p><blockquote><p>一类特殊的应用程序框架，用来解决响应事件的需求。主要用来响应事件的系统被称作事件驱动系统。实例:java swing</p></blockquote><p><strong>内部类使用控制框架</strong></p><ul><li><p>内部类的继承<br>因为内部类的构造器必须连接到指向其外围类对象引用，所以在继承内部类的时候要有一些特殊处理。在导出类中不存在可连接的默认对象，而指向外围类对象的隐秘引用必须被初始化。具体处理继承类构造器中添加<br><code>enclosingClassReference.super()</code> enclosingClassReference是外围类对象如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithInner</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritInner</span> <span class="keyword">extends</span> <span class="title">WithInner</span>.<span class="title">Inner</span></span>&#123;</span><br><span class="line">    InheritInner(WithInner wi)&#123;</span><br><span class="line">        wi.<span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WithInner wi = <span class="keyword">new</span> WithInner();</span><br><span class="line">        InheritInner ii = <span class="keyword">new</span> InheritInner(wi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>内部类的覆盖并无卵用</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Egg</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Yolk y;</span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Egg.Yolk()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Egg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"New Egg()"</span>);</span><br><span class="line">        <span class="keyword">this</span>.y = <span class="keyword">new</span> Yolk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigEgg</span> <span class="keyword">extends</span> <span class="title">Egg</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"BigEgg.Yolk()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> BigEgg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出当继承了某个外围类的时候，内部类并没有发生什么变化。这两个内部类是完全独立的实体，各自在自己的命名空间里。</p><ul><li>局部内部类<br>局部内部类不能有访问修饰符，因为它不是外围类的一部分；但是它可以访问当前代码块内的常量，以及此外围类的所有成员。<br>下面对局部内部类和匿名内部类做比较:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalnnerClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function">Counter <span class="title">getCounter</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">LocalCounter</span> <span class="keyword">implements</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">LocalCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"LocalCounter()"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(name);</span><br><span class="line">                <span class="keyword">return</span> count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LocalCounter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Counter <span class="title">getCounter2</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Counter() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">"Counter()"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> count ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalnnerClass lic = <span class="keyword">new</span> LocalnnerClass();</span><br><span class="line">        Counter</span><br><span class="line">                c1 = lic.getCounter(<span class="string">"Local inner"</span>),</span><br><span class="line">                c2 = lic.getCounter2(<span class="string">"Anonymous inner"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(c1.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(c2.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>使用局部内部类而不使用匿名类的理由如下:<br>1）需要构造器，或需要重载构造器<br>2）需要不止一个该内部类对象</p><ul><li><p>内部类标示符<br><code>外围类的名字 + &quot;$&quot; + 内部类名字 + &quot;.class&quot;</code></p><h4 id="2-持有对象"><a href="#2-持有对象" class="headerlink" title="2.持有对象"></a>2.持有对象</h4></li><li><p>使用 <code>@SuppressWarnings(unchecked)</code>注解及其参数来抑制”不受检查的异常”的警告信息</p></li><li>容器使用泛型可以在编译期防止将错误的类型对象放入到容器中</li><li>Arrays.asList()可接受数组或逗号分隔的元素列表，转换为List对象</li><li>Collection.addAll()方法接受一个Collection对象，以及一个数组或逗号分隔的列表</li><li>Collection的构造器可以接受另一个Collection，用来将自身初始化，`Collection<integer> cellection = new ArrayList<integer>(Arrays.asList(1,2,3,4,5))，但Collection.addAll()速度快是首选;</integer></integer></li><li><p>List<br>1）基本的ArrayList，它长于随机访问元素，但在List中间插入和移除元素时较慢<br>2）LinkedList，执行插入和删除的速度比较快，提供优化的顺序访问，随机访问方面比较慢  </p><p><strong>subList:</strong> 从较大列表截取片断列表，对所返回的列表的修改会反映到初始列表中，反之亦然。<br><strong>retainAll():</strong> 是一种有效的交际操作，所产生的行为依赖于equals方法<br><strong>removeAll():</strong> 也是基于equals方法，移除List中所有元素<br><strong>set():</strong> 替换制定索引处的元素<br><strong>toArray():</strong> 可以将List或其他Collection转换为数组  </p></li><li><p>迭代器<br><strong>Iterator</strong></p><p>利用了迭代器设计模式，这个Iterator只能单向移动，如下操作:<br>1）使用方法iterator()要求容器返回一个Iterator。Iterator将准备好返回序列中的第一个元素<br>2）使用next()获取序列中的下一个元素<br>3）使用hasNext()检查序列中是否还有元素<br>4）使用remove将迭代器新近返回的元素删除<br>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleIteration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">int</span> in = iterator.next();</span><br><span class="line">            System.out.println(in);</span><br><span class="line">        &#125;</span><br><span class="line">        iterator = list.iterator();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">            iterator.remove();<span class="comment">//移除由next()产生的最后一个元素，调用romove()之前必须先调用next()</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>注意:这里有个坑这里用<code>new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3, 4, 5, 6));</code> 如果直接用<code>Arrays.asList(1, 2, 3, 4, 5, 6)</code>会报java.lang.UnsupportedOperationException的错误，原因是@return a list view of the specified array意思是<br>返回一个固定大小的数组。自然不支持add和remove操作。</p><p><strong>ListIterator</strong><br>ListIterator是一个更加强大的iterator的子类型，它只能用于各种List访问；可以双向移动；可以产生迭代器在列表中指向的当前位置的前一个和后一个元素的索引，并且可以使用set()方法替换它访问过的最后一个元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListIteration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line">        ListIterator&lt;Integer&gt; listIterator = list.listIterator();</span><br><span class="line">        <span class="keyword">while</span> (listIterator.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">int</span> in = listIterator.next();</span><br><span class="line">            System.out.println(in + <span class="string">","</span> + listIterator.nextIndex() + <span class="string">","</span> + listIterator.previousIndex());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// backwards</span></span><br><span class="line">        <span class="keyword">while</span> (listIterator.hasPrevious()) &#123;</span><br><span class="line">            System.out.println(listIterator.previous());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        listIterator = list.listIterator(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">while</span> (listIterator.hasNext()) &#123;</span><br><span class="line">            listIterator.next();</span><br><span class="line">            listIterator.set(<span class="keyword">new</span> Random().nextInt());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>LinkedList<br>LinkedList实现了List接口，但是它执行某些插入和删除操作的时候比ArrayList要高效，在随机访问方面要逊色一些；LinkedList添加了可以用作栈、队列或双端队列的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListFeatures</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        System.out.println(<span class="string">"list.getFirst():"</span> + list.getFirst());<span class="comment">//返回列表第一个元素,列表为空抛出异常</span></span><br><span class="line">        System.out.println(<span class="string">"list.element():"</span> + list.element());<span class="comment">//功能和getFirst()相同，返回列表第一个元素,列表为空抛出异常</span></span><br><span class="line">        System.out.println(<span class="string">"list.peek():"</span> + list.peek());<span class="comment">//返回列表第一个元素，与上面两个区别是列表为空返回null</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"list.remove():"</span> + list.remove()); <span class="comment">//删除并返回列表头，列表为空抛异常</span></span><br><span class="line">        System.out.println(<span class="string">"list.removeFirst():"</span> + list.removeFirst());<span class="comment">//功能通remove()，删除并返回列表头，列表为空抛异常</span></span><br><span class="line">        System.out.println(<span class="string">"list.poll():"</span> + list.poll());<span class="comment">//删除并返回列表头，与remove() 和 removeFirst()区别列表为空返回null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//addFirst() 在头部添加元素</span></span><br><span class="line">        <span class="comment">//offer() 和 add() 和 addLast()相同，它们都将某个元素插入到列表的尾部</span></span><br><span class="line">        <span class="comment">//removeLast() 删除并返回队尾的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Stack</p></li></ul><p>后进先出<br><strong>LinkedList实现的栈:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;T&gt; storage = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T v)</span> </span>&#123;</span><br><span class="line">        storage.addFirst(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> storage.getFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> storage.removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> storage.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> storage.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>原始的栈:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an empty Stack.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pushes an item onto the top of this stack. This has exactly</span></span><br><span class="line"><span class="comment">     * the same effect as:</span></span><br><span class="line"><span class="comment">     * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">     * addElement(item)&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   item   the item to be pushed onto this stack.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  the &lt;code&gt;item&lt;/code&gt; argument.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.util.Vector#addElement</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">push</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">        addElement(item);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the object at the top of this stack and returns that</span></span><br><span class="line"><span class="comment">     * object as the value of this function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  The object at the top of this stack (the last item</span></span><br><span class="line"><span class="comment">     *          of the &lt;tt&gt;Vector&lt;/tt&gt; object).</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  EmptyStackException  if this stack is empty.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        E       obj;</span><br><span class="line">        <span class="keyword">int</span>     len = size();</span><br><span class="line"></span><br><span class="line">        obj = peek();</span><br><span class="line">        removeElementAt(len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Looks at the object at the top of this stack without removing it</span></span><br><span class="line"><span class="comment">     * from the stack.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  the object at the top of this stack (the last item</span></span><br><span class="line"><span class="comment">     *          of the &lt;tt&gt;Vector&lt;/tt&gt; object).</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  EmptyStackException  if this stack is empty.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>     len = size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        <span class="keyword">return</span> elementAt(len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tests if this stack is empty.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  &lt;code&gt;true&lt;/code&gt; if and only if this stack contains</span></span><br><span class="line"><span class="comment">     *          no items; &lt;code&gt;false&lt;/code&gt; otherwise.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the 1-based position where an object is on this stack.</span></span><br><span class="line"><span class="comment">     * If the object &lt;tt&gt;o&lt;/tt&gt; occurs as an item in this stack, this</span></span><br><span class="line"><span class="comment">     * method returns the distance from the top of the stack of the</span></span><br><span class="line"><span class="comment">     * occurrence nearest the top of the stack; the topmost item on the</span></span><br><span class="line"><span class="comment">     * stack is considered to be at distance &lt;tt&gt;1&lt;/tt&gt;. The &lt;tt&gt;equals&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * method is used to compare &lt;tt&gt;o&lt;/tt&gt; to the</span></span><br><span class="line"><span class="comment">     * items in this stack.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   o   the desired object.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  the 1-based position from the top of the stack where</span></span><br><span class="line"><span class="comment">     *          the object is located; the return value &lt;code&gt;-1&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     *          indicates that the object is not on the stack.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = lastIndexOf(o);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> size() - i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1224463164541339165L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>可以看出原始的栈是线程安全的</p></blockquote><ul><li>Set</li></ul><blockquote><p>Set是接口，不保存重复元素，通常选择一个HashSet的实现，它对快速查找进行了优化，发现jdk8版本HashSet可以实现自动排序</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetOfInteger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        Set&lt;Integer&gt; intset = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            intset.add(rand.nextInt(<span class="number">30</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(intset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>HashSet使用的是散列函数，没有顺序。LinkedHashSet因为查询速度的原因也使用了散列，但是它使用了链表来维护元素插入顺序。TreeSet将元素存储在红黑数据结构中</p></blockquote><p><strong>使用TreeSet代替HashSet实现对结果排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortedSetOfInteger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        SortedSet&lt;Integer&gt; intset = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            intset.add(rand.nextInt(<span class="number">30</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(intset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>TreeSet<br>set的contains()和containsAll()，前者是是否包含元素，后者是是否包含集合</p></blockquote><p>TreeSet主要构造方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//默认构造方法，根据其元素的自然顺序进行排序</span><br><span class="line">public TreeSet() &#123;</span><br><span class="line">    this(new TreeMap&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br><span class="line">//构造一个新的空 TreeSet，它根据指定比较器进行排序。</span><br><span class="line">public TreeSet(Comparator&lt;? super E&gt; comparator) &#123;</span><br><span class="line">        this(new TreeMap&lt;&gt;(comparator));</span><br><span class="line">&#125;</span><br><span class="line">//构造一个包含指定 collection 元素的新 TreeSet，它按照其元素的自然顺序进行排序。</span><br><span class="line">public TreeSet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    this();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line">//构造一个与指定有序 set 具有相同映射关系和相同排序的新 TreeSet。</span><br><span class="line">public TreeSet(SortedSet&lt;E&gt; s) &#123;</span><br><span class="line">    this(s.comparator());</span><br><span class="line">    addAll(s);</span><br><span class="line">&#125;</span><br><span class="line">TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;</span><br><span class="line">    this.m = m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>notice:Comparable和Comparator比较:<br>1) 若一个类实现了Comparable接口，就意味着”该类支持排序”。  即然实现Comparable接口的类支持排序，假设现在存在”实现Comparable接口的类的对象的List列表(或数组)”，则该List列表(或数组)可以通过 Collections.sort（或 Arrays.sort）进行排序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假设我们通过 x.compareTo(y) 来“比较x和y的大小”。若返回“负数”，意味着“x比y小”；返回“零”，意味着“x等于y”；返回“正数”，意味着“x大于y”。<br>2）我们若需要控制某个类的次序，而该类本身不支持排序(即没有实现Comparable接口)；那么，我们可以建立一个“该类的比较器”来进行排序。这个“比较器”只需要实现Comparator接口即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>int compare(T o1, T o2) 是“比较o1和o2的大小”。返回“负数”，意味着“o1比o2小”；返回“零”，意味着“o1等于o2”；返回“正数”，意味着“o1大于o2”。</p><p>TreeSet主要方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1、add：将指定的元素添加到此 set（如果该元素尚未存在于 set 中）。</span><br><span class="line">2、addAll：将指定 collection 中的所有元素添加到此 set 中。</span><br><span class="line">3、ceiling：返回此 set 中大于等于给定元素的最小元素；如果不存在这样的元素，则返回 null。</span><br><span class="line">4、clear：移除此 set 中的所有元素。</span><br><span class="line">5、clone：返回 TreeSet 实例的浅表副本。属于浅拷贝。</span><br><span class="line">6、comparator：返回对此 set 中的元素进行排序的比较器；如果此 set 使用其元素的自然顺序，则返回 null。</span><br><span class="line">7、contains：如果此 set 包含指定的元素，则返回 true。</span><br><span class="line">8、descendingIterator：返回在此 set 元素上按降序进行迭代的迭代器。</span><br><span class="line">9、descendingSet：返回此 set 中所包含元素的逆序视图。</span><br><span class="line">10、first：返回此 set 中当前第一个（最低）元素。</span><br><span class="line">11、floor：返回此 set 中小于等于给定元素的最大元素；如果不存在这样的元素，则返回 null。</span><br><span class="line">12、headSet：返回此 set 的部分视图，其元素严格小于 toElement。</span><br><span class="line">13、higher：返回此 set 中严格大于给定元素的最小元素；如果不存在这样的元素，则返回 null。</span><br><span class="line">14、isEmpty：如果此 set 不包含任何元素，则返回 true。</span><br><span class="line">15、iterator：返回在此 set 中的元素上按升序进行迭代的迭代器。</span><br><span class="line">16、last：返回此 set 中当前最后一个（最高）元素。</span><br><span class="line">17、lower：返回此 set 中严格小于给定元素的最大元素；如果不存在这样的元素，则返回 null。</span><br><span class="line">18、pollFirst：获取并移除第一个（最低）元素；如果此 set 为空，则返回 null。</span><br><span class="line">19、pollLast：获取并移除最后一个（最高）元素；如果此 set 为空，则返回 null。</span><br><span class="line">20、remove：将指定的元素从 set 中移除（如果该元素存在于此 set 中）。</span><br><span class="line">21、size：返回 set 中的元素数（set 的容量）。</span><br><span class="line">22、subSet：返回此 set 的部分视图</span><br><span class="line">23、tailSet：返回此 set 的部分视图</span><br></pre></td></tr></table></figure></p><ul><li>Map</li></ul><blockquote><p>Map通过keySet()可以返回它的键的Set，通过keyValues()它的值的Collection，或者它的键值对的Set。</p></blockquote><ul><li>Queue</li></ul><blockquote><p>队列是先进先出的容器。在并发编程中特别重要。</p></blockquote><p><strong>LinkedList实现的Queue:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printQ</span><span class="params">(Queue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.peek() != <span class="keyword">null</span>) &#123;<span class="comment">//判断队头元素是否为空</span></span><br><span class="line">            System.out.print(queue.remove() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"============================"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Random random = <span class="keyword">new</span> Random(<span class="number">37</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> randNum = random.nextInt(i + <span class="number">10</span>);</span><br><span class="line">            System.out.println(randNum);</span><br><span class="line">            queue.offer(randNum);<span class="comment">//加入队尾</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(queue);</span><br><span class="line">        Queue&lt;Character&gt; qc = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : <span class="string">"Brontosaurus"</span>.toCharArray()) &#123;</span><br><span class="line">            qc.offer(c);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(qc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>PriorityQueue优先级队列:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            priorityQueue.offer(rand.nextInt(i + <span class="number">20</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        QueueDemo.printQ(priorityQueue);<span class="comment">// 允许重复，最小值有最高优先级放队头</span></span><br><span class="line">        List&lt;Integer&gt; ints = Arrays.asList(<span class="number">25</span>, <span class="number">22</span>, <span class="number">18</span>, <span class="number">14</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">14</span>, <span class="number">18</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">25</span>);</span><br><span class="line">        priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(ints);</span><br><span class="line">        QueueDemo.printQ(priorityQueue);</span><br><span class="line">        priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(ints.size(), Collections.reverseOrder());<span class="comment">// Collections.reverseOrder() 为自带比较器，产生反序，可自定义实现</span></span><br><span class="line">        priorityQueue.addAll(ints);</span><br><span class="line">        QueueDemo.printQ(priorityQueue);</span><br><span class="line">        String fact = <span class="string">"EDUCcATION SHOULD ESCHEW OBFUSCATION"</span>;</span><br><span class="line">        List&lt;String&gt; strings = Arrays.asList(fact.split(<span class="string">""</span>));</span><br><span class="line">        PriorityQueue&lt;String&gt; stringPQ = <span class="keyword">new</span> PriorityQueue&lt;&gt;(strings);</span><br><span class="line">        QueueDemo.printQ(stringPQ);<span class="comment">//String类型，按照字母对应ascii从小到大，从队头到队尾</span></span><br><span class="line">        stringPQ = <span class="keyword">new</span> PriorityQueue&lt;&gt;(strings.size(), Collections.reverseOrder());</span><br><span class="line">        stringPQ.addAll(strings);</span><br><span class="line">        QueueDemo.printQ(stringPQ);</span><br><span class="line"></span><br><span class="line">        Set&lt;Character&gt; charset = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : fact.toCharArray()) &#123;</span><br><span class="line">            charset.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;Character&gt; characterPQ = <span class="keyword">new</span> PriorityQueue&lt;&gt;(charset);</span><br><span class="line">        QueueDemo.printQ(characterPQ);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Foreach和迭代器</li></ul><p>任何实现Iterable的类，都可以用于foreach语句中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IterableClass</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">String</span>&gt; </span>&#123;<span class="comment">//泛型使用</span></span><br><span class="line">   <span class="keyword">protected</span> String[] words = (<span class="string">"And that is how"</span> + <span class="string">"we know the Earth to be banana-shaped."</span>).split(<span class="string">" "</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;String&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> index &lt; words.length;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> words[index++];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String s : <span class="keyword">new</span> IterableClass()) &#123;</span><br><span class="line">            System.out.print(s + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你有一个接口并需要另外一个接口时，编写适配器就可以解决问题。例如添加一个能够产生Iterable对象的方法，该对象可以用于foreach语句。属于:适配器模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReversibleArrayList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReversibleArrayList</span><span class="params">(Collection&lt;? extends T&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;T&gt; <span class="title">reversed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterable&lt;T&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;T&gt;() &#123;</span><br><span class="line">                    <span class="keyword">int</span> current = size() -<span class="number">1</span>;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> current &gt; -<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> get(current--);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterMethodIdiom</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReversibleArrayList&lt;String&gt; ral = <span class="keyword">new</span> ReversibleArrayList(Arrays.asList(<span class="string">"To be or not to be"</span>.split(<span class="string">" "</span>)));</span><br><span class="line">        <span class="keyword">for</span> (String s : ral) &#123;</span><br><span class="line">            System.out.print(s + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span> (String s : ral.reversed()) &#123;</span><br><span class="line">            System.out.print(s + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-通过异常处理错误"><a href="#3-通过异常处理错误" class="headerlink" title="3.通过异常处理错误"></a>3.通过异常处理错误</h4><ul><li>异常类型的根类是Throwable</li><li>监控区域的概念<br>一段可能产生异常的代码，后面跟着处理这些异常的代码</li><li>异常处理程序，就是catch块</li><li>异常处理理论上有两种基本模型：终止模型(无法返回异常发生地方继续执行)和恢复模型(修正错误，并继续调用出错方法)</li><li>恢复模型包含依赖于抛出位置的非通用性代码，增加代码编写和维护的难度</li><li>创建自定义异常<blockquote><p>自定义异常必须从已有类中继承，最好选择意思相近。<br>对异常来说最重要的部分就是类名<br>最简单的方法就是让编译期为你产生默认构造器</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritingExceptions</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">throws</span> SimpleException </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"Throw SimpleException from f()"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SimpleException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InheritingExceptions sed = <span class="keyword">new</span> InheritingExceptions();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sed.f();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SimpleException e) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"Caught it!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>也可以为异常类定义一个接受字符串参数的构造器:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FullConstructors</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">throws</span> MyException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Throwing MyException form f()"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MyException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> <span class="keyword">throws</span> MyException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Throwing MyException from g()"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">"Originated in g()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            e.printStackTrace(System.out);<span class="comment">//信息发送到System.out，自动被捕获和显示在输出中；e.printStackTrace()会输出到标准错误流。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            g();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            e.printStackTrace(System.out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>异常记录日志:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = Logger.getLogger(<span class="string">"LoggingException"</span>);</span><br><span class="line">    <span class="comment">//SEVERE（最高值） 严重信息</span></span><br><span class="line">    <span class="comment">//WARNING 警示信息</span></span><br><span class="line">    <span class="comment">//INFO 一般信息</span></span><br><span class="line">    <span class="comment">//CONFIG 配置信息</span></span><br><span class="line">    <span class="comment">//FINE 细微信息</span></span><br><span class="line">    <span class="comment">//FINER 更细微的信息</span></span><br><span class="line">    <span class="comment">//FINEST（最低值） 最细微的信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoggingException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringWriter trace = <span class="keyword">new</span> StringWriter();<span class="comment">//</span></span><br><span class="line">        printStackTrace(<span class="keyword">new</span> PrintWriter(trace));<span class="comment">//重载的printStackTrace接收PrintWriter对象为参数，通过toString()可以将输出抽取为字符串</span></span><br><span class="line">        logger.severe(trace.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogginExceptions</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LoggingException();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LoggingException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"Caught "</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LoggingException();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LoggingException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"Caught "</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>更进一步自定义异常，加入额外的构造器和成员:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerException</span>  <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomerException</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomerException</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomerException</span><span class="params">(<span class="keyword">int</span> code, String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编译时被强制检查的异常称为被检查的异常</p></blockquote><p><strong>栈轨迹:</strong></p><p>printStackTrace()方法所提供的信息可以通过getStackTrace()直接访问，返回栈轨迹中的元素所构成的数组，每个元素代表栈中一帧。元素0是栈顶元素，是最后一个方法调用。</p><ul><li>重新抛出异常</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">catch(Exception)&#123;</span><br><span class="line"> System.out.println(&quot;An exception was thrown&quot;);</span><br><span class="line"> throw e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新抛出获取异常，printStackTrace()方法显示的是原异常抛出点的调用栈信息，要想更新抛出点的信息，可以调用fillInStackTrace()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    //异常</span><br><span class="line">&#125; catch(Exception e)&#123;</span><br><span class="line">    throw (Exception)e.fillInStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的行为也会更新抛出点的信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    //异常</span><br><span class="line">&#125; catch (OneException one) &#123;</span><br><span class="line">   throw new TwoException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>异常链</li></ul><p>捕获异常后，将原始信息一并打印出来，这就是异常链。<br>Throwable的子类在构造器中都可以接受一个cause对象作为参数，这个cause就是原始异常，通过cause实现把原始异常传递给新的异常。<br>在Throwable子类中，只有三种基本的异常类Error、Exception、及RuntimeException提供了带cause参数的构造器。如果要把其它类型链接起来应该使用initCause()方法而不是构造器实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  //异常</span><br><span class="line">&#125;catch(NoSuchFieldException e)&#123;</span><br><span class="line">  throw new RuntimeException(e);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  //异常</span><br><span class="line">&#125;catch(NoSuchFieldException e)&#123;</span><br><span class="line">  DynamicFieldsException dfe = new DynamicFieldsException();</span><br><span class="line">  dfe.initCause(e);</span><br><span class="line">  throw dfe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>java标准异常</li></ul><blockquote><p>Throwable可分为两种类型：Error-编译时和系统错误(一般不用关心)；Exception-基本异常类型(关心)<br>RuntimeException不会被编译器发现，其输出被报告给System.err;如果RuntimeException没有被捕获直达main（）</p></blockquote><ul><li>finally可用于释放内存之外的其他资源</li><li><p>finally总是会执行，即使方法有多个返回点，任可保证执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultipleReturns</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Initialization that requires cleanup"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Point 1"</span>);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Point 2"</span>);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Point 3"</span>);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"End"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Performing cleanup"</span>); <span class="comment">//都会执行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">            f(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>派生类构造器不能捕获基类构造器抛出的异常</p></li><li>一个派生类继承父类并实现接口，如果父类有接口的实现，且方法在接口和父类中抛出不一样的异常，基类复写方法时不能抛出异常。</li><li>一个派生类继承抽象父类，如果抽象父类中抽象父类抛出指定异常，则派生类复写方法时只能抛出父类部分或全部指定异常。</li><li>异常处理系统会按照catch异常顺序匹配异常，异常的派生类也可以被异常基类捕获</li></ul><h4 id="4-字符串"><a href="#4-字符串" class="headerlink" title="4.字符串"></a>4.字符串</h4><ul><li>String类中每一个看起来会修改String值的方法，实际上都是创建了一个全新的对象，以包含修改后的字符串内容。而最初的String对象则丝毫未动。</li><li>用于String的 “+” 与 “+=” 是java中仅有的两个重载过的操作符，而java并不允许程序员重载任何操作符</li><li><p>格式化输出： <code>printf()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintfTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">float</span> y =  <span class="number">1.01f</span>;</span><br><span class="line">        System.out.printf(<span class="string">"row 1:[%d %f]"</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>格式化输出： <code>format()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintfTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">float</span> y =  <span class="number">1.01f</span>;</span><br><span class="line">        System.out.format(<span class="string">"row 1:[%d %f]"</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Formatter转换器<br><strong>格式：</strong><br>d====&gt;整数型(十进制)  e====&gt;浮点数(科学计数)<br>c====&gt;Unicode字符    x====&gt;整数(十六进制)<br>b====&gt;Boolean值      h====&gt;散列码(十六进制)<br>s====&gt;String         %====&gt;字符%<br>f====&gt;浮点数(十进制)</p></li></ul><p>实战如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Formatter f = new Formatter(System.out);</span><br><span class="line">char u = &apos;a&apos;;</span><br><span class="line">System.out.println(&quot;u = &apos;a&apos;&quot;);</span><br><span class="line">f.format(&quot;s: %s\n&quot;, u);</span><br><span class="line">f.format(&quot;c: %c\n&quot;, u);</span><br><span class="line">f.format(&quot;b: %b\n&quot;, u);</span><br><span class="line">f.format(&quot;h: %h\n&quot;, u);</span><br><span class="line"></span><br><span class="line">int v =121;</span><br><span class="line">System.out.println(&quot;v = 121&quot;);</span><br><span class="line">f.format(&quot;d: %d\n&quot;, v);</span><br><span class="line">f.format(&quot;c: %c\n&quot;, v);</span><br><span class="line">f.format(&quot;b: %b\n&quot;, v);</span><br><span class="line">f.format(&quot;s: %s\n&quot;, v);</span><br><span class="line">f.format(&quot;x: %x\n&quot;, v);</span><br></pre></td></tr></table></figure></p><ul><li><p><code>String.format()</code>是static方法，接受与Formatter.format()方法一样的参数，但返回一个String对象，当只需用format()方法一次的时候使用比较方便</p></li><li><p>正则表达式<br>（1）匹配一个数字，可能有负号在前面：<code>-?</code><br>（2）正则表达式中，一位数字表示：<code>\d</code>，在java中是<code>\\d</code>，java中插入普通反斜线是<code>\\\\</code><br>（3）一个或多个之前的表达式：<code>+</code>，例如：可能有一个负号，后面跟着一位或多位数字，可以这样<code>-?\\d+</code><br>（4）通过String内置方法使用正则表达式：<code>&quot;-1234&quot;.matches(&quot;-?\\d+&quot;)</code><br>（5）可能以一个加号或减号开头<code>(-|\\+)?</code>，其中|为或者意思，因为+符号在正则有特殊意义，使用\转义变为普通符号<br>（6）String自带正则工具split()方法，将字符串从正则匹配的地方切开，<code>String.split(regex)</code>，例如：<code>split(\\W+)</code>从一个或多个非单词处切分，<code>\w</code>表示一个单词；<code>split(n\\W+)</code>从字母n后面跟着一个或多个单词的地方切分。<br>（7）String自带正则工具替换，<code>.replaceFirst(regex,str)</code>替换第一个匹配到的字符串，<code>.replaceAll(regex,str)</code></p></li><li>创建正则表达式</li></ul><p>——–字符——————<br>B==&gt;指定字符B<br>\xhh==&gt; 十六进制值为oxhh的字符串<br>\uhhhh==&gt; 十六进制值为oxhhhh字符<br>\t==&gt; 制表符tab<br>\n==&gt;换行符<br>\r==&gt;回车<br>\f==&gt;换页<br>\e==&gt;转义（Escape）  </p><p>——-字符类—————–<br>.==&gt;任意字符<br>[abc]==&gt;包含a、b和c的任何字符（和a|b|c作用相同）<br>[^abc]==&gt;除了a、b和c之外的任何字符<br>[a-zA-Z]==&gt;从a到z或从A到Z的任何字符<br>[abc[hij]]==&gt;任意a、b、c、h、i和j字符（同a|b|c|h|i|j）<br>[a-z&amp;&amp;[hij]]==&gt;从a到z和h、i、j取交集，结果为hij<br>\s==&gt;空白符（空格、tab、换行、换页和回车）<br>\S==&gt;非空白符（[^\s]）<br>\d==&gt;数字[0-9]<br>\D==&gt;非数字[^0-9]<br>\w==&gt;词字符[a-zA-Z0-9]<br>\W==&gt;非词字符[^\w]<br>——-逻辑操作符—————–<br>XY==&gt;Y跟在X后面<br>X|Y==&gt;X或Y<br>(X)==&gt;捕获组，可以在表达式中用\i引用第i个捕获组<br>——-边界匹配符—————–<br>^==&gt;一行的开始<br>$==&gt;一行的结束<br>\b==&gt;词的边界<br>\B==&gt;非词的边界<br>\G==&gt;前一个匹配的结束  </p><ul><li>量词<br>1.贪婪型<br>贪婪表达式会为所有可能的模式发现更多匹配<br>2.勉强型<br>用问号来指定，匹配满足模式所需的最少字符数<br>3.占有型</li></ul><table><thead><tr><th style="text-align:center">贪婪型</th><th style="text-align:center">勉强型</th><th style="text-align:center">占有型</th><th style="text-align:center">如何匹配</th></tr></thead><tbody><tr><td style="text-align:center">X?</td><td style="text-align:center">X??</td><td style="text-align:center">X?+</td><td style="text-align:center">一个或零个X</td></tr><tr><td style="text-align:center">X*</td><td style="text-align:center">X*?</td><td style="text-align:center">X*+</td><td style="text-align:center">零个或多个X</td></tr><tr><td style="text-align:center">X+</td><td style="text-align:center">X+?</td><td style="text-align:center">X++</td><td style="text-align:center">一个或多个X</td></tr><tr><td style="text-align:center">X{n}</td><td style="text-align:center">X{n}?</td><td style="text-align:center">X{n}+</td><td style="text-align:center">恰好n次</td></tr><tr><td style="text-align:center">X{n,}</td><td style="text-align:center">X{n,}?</td><td style="text-align:center">X{n,}+</td><td style="text-align:center">至少n次X</td></tr><tr><td style="text-align:center">X{n,m}</td><td style="text-align:center">X{n,m}?</td><td style="text-align:center">X{n,m}+</td><td style="text-align:center">至少n次，最多m次</td></tr></tbody></table><blockquote><p>note:    <code>abc+</code>代表匹配ab，后面跟1个或多个c；<code>(abc)+</code>代表匹配一个或多个abc</p></blockquote><ul><li>Pattern 和 Matcher</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//编译正则表达式字符串</span><br><span class="line">Pattern p = Pattern.compile(regx);</span><br><span class="line">//匹配目标字符串</span><br><span class="line">Matcher m = p.matcher(targetStr);</span><br><span class="line">//todo Matcher的方法</span><br></pre></td></tr></table></figure><blockquote><p>Matcher对象的方法reset()，带参数时可以替换目标匹配字符串，不带参数重新设置到当前字符串序列的起始位置。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续看java编程思想，这篇主要记录了书中第十章：内部类、第十一章：持有对象、第十二章：通过异常处理错误中的碎片知识。&lt;br&gt;
    
    </summary>
    
    
      <category term="编程思想" scheme="https://dongme.site/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>快捷键</title>
    <link href="https://dongme.site/2018/07/22/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://dongme.site/2018/07/22/快捷键/</id>
    <published>2018-07-22T05:23:00.000Z</published>
    <updated>2018-08-29T16:10:58.310Z</updated>
    
    <content type="html"><![CDATA[<p>mac、sublime 和 idea的一些快捷键可以大大加快我们的工作效率，特此mark一下，后续会不断更新完善。<br><a id="more"></a></p><p>——————- mac 快捷键———————<br>⌘ Command<br>⇧ Shift<br>⌥ Option<br>⌃ Control<br>↩︎ Return/Enter<br>⌫ Delete<br>⌦ 向前删除键（Fn+Delete）<br>↑ 上箭头<br>↓ 下箭头<br>← 左箭头<br>→ 右箭头<br>⇞ Page Up（Fn+↑）<br>⇟ Page Down（Fn+↓）<br>Home Fn + ←<br>End Fn + →<br>⇥ 右制表符（Tab键）<br>⇤ 左制表符（Shift+Tab）<br>⎋ Escape (Esc)<br>control + alt/option + space bar 切换下一个输入法<br>control + space bar 切换最近的一次输入法<br>command + ←/→  光标定位到行首或行尾部<br>option + ←/→ 光标定位到上一个或下一个单词  </p><p>———————sublime————————  </p><p>sublime多行<br>下面就来看下具体的五种方式吧：<br>1，鼠标选中多行，按下 Ctrl Shift L (Command Shift L) 即可同时编辑这些行；<br>2，鼠标选中文本，反复按 CTRL D (Command D) 即可继续向下同时选中下一个相同的文本进行同时编辑；<br>3，鼠标选中文本，按下 Alt F3 (Win) 或 Ctrl Command G(Mac) 即可一次性选择全部的相同文本进行同时编辑；<br>4，Shift 鼠标右键 (Win) 或 Option 鼠标左键 (Mac) 或使用鼠标中键可以用鼠标进行竖向多行选择；<br>5，Ctrl 鼠标左键(Win) 或 Command 鼠标左键(Mac) 可以手动选择同时要编辑。</p><p>———————-idea 常用但常忘记快捷键———————–<br>Command + Shift + Delete 跳转到最后一个编辑的地方<br>Option + Enter 显示意向动作和快速修复代码<br>Option + Command + o   自动删除无效包<br>Command + Shift + ↑/↓ 向上或向下移动代码<br>Option + Command + Enter 当前光标处代码下移并插入新行且光标定位新行<br>———————-idea快捷————————————<br>一、Editing（编辑）<br>Option/Alt + F7 查看方法在哪些地方被调用<br>Control + Space 基本的代码补全（补全任何类、方法、变量）<br>Control + Shift + Space 智能代码补全（过滤器方法列表和变量的预期类型）<br>Command + Option/Shift + 上下方向键 向上或向下移动代码<br>Command + Shift + Enter 自动结束代码，行末自动添加分号<br>Command + P 显示方法的参数信息<br>Control + J 快速查看文档<br>Shift + F1 查看外部文档（在某些代码上会触发打开浏览器显示相关文档）<br>Command + 鼠标放在代码上 显示代码简要信息<br>Command + F1 在错误或警告处显示具体描述信息<br>Command + N” Control + Enter” Control + N 生成代码（getter、setter、构造函数、hashCode/equals”toString）<br>Control + O 覆盖方法（重写父类方法）<br>Command/Control + I 实现方法（实现接口中的方法）<br>Command + Option + T 包围代码（使用if..else” try..catch” for” synchronized等包围选中的代码）<br>Command + / 注释/取消注释与行注释<br>Command + Option + / 注释/取消注释与块注释<br>Option/Shift + 方向键上 连续选中代码块<br>Option/Shift + 方向键下 减少当前选中的代码块<br>Control + Shift + Q 显示上下文信息<br>Option + Enter 显示意向动作和快速修复代码<br>Command + Option + L 格式化代码<br>Control + Option + O 优化import<br>Control + Option + I 自动缩进线<br>Tab / Shift + Tab 缩进代码 / 反缩进代码<br>Command + X 剪切当前行或选定的块到剪贴板<br>Command + C 复制当前行或选定的块到剪贴板<br>Command + V 从剪贴板粘贴<br>Command + Shift + V 从最近的缓冲区粘贴<br>Command + D 复制当前行或选定的块<br>Command + Y/Delete 删除当前行或选定的块的行<br>Control + Shift + J 智能的将代码拼接成一行<br>Command + Enter 智能的拆分拼接的行<br>Shift + Enter 开始新的一行<br>Command + Shift + U 大小写切换<br>Command + Shift + ] / Command + Shift + [ 选择直到代码块结束/开始<br>Option + Fn + Delete 删除到单词的末尾<br>Option + Delete 删除到单词的开头<br>Command + 加号 / Command + 减号 展开 / 折叠代码块<br>Command + Shift + 加号 展开所以代码块<br>Command + Shift + 减号 折叠所有代码块<br>Command + W 关闭活动的编辑器选项卡<br>二、Search/Replace（查询/替换）<br>Double Shift 查询任何东西<br>Command + F 文件内查找<br>Command + G 查找模式下，向下查找<br>Command + Shift + G 查找模式下，向上查找<br>Command + R 文件内替换<br>Command + Shift + F 全局查找（根据路径）<br>Command + Shift + R 全局替换（根据路径）<br>Command + Shift + S 查询结构（Ultimate Edition 版专用，需要在Keymap中设置）<br>Command + Shift + M 替换结构（Ultimate Edition 版专用，需要在Keymap中设置）<br>三、Usage Search（使用查询）<br>Option + F7 / Command + F7 在文件中查找用法 / 在类中查找用法<br>Command + Shift + F7 在文件中突出显示的用法<br>Command + Option + F7 显示用法<br>四、Compile and Run（编译和运行）<br>Command + F9 编译Project<br>Command + Shift + F9 编译选择的文件、包或模块<br>Control + Option + R 弹出 Run 的可选择菜单<br>Control + Option + D 弹出 Debug 的可选择菜单<br>Control + R 运行<br>Control + D 调试<br>Control + Shift + R” Control + Shift + D 从编辑器运行上下文环境配置<br>五、Debugging（调试）<br>F8 进入下一步，如果当前行断点是一个方法，则不进入当前方法体内<br>F7 进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中<br>Shift + F7 智能步入，断点所在行上有多个方法调用，会弹出进入哪个方法<br>Shift + F8 跳出<br>Option + F9 运行到光标处，如果光标前有其他断点会进入到该断点<br>Option + F8 计算表达式（可以更改变量值使其生效）<br>Command + Option + R 恢复程序运行，如果该断点下面代码还有断点则停在下一个断点上<br>Command + F8 切换断点（若光标当前行有断点则取消断点，没有则加上断点）<br>Command + Shift + F8 查看断点信息<br>六、Navigation（导航）<br>Command + O 查找类文件<br>Command + Shift + O 查找所有类型文件、打开文件、打开目录，打开目录需要在输入的内容前面或后面加一个反斜杠/<br>Command + Option + O 前往指定的变量 / 方法<br>Control + 方向键左 / Control + 方向键右 左右切换打开的编辑tab页<br>F12 返回到前一个工具窗口<br>Esc 从工具窗口进入代码文件窗口<br>Shift + Esc 隐藏当前或最后一个活动的窗口，且光标进入代码文件窗口<br>Command + Shift + F4 关闭活动run/messages/find/… tab<br>Command + L 在当前文件跳转到某一行的指定处<br>Command + E 显示最近打开的文件记录列表<br>Option + 方向键左 / Option + 方向键右 光标跳转到当前单词 / 中文句的左 / 右侧开头位置<br>Command + Option + 方向键左 / Command + Option + 方向键右 退回 / 前进到上一个操作的地方<br>Command + Shift + Delete 跳转到最后一个编辑的地方<br>Option + F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择(如在代码编辑窗口可以选择显示该文件的Finder)<br>Command + B / Command + 鼠标点击 进入光标所在的方法/变量的接口或是定义处<br>Command + Option + B 跳转到实现处，在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口<br>Option + Space” Command + Y 快速打开光标所在方法、类的定义<br>Control + Shift + B 跳转到类型声明处<br>Command + U 前往当前光标所在方法的父类的方法 / 接口定义<br>Control + 方向键下 / Control + 方向键上 当前光标跳转到当前文件的前一个/后一个方法名位置<br>Command + ] / Command + [ 移动光标到当前所在代码的花括号开始/结束位置<br>Command + F12 弹出当前文件结构层，可以在弹出的层上直接输入进行筛选（可用于搜索类中的方法）<br>Control + H 显示当前类的层次结构<br>Command + Shift + H 显示方法层次结构<br>Control + Option + H 显示调用层次结构<br>F2 / Shift + F2 跳转到下一个/上一个突出错误或警告的位置<br>F4 / Command + 方向键下 编辑/查看代码源<br>Option + Home 显示到当前文件的导航条<br>F3选中文件/文件夹/代码行，添加/取消书签<br>Option + F3 选中文件/文件夹/代码行，使用助记符添加/取消书签<br>Control + 0…Control + 9 定位到对应数值的书签位置<br>Command + F3 显示所有书签<br>七、Refactoring（重构）<br>F5 复制文件到指定目录<br>F6 移动文件到指定目录<br>Command + Delete 在文件上为安全删除文件，弹出确认框<br>Shift + F6 重命名文件<br>Command + F6 更改签名<br>Command + Option + N 一致性<br>Command + Option + M 将选中的代码提取为方法<br>Command + Option + V 提取变量<br>Command + Option + F 提取字段<br>Command + Option + C 提取常量<br>Command + Option + P 提取参数<br>八、VCS/Local History（版本控制/本地历史记录）<br>Command + K 提交代码到版本控制器<br>Command + T 从版本控制器更新代码<br>Option + Shift + C 查看最近的变更记录<br>Control + C 快速弹出版本控制器操作面板<br>九、Live Templates（动态代码模板）<br>Command + Option + J 弹出模板选择窗口，将选定的代码使用动态模板包住<br>Command + J 插入自定义动态代码模板<br>十、General（通用）<br>Command + 1…Command + 9 打开相应编号的工具窗口<br>Command + S 保存所有<br>Command + Option + Y 同步、刷新<br>Control + Command + F 切换全屏模式<br>Command + Shift + F12 切换最大化编辑器<br>Option + Shift + F 添加到收藏夹<br>Option + Shift + I 检查当前文件与当前的配置文件<br>Control + ` 快速切换当前的scheme（切换主题、代码样式等）<br>Command + “ 打开IDEA系统设置<br>Command + ; 打开项目结构对话框<br>Shift + Command + A 查找动作（可设置相关选项）<br>Control + Shift + Tab 编辑窗口标签和工具窗口之间切换（如果在切换的过程加按上delete，则是关闭对应选中的窗口）<br>十一、Other（一些官方文档上没有体现的快捷键）<br>Command + Shift +8 竖编辑模式</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mac、sublime 和 idea的一些快捷键可以大大加快我们的工作效率，特此mark一下，后续会不断更新完善。&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="https://dongme.site/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="快捷键" scheme="https://dongme.site/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>java编程思想[1-9]</title>
    <link href="https://dongme.site/2018/06/06/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-1/"/>
    <id>https://dongme.site/2018/06/06/java编程思想-1/</id>
    <published>2018-06-05T16:00:00.000Z</published>
    <updated>2018-08-29T16:10:58.308Z</updated>
    
    <content type="html"><![CDATA[<p>最近看java编程思想，对看过的前1-9章一些似懂非懂的知识点做个记录吧。<br><a id="more"></a></p><h4 id="1-”是一个”与”像是一个”的关系"><a href="#1-”是一个”与”像是一个”的关系" class="headerlink" title="1.”是一个”与”像是一个”的关系"></a>1.”是一个”与”像是一个”的关系</h4><ul><li>导出类只覆盖基类的方法，导出类和基类是完全相同的类型，基类和导出类的关系是一个关系。</li><li>导出类添加新的接口元素，基类无法访问导出类的新接口元素，基类和导出类之间的关系是”像是一个的关系”</li></ul><h4 id="2-伴随多态的可互换对象"><a href="#2-伴随多态的可互换对象" class="headerlink" title="2.伴随多态的可互换对象"></a>2.伴随多态的可互换对象</h4><ul><li>伴随多态的可互换对象基于面向对象程序设计语言采用了后期绑定的概念。当向对象发送消息时，被调用的代码在运行时才能确定。</li></ul><h4 id="3-为什么支持多种类型容器"><a href="#3-为什么支持多种类型容器" class="headerlink" title="3.为什么支持多种类型容器"></a>3.为什么支持多种类型容器</h4><p> 容器持有其它对象的引用，设计多种容器类型原因如下：</p><ul><li>不同容器提供不同的接口和行为</li><li>不同容器对某些操作的效率不同</li></ul><h4 id="4-对象和其它变量存储空间、生命周期"><a href="#4-对象和其它变量存储空间、生命周期" class="headerlink" title="4.对象和其它变量存储空间、生命周期"></a>4.对象和其它变量存储空间、生命周期</h4><ul><li>普通变量存在在堆栈，在编译阶段就会确定变量的存储空间地址和生命周期；对象存在堆（heap），在运行阶段动态分配存储空间，对象的生命周期取决是否被引用，且通过java垃圾回收机制回收。</li></ul><h4 id="5-异常处理不是面向对象的特征。"><a href="#5-异常处理不是面向对象的特征。" class="headerlink" title="5.异常处理不是面向对象的特征。"></a>5.异常处理不是面向对象的特征。</h4><h4 id="6-java基本类型"><a href="#6-java基本类型" class="headerlink" title="6.java基本类型"></a>6.java基本类型</h4><ul><li>boolean、char、byte、short、int、long、float、double、void</li><li>基本类型所占存储空间不随机器硬件架构的变化而变化</li><li>boolean类型没有明确指定存储空间大小，仅定义为能够取字面值true&amp;false</li></ul><h4 id="7-BigInteger-amp-BigDecimal"><a href="#7-BigInteger-amp-BigDecimal" class="headerlink" title="7. BigInteger&amp;BigDecimal"></a>7. BigInteger&amp;BigDecimal</h4><ul><li>高精度计算类，虽然属于包装类却没有对应的基本类型。高精度计算类操作复杂，运算速度相当较慢。</li></ul><h4 id="8-java数组对比C和C"><a href="#8-java数组对比C和C" class="headerlink" title="8.java数组对比C和C++"></a>8.java数组对比C和C++</h4><ul><li>java有范围检查，要求数组必须进行初始化且不超出范围，牺牲了少量内存开销换来安全性和效率的提升。</li></ul><h4 id="9-java类中基本类型成员会自动初始化，但局部变量并不会-非某个类的字段"><a href="#9-java类中基本类型成员会自动初始化，但局部变量并不会-非某个类的字段" class="headerlink" title="9. java类中基本类型成员会自动初始化，但局部变量并不会(非某个类的字段)"></a>9. java类中基本类型成员会自动初始化，但局部变量并不会(非某个类的字段)</h4><ul><li>boolean==&gt;false</li><li>char==&gt;null</li><li>byte==&gt;(byte)0</li><li>short==&gt;(short)0</li><li>int==&gt;0</li><li>long==&gt;oL</li><li>float==&gt;0.0L</li><li>double==&gt;0.0D</li></ul><h4 id="10-方法签名（方法名和参数列表）唯一标识某个方法"><a href="#10-方法签名（方法名和参数列表）唯一标识某个方法" class="headerlink" title="10.方法签名（方法名和参数列表）唯一标识某个方法"></a>10.方法签名（方法名和参数列表）唯一标识某个方法</h4><h4 id="11-static方法牧羊人角色-创建或使用同类型的被命名对象"><a href="#11-static方法牧羊人角色-创建或使用同类型的被命名对象" class="headerlink" title="11.static方法牧羊人角色-创建或使用同类型的被命名对象"></a>11.static方法牧羊人角色-创建或使用同类型的被命名对象</h4><h4 id="12-java-lang默认导入到每个java文件中"><a href="#12-java-lang默认导入到每个java文件中" class="headerlink" title="12.java.lang默认导入到每个java文件中"></a>12.java.lang默认导入到每个java文件中</h4><h4 id="13-文档注释"><a href="#13-文档注释" class="headerlink" title="13.文档注释"></a>13.文档注释</h4><ul><li><code>/*comment*/</code>  整段注释</li><li><code>//</code> 行注释</li></ul><h4 id="14-javadoc命令只能出现在-中，可嵌入html"><a href="#14-javadoc命令只能出现在-中，可嵌入html" class="headerlink" title="14.javadoc命令只能出现在/**中，可嵌入html"></a>14.javadoc命令只能出现在/**中，可嵌入html</h4><ul><li>@see: 引用其他类</li><li>@link: 与@see类似，但是属于行内引用，{@link package.class#member label}</li><li>@{@docRoot}</li><li>@{inheritDoc}</li><li>@version</li><li>@author</li><li>@since</li><li>@param</li><li>@return</li><li>@throws</li><li>@deprecated</li></ul><h4 id="15-几乎所有操作类型只能操作基本类型，例外的操作符是“-”，“-”，“-”可以操作所有对象"><a href="#15-几乎所有操作类型只能操作基本类型，例外的操作符是“-”，“-”，“-”可以操作所有对象" class="headerlink" title="15.几乎所有操作类型只能操作基本类型，例外的操作符是“=”，“!=”，“==”可以操作所有对象"></a>15.几乎所有操作类型只能操作基本类型，例外的操作符是“=”，“!=”，“==”可以操作所有对象</h4><h4 id="16-随机数的生成"><a href="#16-随机数的生成" class="headerlink" title="16.随机数的生成"></a>16.随机数的生成</h4><p><strong>Random rand = new Random():</strong><br>若创建时不输入构造参数，每一轮执行第n次rand.nextInt(100)的结果都不同；<br>若创建时输入构造参数，每一轮执行第n次rand.nextInt(100)的结构都相同。</p><h4 id="17-对象的等价性"><a href="#17-对象的等价性" class="headerlink" title="17.对象的等价性"></a>17.对象的等价性</h4><ul><li>基本类型判断等价性使用==和!=；比较其他对象的等价性使用每个对象都有的equals方法。</li></ul><h4 id="18-指数计数法"><a href="#18-指数计数法" class="headerlink" title="18.指数计数法"></a>18.指数计数法</h4><p><code>float flt = 1.36e-19f</code><br>等价于如下计算:<br><code>flt = 1.36*10^(-19)</code></p><h4 id="19-java位运算"><a href="#19-java位运算" class="headerlink" title="19.java位运算"></a>19.java位运算</h4><ul><li>在计算机中所有数据都是以二进制的形式储存的。位运算其实就是直接对在内存中的二进制数据进行操作，因此处理数据的速度非常快。</li><li>基本的位操作符有与、或、异或、取反、左移、右移这6种，它们的运算规则如下所示：<br>| 符号 | 描述 | 运算规则 |<br>| :-: | :-: | :-: |<br>| &amp; | 与 | 两个位都为1时结果才为1 |<br>| | | 或 | 两个位都为0时才为0 |<br>| ^ | 异或 | 两个位相同时为0，相异时为1 |<br>| ~ | 取反 | 1变0，0变1 |<br>| &lt;&lt; | 左移 | 各二进位全部左移若干位，高位丢弃，低位补 0；num &lt;&lt; 1”相当于num乘以2|<br>| &gt;&gt; | 有符号右移 | 各二进位全部右移若干位，对无符号数，高位补 0，有符号数，各编译器处理方法不一样，有的补符号位(算术右移，java采用)，有的补 0 (逻辑右移)；num &gt;&gt; 1”相当于num除以2|<br>| &gt;&gt;&gt; | 无符号右移 | 无论正负都在高位补0|</li><li>计算机中采用补码的形式进行二进制运算；正数的原码、反码和补码都一样；负数的反码，对应正数二进制表示所有位取反；负数的补码等于反码</li></ul><h4 id="20-java类型转换，扩展转换是自动的，窄化转换是强制的，而且数值窄化转换会强制截尾（Math-round-x-可实现四舍五入）"><a href="#20-java类型转换，扩展转换是自动的，窄化转换是强制的，而且数值窄化转换会强制截尾（Math-round-x-可实现四舍五入）" class="headerlink" title="20.java类型转换，扩展转换是自动的，窄化转换是强制的，而且数值窄化转换会强制截尾（Math.round(x)可实现四舍五入）"></a>20.java类型转换，扩展转换是自动的，窄化转换是强制的，而且数值窄化转换会强制截尾（Math.round(x)可实现四舍五入）</h4><h4 id="21-while-x-y-除非x和y都是boolean类型，否则编译报错"><a href="#21-while-x-y-除非x和y都是boolean类型，否则编译报错" class="headerlink" title="21. while(x=y)除非x和y都是boolean类型，否则编译报错"></a>21. while(x=y)除非x和y都是boolean类型，否则编译报错</h4><h4 id="22-void方法中有隐含的return，另外return会退出当前方法"><a href="#22-void方法中有隐含的return，另外return会退出当前方法" class="headerlink" title="22. void方法中有隐含的return，另外return会退出当前方法"></a>22. void方法中有隐含的return，另外return会退出当前方法</h4><h4 id="23-break-lable和continue-lable的区别"><a href="#23-break-lable和continue-lable的区别" class="headerlink" title="23. break lable和continue lable的区别"></a>23. break lable和continue lable的区别</h4><ul><li>嵌套循环，内循环内执行continue label会跳到外循环外label1并重新进入循环，break label则不会重新进入循环</li></ul><h4 id="24-多个构造器也是方法重载的使用"><a href="#24-多个构造器也是方法重载的使用" class="headerlink" title="24.多个构造器也是方法重载的使用"></a>24.多个构造器也是方法重载的使用</h4><h4 id="25-this代表调用方法的那个对象，会隐式的作为方法的第一个参数传过去，并通过this进行引用"><a href="#25-this代表调用方法的那个对象，会隐式的作为方法的第一个参数传过去，并通过this进行引用" class="headerlink" title="25. this代表调用方法的那个对象，会隐式的作为方法的第一个参数传过去，并通过this进行引用"></a>25. this代表调用方法的那个对象，会隐式的作为方法的第一个参数传过去，并通过this进行引用</h4><h4 id="26-构造器中调用构造器，可用this-参数列表-且必须放第一行且只能通过该形式调用一次"><a href="#26-构造器中调用构造器，可用this-参数列表-且必须放第一行且只能通过该形式调用一次" class="headerlink" title="26. 构造器中调用构造器，可用this(参数列表)且必须放第一行且只能通过该形式调用一次"></a>26. 构造器中调用构造器，可用this(参数列表)且必须放第一行且只能通过该形式调用一次</h4><h4 id="27-static的含义"><a href="#27-static的含义" class="headerlink" title="27. static的含义"></a>27. static的含义</h4><ul><li>static的方法没有隐含this参数</li><li>static的方法不能调用非static的方法，反之可以</li></ul><h4 id="28-finalize-用法"><a href="#28-finalize-用法" class="headerlink" title="28. finalize()用法"></a>28. finalize()用法</h4><ul><li>在类中定义一个finalize()，在垃圾回收器准备回收对象时会首先调用该函数</li><li>java中调用了非java的代码开辟了存储空间，需要finalize()中释放空间</li><li>通常不能指望finalize()，必须创建其它的清理方法</li></ul><h4 id="29-类的数据成员如果是基本类型会被自动初始化为默认值"><a href="#29-类的数据成员如果是基本类型会被自动初始化为默认值" class="headerlink" title="29. 类的数据成员如果是基本类型会被自动初始化为默认值"></a>29. 类的数据成员如果是基本类型会被自动初始化为默认值</h4><h4 id="30-类成员初始化顺序依次"><a href="#30-类成员初始化顺序依次" class="headerlink" title="30. 类成员初始化顺序依次"></a>30. 类成员初始化顺序依次</h4><ul><li>基类构造器 &gt;（静态变量、静态初始化块）&gt;（变量、初始化块）&gt; 导出类构造器</li></ul><h4 id="31-对象创建过程及成员初始化"><a href="#31-对象创建过程及成员初始化" class="headerlink" title="31. 对象创建过程及成员初始化"></a>31. 对象创建过程及成员初始化</h4><p><strong>假设有个名为Dog的类</strong></p><ol><li>即使没有显式地使用static关键字，构造器实际上也是静态方法。因此，当首次创建类型为Dog的对象时，<br>或者Dog类的静态方法/静态域首次被访问时，java解释器必须查找类路径，以定位Dog.class文件</li><li>然后载入Dog.class(会创建Class对象)，有关静态初始化的所有动作都会执行。因此，静态初始化只在Class<br>对象首次加载的时候执行一次。</li><li>当用new Dog()创建对象的时候，首先将在堆上为Dog对象分配足够的存储空间。</li><li>这块存储空间会被清零，这就自动地将Dog对象中所有基本类型设置成默认值。(数字、字符、布尔为0，引用为null)</li><li>执行所有出现于字段定义处的初始化动作。</li><li>执行构造器</li></ol><h4 id="32-数组初始化"><a href="#32-数组初始化" class="headerlink" title="32. 数组初始化"></a>32. 数组初始化</h4><ul><li><code>int[] a1 = {1&quot;2&quot;3&quot;4&quot;5}</code></li><li><code>int a2 [] = new int[]{20&quot;21&quot;22}</code></li><li><code>int a3 = new int[5]</code>，随后进行初始化</li></ul><h4 id="33-可变参数列表"><a href="#33-可变参数列表" class="headerlink" title="33. 可变参数列表"></a>33. 可变参数列表</h4><ul><li>void test(Object… objs)，objs会根据输入的参数创建数组。</li></ul><h4 id="34-enum枚举类型可以结合switch语句使用"><a href="#34-enum枚举类型可以结合switch语句使用" class="headerlink" title="34.enum枚举类型可以结合switch语句使用"></a>34.enum枚举类型可以结合switch语句使用</h4><h4 id="35-一个java源代码文件有且只能有一个public类"><a href="#35-一个java源代码文件有且只能有一个public类" class="headerlink" title="35.一个java源代码文件有且只能有一个public类"></a>35.一个java源代码文件有且只能有一个public类</h4><h4 id="36-package语言必须出现在除注释外的第一行"><a href="#36-package语言必须出现在除注释外的第一行" class="headerlink" title="36.package语言必须出现在除注释外的第一行"></a>36.package语言必须出现在除注释外的第一行</h4><h4 id="37-java类中不指定package，会使用默认包"><a href="#37-java类中不指定package，会使用默认包" class="headerlink" title="37.java类中不指定package，会使用默认包"></a>37.java类中不指定package，会使用默认包</h4><h4 id="38-运行java-类名会自动运行该类下的main方法"><a href="#38-运行java-类名会自动运行该类下的main方法" class="headerlink" title="38.运行java 类名会自动运行该类下的main方法"></a>38.运行java 类名会自动运行该类下的main方法</h4><h4 id="39-继承类的构造过程是从内向外，先调用基类构造器后调用导出类构造器"><a href="#39-继承类的构造过程是从内向外，先调用基类构造器后调用导出类构造器" class="headerlink" title="39.继承类的构造过程是从内向外，先调用基类构造器后调用导出类构造器"></a>39.继承类的构造过程是从内向外，先调用基类构造器后调用导出类构造器</h4><h4 id="40-子类调用父类带参构造器使用super"><a href="#40-子类调用父类带参构造器使用super" class="headerlink" title="40.子类调用父类带参构造器使用super"></a>40.子类调用父类带参构造器使用super</h4><h4 id="41-复用类之组合、继承、代理"><a href="#41-复用类之组合、继承、代理" class="headerlink" title="41.复用类之组合、继承、代理"></a>41.复用类之组合、继承、代理</h4><ul><li>代理的实质是通过创建一个代理类去，并将代理对象作为初始化成员属性通过自身方法调用目标对象的方法，是对目标方法的再次包装</li></ul><h4 id="42-导出类可以向上自动转型为基类类型"><a href="#42-导出类可以向上自动转型为基类类型" class="headerlink" title="42.导出类可以向上自动转型为基类类型"></a>42.导出类可以向上自动转型为基类类型</h4><h4 id="43-继承or组合"><a href="#43-继承or组合" class="headerlink" title="43.继承or组合"></a>43.继承or组合</h4><ul><li>继承当慎用，使用组合还是继承判断标准是:是否需要向上转型，若需要则使用继承</li></ul><h4 id="44-final相关"><a href="#44-final相关" class="headerlink" title="44.final相关"></a>44.final相关</h4><ul><li>final标注的类型必须初始化</li><li>分配固定的存储空间，基本类型值不变，引用类型引用地址不变</li><li>基本类型且不是随机数属于编译期常量</li><li>基本类型且属于随机数、对象等引用类型在运行时才能确定，运行时常量</li><li>对数组等引用类型使用final意义不大</li><li>final标注类型初始化可发生在使用之前，如在构造函数中进行初始化</li><li>final标注的方法，可以防止被重写，而是提高效率(编译时动态绑定)</li><li>final标注的类不能被继承，类的方法隐式的指定为final，显示的添加final无意义</li><li>java中除了static方法和final方法(private方法属于final方法)，其它所有方法都是后期绑定</li></ul><h4 id="45-域和静态方法"><a href="#45-域和静态方法" class="headerlink" title="45.域和静态方法"></a>45.域和静态方法</h4><ul><li>普通方法才具有多态性，直接访问的域则是在编译期进行解析，如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class FieldAccess &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Super sup = new Sub();</span><br><span class="line">        System.out.println(&quot;sup.field=&quot; + sup.field + &quot;;sup.getField()=&quot; + sup.getField());</span><br><span class="line">        Sub sub = new Sub();</span><br><span class="line">        System.out.println(&quot;sub.field=&quot; + sub.field + &quot;;sub.getField()=&quot; + sub.getField() + &quot;;sub.getSuperField()=&quot; + sub.getSuperField());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Super &#123;</span><br><span class="line">    public int field = 0;</span><br><span class="line"></span><br><span class="line">    public int getField() &#123;</span><br><span class="line">        return field;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Sub extends Super &#123;</span><br><span class="line">    public int field = 1;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getField() &#123;</span><br><span class="line">        return field;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getSuperField() &#123;</span><br><span class="line">        return super.field;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>基类中的域和导出类中的域尽量不要起相同的名字</li><li>静态方法是不具有多态性的，静态方法是和类而非对象进行关联的</li></ul><h4 id="46-构造器是隐式的static"><a href="#46-构造器是隐式的static" class="headerlink" title="46.构造器是隐式的static"></a>46.构造器是隐式的static</h4><h4 id="47-抽象类和抽象方法"><a href="#47-抽象类和抽象方法" class="headerlink" title="47.抽象类和抽象方法"></a>47.抽象类和抽象方法</h4><ul><li>包含抽象方法的类为抽象类</li><li>一个类中包含一个或多个抽象方法，必须被声明为抽象类</li><li>导出类继承抽象类，要么实现抽象类中的抽象方法，要么声明为抽象类</li></ul><h4 id="48-接口相关"><a href="#48-接口相关" class="headerlink" title="48.接口相关"></a>48.接口相关</h4><ul><li>接口中的任何域都是static和final的，初始化可以发生在编译阶段和运行阶段</li><li>接口只有public和默认(包访问权限)两种权限</li><li>接口中的元素的都是public的</li><li>接口实现工厂方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">interface Service &#123;</span><br><span class="line">    void method1();</span><br><span class="line"></span><br><span class="line">    void method2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface ServiceFactory &#123;</span><br><span class="line">    Service getService();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Implementation1 implements Service &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void method1() &#123;</span><br><span class="line">        System.out.println(&quot;Implementation1:method1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void method2() &#123;</span><br><span class="line">        System.out.println(&quot;Implementation1:method2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Implementation1Factory implements ServiceFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Service getService() &#123;</span><br><span class="line">        return new Implementation1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Implementation2 implements Service &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void method1() &#123;</span><br><span class="line">        System.out.println(&quot;Implemention2:method1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void method2() &#123;</span><br><span class="line">        System.out.println(&quot;Implemention2:method2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Implementation2Factory implements ServiceFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Service getService() &#123;</span><br><span class="line">        return new Implementation2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class FactoriesPrice &#123;</span><br><span class="line">    public static void serviceConsumer(ServiceFactory factory) &#123;</span><br><span class="line">        Service s = factory.getService();</span><br><span class="line">        s.method1();</span><br><span class="line">        s.method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        serviceConsumer(new Implementation1Factory());</span><br><span class="line">        serviceConsumer(new Implementation2Factory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看java编程思想，对看过的前1-9章一些似懂非懂的知识点做个记录吧。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://dongme.site/categories/java/"/>
    
    
      <category term="编程思想" scheme="https://dongme.site/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>博客添加订阅</title>
    <link href="https://dongme.site/2018/05/15/%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AE%A2%E9%98%85/"/>
    <id>https://dongme.site/2018/05/15/博客添加订阅/</id>
    <published>2018-05-15T03:29:57.000Z</published>
    <updated>2018-08-29T16:10:58.310Z</updated>
    
    <content type="html"><![CDATA[<p>下载的主题中包含Rss订阅页签，但发现实际不可用，搜索资料动手完善了下订阅功能。<br><a id="more"></a><br><strong>步骤如下：</strong></p><ul><li>博客根目录下执行<code>npm install hexo-generator-feed --save</code></li><li><p>编辑博客根目录下<code>_config.yml</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">## RSS订阅添加</span><br><span class="line">plugin:</span><br><span class="line">- hexo-generator-feed</span><br><span class="line">#Feed Atom</span><br><span class="line">feed:</span><br><span class="line">  type: atom</span><br><span class="line">  path: atom.xml</span><br><span class="line">  limit: 20</span><br><span class="line">## RSS订阅添加</span><br></pre></td></tr></table></figure></li><li><p>编辑主题下的<code>_config.yml</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## RSS订阅</span><br><span class="line">subnav:</span><br><span class="line">  rss: &quot;/atom.xml&quot;</span><br><span class="line">## RSS订阅</span><br></pre></td></tr></table></figure></li><li><p>重用编译发布博客</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下载的主题中包含Rss订阅页签，但发现实际不可用，搜索资料动手完善了下订阅功能。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
