<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>alvin&#39;s blog</title>
  
  <subtitle>Good memory is worse than bad writing</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dongme.site/"/>
  <updated>2018-10-24T16:13:50.296Z</updated>
  <id>https://dongme.site/</id>
  
  <author>
    <name>alvin dong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>风暴之分布式事务</title>
    <link href="https://dongme.site/2018/10/24/%E9%A3%8E%E6%9A%B4%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <id>https://dongme.site/2018/10/24/风暴之分布式事务/</id>
    <published>2018-10-23T16:23:00.000Z</published>
    <updated>2018-10-24T16:13:50.296Z</updated>
    
    <content type="html"><![CDATA[<p>分布式事务是企业集成中的一个技术难点，也是每一个分布式系统架构中都会涉及到的一个东西，特别是在微服务架构中，几乎可以说是无法避免，本文通过思维导图做一个简单的知识梳理。<br><a id="more"></a></p><p><img src="http://ombpxfki1.bkt.clouddn.com/154031193881752wfhtwt.png?imageslim" alt="paste image">  </p><h5 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h5><p>[1] <a href="https://draveness.me/distributed-transaction-principle" target="_blank" rel="noopener">分布式事务的实现原理</a><br>[2] <a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" target="_blank" rel="noopener">聊聊分布式事务，再说说解决方案</a>  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分布式事务是企业集成中的一个技术难点，也是每一个分布式系统架构中都会涉及到的一个东西，特别是在微服务架构中，几乎可以说是无法避免，本文通过思维导图做一个简单的知识梳理。&lt;br&gt;
    
    </summary>
    
      <category term=" 分布式" scheme="https://dongme.site/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式事务" scheme="https://dongme.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之传输对象模式</title>
    <link href="https://dongme.site/2018/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongme.site/2018/10/21/设计模式之传输对象模式/</id>
    <published>2018-10-21T04:46:00.000Z</published>
    <updated>2018-10-21T04:47:51.901Z</updated>
    
    <content type="html"><![CDATA[<p>传输对象模式（Transfer Object Pattern）用于从客户端向服务器一次性传递带有多个属性的数据。传输对象也被称为数值对象。传输对象是一个具有 getter/setter 方法的简单的 POJO 类，它是可序列化的，所以它可以通过网络传输。它没有任何的行为。服务器端的业务类通常从数据库读取数据，然后填充 POJO，并把它发送到客户端或按值传递它。对于客户端，传输对象是只读的。客户端可以创建自己的传输对象，并把它传递给服务器，以便一次性更新数据库中的数值。以下是这种设计模式的实体。</p><ul><li><strong>业务对象（Business Object）</strong> - 为传输对象填充数据的业务服务。</li><li><strong>传输对象（Transfer Object）</strong> - 简单的 POJO，只有设置/获取属性的方法。</li><li><strong>客户端（Client）</strong> - 客户端可以发送请求或者发送传输对象到业务对象。<a id="more"></a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传输对象模式（Transfer Object Pattern）用于从客户端向服务器一次性传递带有多个属性的数据。传输对象也被称为数值对象。传输对象是一个具有 getter/setter 方法的简单的 POJO 类，它是可序列化的，所以它可以通过网络传输。它没有任何的行为。服务器端的业务类通常从数据库读取数据，然后填充 POJO，并把它发送到客户端或按值传递它。对于客户端，传输对象是只读的。客户端可以创建自己的传输对象，并把它传递给服务器，以便一次性更新数据库中的数值。以下是这种设计模式的实体。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;业务对象（Business Object）&lt;/strong&gt; - 为传输对象填充数据的业务服务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;传输对象（Transfer Object）&lt;/strong&gt; - 简单的 POJO，只有设置/获取属性的方法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;客户端（Client）&lt;/strong&gt; - 客户端可以发送请求或者发送传输对象到业务对象。
    
    </summary>
    
      <category term="设计模式" scheme="https://dongme.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="传输对象模式" scheme="https://dongme.site/tags/%E4%BC%A0%E8%BE%93%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之服务定位器模式</title>
    <link href="https://dongme.site/2018/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%AE%9A%E4%BD%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongme.site/2018/10/21/设计模式之服务定位器模式/</id>
    <published>2018-10-21T04:44:00.000Z</published>
    <updated>2018-10-21T04:45:29.984Z</updated>
    
    <content type="html"><![CDATA[<p>服务定位器模式（Service Locator Pattern）用在我们想使用 JNDI 查询定位各种服务的时候。考虑到为某个服务查找 JNDI 的代价很高，服务定位器模式充分利用了缓存技术。在首次请求某个服务时，服务定位器在 JNDI 中查找服务，并缓存该服务对象。当再次请求相同的服务时，服务定位器会在它的缓存中查找，这样可以在很大程度上提高应用程序的性能。以下是这种设计模式的实体。</p><ul><li><strong>服务（Service）</strong> - 实际处理请求的服务。对这种服务的引用可以在 JNDI 服务器中查找到。</li><li><strong>Context / 初始的 Context</strong> - JNDI Context 带有对要查找的服务的引用。</li><li><strong>服务定位器（Service Locator）</strong> - 服务定位器是通过 JNDI 查找和缓存服务来获取服务的单点接触。</li><li><strong>缓存（Cache）</strong> - 缓存存储服务的引用，以便复用它们。</li><li><strong>客户端（Client）</strong> - Client 是通过 ServiceLocator 调用服务的对象。<a id="more"></a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;服务定位器模式（Service Locator Pattern）用在我们想使用 JNDI 查询定位各种服务的时候。考虑到为某个服务查找 JNDI 的代价很高，服务定位器模式充分利用了缓存技术。在首次请求某个服务时，服务定位器在 JNDI 中查找服务，并缓存该服务对象。当再次请求相同的服务时，服务定位器会在它的缓存中查找，这样可以在很大程度上提高应用程序的性能。以下是这种设计模式的实体。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;服务（Service）&lt;/strong&gt; - 实际处理请求的服务。对这种服务的引用可以在 JNDI 服务器中查找到。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Context / 初始的 Context&lt;/strong&gt; - JNDI Context 带有对要查找的服务的引用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务定位器（Service Locator）&lt;/strong&gt; - 服务定位器是通过 JNDI 查找和缓存服务来获取服务的单点接触。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓存（Cache）&lt;/strong&gt; - 缓存存储服务的引用，以便复用它们。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;客户端（Client）&lt;/strong&gt; - Client 是通过 ServiceLocator 调用服务的对象。
    
    </summary>
    
      <category term="设计模式" scheme="https://dongme.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="服务器定位模式" scheme="https://dongme.site/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9A%E4%BD%8D%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之拦截过滤器模式</title>
    <link href="https://dongme.site/2018/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%8B%A6%E6%88%AA%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongme.site/2018/10/21/设计模式之拦截过滤器模式/</id>
    <published>2018-10-21T04:41:00.000Z</published>
    <updated>2018-10-21T04:45:50.414Z</updated>
    
    <content type="html"><![CDATA[<p>拦截过滤器模式（Intercepting Filter Pattern）用于对应用程序的请求或响应做一些预处理/后处理。定义过滤器，并在把请求传给实际目标应用程序之前应用在请求上。过滤器可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。</p><ul><li><strong>过滤器（Filter）</strong> - 过滤器在请求处理程序执行请求之前或之后，执行某些任务。</li><li><strong>过滤器链（Filter Chain）</strong> - 过滤器链带有多个过滤器，并在 Target 上按照定义的顺序执行这些过滤器。</li><li><strong>Target</strong> - Target 对象是请求处理程序。</li><li><strong>过滤管理器（Filter Manager）</strong> - 过滤管理器管理过滤器和过滤器链。</li><li><strong>客户端（Client）</strong> - Client 是向 Target 对象发送请求的对象。<a id="more"></a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;拦截过滤器模式（Intercepting Filter Pattern）用于对应用程序的请求或响应做一些预处理/后处理。定义过滤器，并在把请求传给实际目标应用程序之前应用在请求上。过滤器可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;过滤器（Filter）&lt;/strong&gt; - 过滤器在请求处理程序执行请求之前或之后，执行某些任务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;过滤器链（Filter Chain）&lt;/strong&gt; - 过滤器链带有多个过滤器，并在 Target 上按照定义的顺序执行这些过滤器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Target&lt;/strong&gt; - Target 对象是请求处理程序。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;过滤管理器（Filter Manager）&lt;/strong&gt; - 过滤管理器管理过滤器和过滤器链。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;客户端（Client）&lt;/strong&gt; - Client 是向 Target 对象发送请求的对象。
    
    </summary>
    
      <category term="设计模式" scheme="https://dongme.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="拦截过滤器模式" scheme="https://dongme.site/tags/%E6%8B%A6%E6%88%AA%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之前端控制器模式</title>
    <link href="https://dongme.site/2018/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%89%8D%E7%AB%AF%E6%8E%A7%E5%88%B6%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongme.site/2018/10/21/设计模式之前端控制器模式/</id>
    <published>2018-10-21T04:40:00.000Z</published>
    <updated>2018-10-21T04:46:19.094Z</updated>
    
    <content type="html"><![CDATA[<p>前端控制器模式（Front Controller Pattern）是用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。</p><ul><li><strong>前端控制器（Front Controller）</strong> - 处理应用程序所有类型请求的单个处理程序，应用程序可以是基于 web 的应用程序，也可以是基于桌面的应用程序。</li><li><strong>调度器（Dispatcher）</strong> - 前端控制器可能使用一个调度器对象来调度请求到相应的具体处理程序。</li><li><strong>视图（View）</strong> - 视图是为请求而创建的对象。<a id="more"></a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端控制器模式（Front Controller Pattern）是用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;前端控制器（Front Controller）&lt;/strong&gt; - 处理应用程序所有类型请求的单个处理程序，应用程序可以是基于 web 的应用程序，也可以是基于桌面的应用程序。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;调度器（Dispatcher）&lt;/strong&gt; - 前端控制器可能使用一个调度器对象来调度请求到相应的具体处理程序。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;视图（View）&lt;/strong&gt; - 视图是为请求而创建的对象。
    
    </summary>
    
      <category term="设计模式" scheme="https://dongme.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="前端控制器模式" scheme="https://dongme.site/tags/%E5%89%8D%E7%AB%AF%E6%8E%A7%E5%88%B6%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之数据访问对象模式</title>
    <link href="https://dongme.site/2018/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongme.site/2018/10/21/设计模式之数据访问对象模式/</id>
    <published>2018-10-21T04:38:00.000Z</published>
    <updated>2018-10-21T04:39:48.091Z</updated>
    
    <content type="html"><![CDATA[<p>数据访问对象模式（Data Access Object Pattern）或 DAO 模式用于把低级的数据访问 API 或操作从高级的业务服务中分离出来。以下是数据访问对象模式的参与者。</p><ul><li><strong>数据访问对象接口（Data Access Object Interface）</strong> - 该接口定义了在一个模型对象上要执行的标准操作。</li><li><strong>数据访问对象实体类（Data Access Object concrete class）</strong> - 该类实现了上述的接口。该类负责从数据源获取数据，数据源可以是数据库，也可以是 xml，或者是其他的存储机制。</li><li><strong>模型对象/数值对象（Model Object/Value Object）</strong> - 该对象是简单的 POJO，包含了 get/set 方法来存储通过使用 DAO 类检索到的数据。<a id="more"></a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据访问对象模式（Data Access Object Pattern）或 DAO 模式用于把低级的数据访问 API 或操作从高级的业务服务中分离出来。以下是数据访问对象模式的参与者。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数据访问对象接口（Data Access Object Interface）&lt;/strong&gt; - 该接口定义了在一个模型对象上要执行的标准操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据访问对象实体类（Data Access Object concrete class）&lt;/strong&gt; - 该类实现了上述的接口。该类负责从数据源获取数据，数据源可以是数据库，也可以是 xml，或者是其他的存储机制。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;模型对象/数值对象（Model Object/Value Object）&lt;/strong&gt; - 该对象是简单的 POJO，包含了 get/set 方法来存储通过使用 DAO 类检索到的数据。
    
    </summary>
    
      <category term="设计模式" scheme="https://dongme.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="数据访问对象模式" scheme="https://dongme.site/tags/%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之组合实体模式</title>
    <link href="https://dongme.site/2018/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%84%E5%90%88%E5%AE%9E%E4%BD%93%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongme.site/2018/10/21/设计模式之组合实体模式/</id>
    <published>2018-10-21T04:34:04.000Z</published>
    <updated>2018-10-21T04:35:59.932Z</updated>
    
    <content type="html"><![CDATA[<p>组合实体模式（Composite Entity Pattern）用在 EJB 持久化机制中。一个组合实体是一个 EJB 实体 bean，代表了对象的图解。当更新一个组合实体时，内部依赖对象 beans 会自动更新，因为它们是由 EJB 实体 bean 管理的。以下是组合实体 bean 的参与者。</p><ul><li><strong>组合实体（Composite Entity）</strong> - 它是主要的实体 bean。它可以是粗粒的，或者可以包含一个粗粒度对象，用于持续生命周期。</li><li><strong>粗粒度对象（Coarse-Grained Object）</strong> - 该对象包含依赖对象。它有自己的生命周期，也能管理依赖对象的生命周期。</li><li><strong>依赖对象（Dependent Object）</strong> - 依赖对象是一个持续生命周期依赖于粗粒度对象的对象。</li><li><strong>策略（Strategies）</strong> - 策略表示如何实现组合实体。<a id="more"></a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;组合实体模式（Composite Entity Pattern）用在 EJB 持久化机制中。一个组合实体是一个 EJB 实体 bean，代表了对象的图解。当更新一个组合实体时，内部依赖对象 beans 会自动更新，因为它们是由 EJB 实体 bean 管理的。以下是组合实体 bean 的参与者。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;组合实体（Composite Entity）&lt;/strong&gt; - 它是主要的实体 bean。它可以是粗粒的，或者可以包含一个粗粒度对象，用于持续生命周期。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;粗粒度对象（Coarse-Grained Object）&lt;/strong&gt; - 该对象包含依赖对象。它有自己的生命周期，也能管理依赖对象的生命周期。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;依赖对象（Dependent Object）&lt;/strong&gt; - 依赖对象是一个持续生命周期依赖于粗粒度对象的对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;策略（Strategies）&lt;/strong&gt; - 策略表示如何实现组合实体。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式之业务代表模式</title>
    <link href="https://dongme.site/2018/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%B8%9A%E5%8A%A1%E4%BB%A3%E8%A1%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongme.site/2018/10/21/设计模式之业务代表模式/</id>
    <published>2018-10-21T04:32:36.000Z</published>
    <updated>2018-10-21T04:33:41.205Z</updated>
    
    <content type="html"><![CDATA[<p>业务代表模式（Business Delegate Pattern）用于对表示层和业务层解耦。它基本上是用来减少通信或对表示层代码中的业务层代码的远程查询功能。在业务层中我们有以下实体。</p><ul><li><strong>客户端（Client）</strong> - 表示层代码可以是 JSP、servlet 或 UI java 代码。</li><li><strong>业务代表（Business Delegate）</strong> - 一个为客户端实体提供的入口类，它提供了对业务服务方法的访问。</li><li><strong>查询服务（LookUp Service）</strong> - 查找服务对象负责获取相关的业务实现，并提供业务对象对业务代表对象的访问。</li><li><strong>业务服务（Business Service）</strong> - 业务服务接口。实现了该业务服务的实体类，提供了实际的业务实现逻辑。<a id="more"></a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;业务代表模式（Business Delegate Pattern）用于对表示层和业务层解耦。它基本上是用来减少通信或对表示层代码中的业务层代码的远程查询功能。在业务层中我们有以下实体。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;客户端（Client）&lt;/strong&gt; - 表示层代码可以是 JSP、servlet 或 UI java 代码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;业务代表（Business Delegate）&lt;/strong&gt; - 一个为客户端实体提供的入口类，它提供了对业务服务方法的访问。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;查询服务（LookUp Service）&lt;/strong&gt; - 查找服务对象负责获取相关的业务实现，并提供业务对象对业务代表对象的访问。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;业务服务（Business Service）&lt;/strong&gt; - 业务服务接口。实现了该业务服务的实体类，提供了实际的业务实现逻辑。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式之MVC 模式</title>
    <link href="https://dongme.site/2018/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BMVC-%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongme.site/2018/10/21/设计模式之MVC-模式/</id>
    <published>2018-10-21T04:29:36.000Z</published>
    <updated>2018-10-21T04:32:11.353Z</updated>
    
    <content type="html"><![CDATA[<p>MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。</p><ul><li><strong>Model（模型）</strong> - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。  </li><li><strong>View（视图）</strong> - 视图代表模型包含的数据的可视化。  </li><li><strong>Controller（控制器）</strong> - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。<br><img src="http://ombpxfki1.bkt.clouddn.com/1540096265471noao1rih.png?imageslim" alt="paste image">  </li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Model（模型）&lt;/strong&gt; - 模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;View（视图）&lt;/strong&gt; - 视图代表模型包含的数据的可视化。  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Controller（控制器）&lt;/strong&gt; - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。&lt;br&gt;&lt;img src=&quot;http://ombpxfki1.bkt.clouddn.com/1540096265471noao1rih.png?imageslim&quot; alt=&quot;paste image&quot;&gt;  &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式之访问者模式</title>
    <link href="https://dongme.site/2018/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongme.site/2018/10/21/设计模式之访问者模式/</id>
    <published>2018-10-21T04:28:00.000Z</published>
    <updated>2018-10-21T04:29:00.600Z</updated>
    
    <content type="html"><![CDATA[<p>在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://dongme.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="访问者模式" scheme="https://dongme.site/tags/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之模板模式</title>
    <link href="https://dongme.site/2018/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B/"/>
    <id>https://dongme.site/2018/10/21/设计模式之/</id>
    <published>2018-10-21T04:27:25.000Z</published>
    <updated>2018-10-21T04:28:00.363Z</updated>
    
    <content type="html"><![CDATA[<p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式之策略模式</title>
    <link href="https://dongme.site/2018/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongme.site/2018/10/21/设计模式之策略模式/</id>
    <published>2018-10-21T04:26:45.000Z</published>
    <updated>2018-10-21T04:27:05.278Z</updated>
    
    <content type="html"><![CDATA[<p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。</p><p>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。&lt;/p&gt;
&lt;p&gt;在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式之空对象模式</title>
    <link href="https://dongme.site/2018/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongme.site/2018/10/21/设计模式之空对象模式/</id>
    <published>2018-10-21T04:25:52.000Z</published>
    <updated>2018-10-21T04:26:21.415Z</updated>
    
    <content type="html"><![CDATA[<p>在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。这样的 Null 对象也可以在数据不可用的时候提供默认的行为。</p><p>在空对象模式中，我们创建一个指定各种要执行的操作的抽象类和扩展该类的实体类，还创建一个未对该类做任何实现的空对象类，该空对象类将无缝地使用在需要检查空值的地方。<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。这样的 Null 对象也可以在数据不可用的时候提供默认的行为。&lt;/p&gt;
&lt;p&gt;在空对象模式中，我们创建一个指定各种要执行的操作的抽象类和扩展该类的实体类，还创建一个未对该类做任何实现的空对象类，该空对象类将无缝地使用在需要检查空值的地方。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式之状态模式</title>
    <link href="https://dongme.site/2018/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongme.site/2018/10/21/设计模式之状态模式/</id>
    <published>2018-10-21T04:25:04.000Z</published>
    <updated>2018-10-21T04:25:27.788Z</updated>
    
    <content type="html"><![CDATA[<p>在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。</p><p>在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。&lt;/p&gt;
&lt;p&gt;在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式之观察者模式</title>
    <link href="https://dongme.site/2018/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongme.site/2018/10/21/设计模式之观察者模式/</id>
    <published>2018-10-21T04:24:14.000Z</published>
    <updated>2018-10-21T04:24:38.335Z</updated>
    
    <content type="html"><![CDATA[<p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式之备忘录模式</title>
    <link href="https://dongme.site/2018/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongme.site/2018/10/21/设计模式之备忘录模式/</id>
    <published>2018-10-21T04:23:16.000Z</published>
    <updated>2018-10-21T04:23:43.504Z</updated>
    
    <content type="html"><![CDATA[<p>备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式之迭代器模式</title>
    <link href="https://dongme.site/2018/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongme.site/2018/10/21/设计模式之迭代器模式/</id>
    <published>2018-10-21T04:21:10.000Z</published>
    <updated>2018-10-21T04:21:34.537Z</updated>
    
    <content type="html"><![CDATA[<p>代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。</p><p>迭代器模式属于行为型模式。<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。&lt;/p&gt;
&lt;p&gt;迭代器模式属于行为型模式。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式之中介者模式</title>
    <link href="https://dongme.site/2018/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongme.site/2018/10/21/设计模式之中介者模式/</id>
    <published>2018-10-21T04:21:00.000Z</published>
    <updated>2018-10-21T04:22:37.553Z</updated>
    
    <content type="html"><![CDATA[<p>中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://dongme.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="中介者模式" scheme="https://dongme.site/tags/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之解释器模式</title>
    <link href="https://dongme.site/2018/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongme.site/2018/10/21/设计模式之解释器模式/</id>
    <published>2018-10-21T04:19:00.000Z</published>
    <updated>2018-10-21T04:20:34.800Z</updated>
    
    <content type="html"><![CDATA[<p>解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://dongme.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="解释器模式" scheme="https://dongme.site/tags/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之命令模式</title>
    <link href="https://dongme.site/2018/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongme.site/2018/10/21/设计模式之命令模式/</id>
    <published>2018-10-21T04:17:00.000Z</published>
    <updated>2018-10-21T04:19:45.879Z</updated>
    
    <content type="html"><![CDATA[<p>命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://dongme.site/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="命令模式" scheme="https://dongme.site/tags/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
