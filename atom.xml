<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>alvin&#39;s blog</title>
  
  <subtitle>Good memory is worse than bad writing</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dongz.me/"/>
  <updated>2018-12-18T15:43:52.371Z</updated>
  <id>https://dongz.me/</id>
  
  <author>
    <name>alvin dong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>oracle递归查询</title>
    <link href="https://dongz.me/2018/12/18/oracle%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2/"/>
    <id>https://dongz.me/2018/12/18/oracle递归查询/</id>
    <published>2018-12-18T15:05:00.000Z</published>
    <updated>2018-12-18T15:43:52.371Z</updated>
    
    <content type="html"><![CDATA[<p>工作中遇到了递归查询部门树的需求，之前虽然用过，但隔的时间久了记不清具体用法。在这里mark一下，重新熟悉下<br><a id="more"></a></p><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span>  <span class="keyword">table</span> dept_tree(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> ,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">parent</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">comment</span> <span class="keyword">on</span> <span class="keyword">column</span> dept_tree.id <span class="keyword">is</span> <span class="string">'主键'</span>;</span><br><span class="line"><span class="keyword">comment</span> <span class="keyword">on</span> <span class="keyword">column</span> dept_tree.name <span class="keyword">is</span> <span class="string">'部门名称'</span>;</span><br><span class="line"><span class="keyword">comment</span> <span class="keyword">on</span> <span class="keyword">column</span> dept_tree.parent <span class="keyword">is</span> <span class="string">'父部门主键'</span>;</span><br></pre></td></tr></table></figure><h2 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h2><p>执行 <code>desc dept_tree;</code>  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">名称     空值       类型           </span><br><span class="line"><span class="comment">------ -------- ------------ </span></span><br><span class="line">ID     NOT NULL NUMBER(38)   </span><br><span class="line">NAME   NOT NULL VARCHAR2(20) </span><br><span class="line">PARENT NOT NULL NUMBER(38)</span><br></pre></td></tr></table></figure><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">1</span> , <span class="string">'部门1'</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">2</span> , <span class="string">'部门2'</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">3</span> , <span class="string">'部门3'</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">4</span> , <span class="string">'部门1-1'</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">5</span> , <span class="string">'部门1-2'</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">6</span> , <span class="string">'部门1-3'</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">7</span> , <span class="string">'部门2-1'</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">8</span> , <span class="string">'部门2-2'</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">9</span> , <span class="string">'部门3-1'</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">10</span> , <span class="string">'部门3-2'</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">11</span> , <span class="string">'部门3-3'</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">12</span> , <span class="string">'部门3-4'</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">13</span> , <span class="string">'部门3-5'</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">14</span> , <span class="string">'部门3-6'</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">15</span> , <span class="string">'部门3-6'</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">16</span> , <span class="string">'部门2-2-1'</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">17</span> , <span class="string">'部门2-2-2'</span>, <span class="number">8</span>);</span><br></pre></td></tr></table></figure><h2 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h2><h3 id="递归语法"><a href="#递归语法" class="headerlink" title="递归语法"></a>递归语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> [<span class="keyword">column</span>, ...] <span class="keyword">from</span> tablename</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> [condition1]</span><br><span class="line"><span class="keyword">connect</span> <span class="keyword">by</span> [condition2]</span><br><span class="line"><span class="keyword">where</span> [condition3];</span><br></pre></td></tr></table></figure><p><strong>condition1:</strong><br>根结点的限定语句，可以放宽限定条件，以取得多个根结点，实际就是多棵树；省略该条件或设置为1=1则是每个节点作为根节点遍历一遍。  </p><p><strong>condition2:</strong><br>连接条件，其中用PRIOR表示上一条记录。比如 CONNECT BY PRIOR id = parent，就是说上一条记录的id 是本条记录的parent，即本记录的父亲是上一条记录，递归方式为自顶向下顺序遍历；CONNECT BY id =  PRIOR parent，就是说上一条记录的parent是本条记录的id，即上一条记录的父亲是本记录，递归方式为自底向上顺序遍历。  </p><p><strong>condition3:</strong><br>是过滤条件，用于对返回的所有记录进行过滤。</p><h3 id="递归实例"><a href="#递归实例" class="headerlink" title="递归实例"></a>递归实例</h3><h4 id="根部门为17，向上遍历所有节点"><a href="#根部门为17，向上遍历所有节点" class="headerlink" title="根部门为17，向上遍历所有节点"></a>根部门为17，向上遍历所有节点</h4><blockquote><p>执行sql: </p></blockquote>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span>,sys_connect_by_path(<span class="keyword">name</span>, <span class="string">'=&gt;'</span>) namejoins, <span class="keyword">level</span></span><br><span class="line"><span class="keyword">from</span> dept_tree</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> dept_tree.id=<span class="number">17</span></span><br><span class="line"><span class="keyword">connect</span> <span class="keyword">by</span>  <span class="keyword">id</span> = <span class="keyword">prior</span> <span class="keyword">parent</span></span><br></pre></td></tr></table></figure><blockquote><p>执行结果:  </p></blockquote><table><thead><tr><th style="text-align:center">ID</th><th style="text-align:center">NAME</th><th style="text-align:center">NAMEJOINS</th><th style="text-align:center">LEVEL</th></tr></thead><tbody><tr><td style="text-align:center">17</td><td style="text-align:center">部门2-2-2</td><td style="text-align:center">=&gt;部门2-2-2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">部门2-2</td><td style="text-align:center">=&gt;部门2-2-2=&gt;部门2-2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">部门2</td><td style="text-align:center">=&gt;部门2-2-2=&gt;部门2-2=&gt;部门2</td><td style="text-align:center">3</td></tr></tbody></table><h4 id="根部门为17，向下遍历所有节点"><a href="#根部门为17，向下遍历所有节点" class="headerlink" title="根部门为17，向下遍历所有节点"></a>根部门为17，向下遍历所有节点</h4><blockquote><p>执行sql:  </p></blockquote>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span>,sys_connect_by_path(<span class="keyword">name</span>, <span class="string">'=&gt;'</span>) namejoins, <span class="keyword">level</span></span><br><span class="line"><span class="keyword">from</span> dept_tree</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> dept_tree.id=<span class="number">17</span></span><br><span class="line"><span class="keyword">connect</span> <span class="keyword">by</span>  <span class="keyword">prior</span> <span class="keyword">id</span> = <span class="keyword">parent</span></span><br></pre></td></tr></table></figure><blockquote><p>执行结果:  </p></blockquote><table><thead><tr><th style="text-align:center">ID</th><th style="text-align:center">NAME</th><th style="text-align:center">NAMEJOINS</th><th style="text-align:center">LEVEL</th></tr></thead><tbody><tr><td style="text-align:center">17</td><td style="text-align:center">部门2-2-2</td><td style="text-align:center">=&gt;部门2-2-2</td><td style="text-align:center">1</td></tr></tbody></table><h4 id="根部门不设置过滤条件，以所有节点作为根节点遍历"><a href="#根部门不设置过滤条件，以所有节点作为根节点遍历" class="headerlink" title="根部门不设置过滤条件，以所有节点作为根节点遍历"></a>根部门不设置过滤条件，以所有节点作为根节点遍历</h4><blockquote><p>执行sql: </p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span>,sys_connect_by_path(<span class="keyword">name</span>, <span class="string">'=&gt;'</span>) namejoins, <span class="keyword">level</span></span><br><span class="line"><span class="keyword">from</span> dept_tree</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> <span class="number">1</span>=<span class="number">1</span></span><br><span class="line"><span class="keyword">connect</span> <span class="keyword">by</span>  <span class="keyword">prior</span> <span class="keyword">id</span> = <span class="keyword">parent</span></span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string">&gt; 执行结果:  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">|ID|NAME|NAMEJOINS|LEVEL|</span></span><br><span class="line"><span class="string">|:--:|:--:|:--:|:--:|</span></span><br><span class="line"><span class="string">|1|部门1|=&gt;部门1|1|</span></span><br><span class="line"><span class="string">|4|部门1-1|=&gt;部门1=&gt;部门1-1|2|</span></span><br><span class="line"><span class="string">|5|部门1-2|=&gt;部门1=&gt;部门1-2|2|</span></span><br><span class="line"><span class="string">|6|部门1-3|=&gt;部门1=&gt;部门1-3|2|</span></span><br><span class="line"><span class="string">|2|部门2|=&gt;部门2|1|</span></span><br><span class="line"><span class="string">|7|部门2-1|=&gt;部门2=&gt;部门2-1|2|</span></span><br><span class="line"><span class="string">|8|部门2-2|=&gt;部门2=&gt;部门2-2|2|</span></span><br><span class="line"><span class="string">|16|部门2-2-1|=&gt;部门2=&gt;部门2-2=&gt;部门2-2-1|3|</span></span><br><span class="line"><span class="string">|17|部门2-2-2|=&gt;部门2=&gt;部门2-2=&gt;部门2-2-2|3|</span></span><br><span class="line"><span class="string">|3|部门3|=&gt;部门3|1|</span></span><br><span class="line"><span class="string">|9|部门3-1|=&gt;部门3=&gt;部门3-1|2|</span></span><br><span class="line"><span class="string">|10|部门3-2|=&gt;部门3=&gt;部门3-2|2|</span></span><br><span class="line"><span class="string">|11|部门3-3|=&gt;部门3=&gt;部门3-3|2|</span></span><br><span class="line"><span class="string">|12|部门3-4|=&gt;部门3=&gt;部门3-4|2|</span></span><br><span class="line"><span class="string">|13|部门3-5|=&gt;部门3=&gt;部门3-5|2|</span></span><br><span class="line"><span class="string">|14|部门3-6|=&gt;部门3=&gt;部门3-6|2|</span></span><br><span class="line"><span class="string">|15|部门3-6|=&gt;部门3=&gt;部门3-6|2|</span></span><br><span class="line"><span class="string">|4|部门1-1|=&gt;部门1-1|1|</span></span><br><span class="line"><span class="string">|5|部门1-2|=&gt;部门1-2|1|</span></span><br><span class="line"><span class="string">|6|部门1-3|=&gt;部门1-3|1|</span></span><br><span class="line"><span class="string">|7|部门2-1|=&gt;部门2-1|1|</span></span><br><span class="line"><span class="string">|8|部门2-2|=&gt;部门2-2|1|</span></span><br><span class="line"><span class="string">|16|部门2-2-1|=&gt;部门2-2=&gt;部门2-2-1|2|</span></span><br><span class="line"><span class="string">|17|部门2-2-2|=&gt;部门2-2=&gt;部门2-2-2|2|</span></span><br><span class="line"><span class="string">|9|部门3-1|=&gt;部门3-1|1|</span></span><br><span class="line"><span class="string">|10|部门3-2|=&gt;部门3-2|1|</span></span><br><span class="line"><span class="string">|11|部门3-3|=&gt;部门3-3|1|</span></span><br><span class="line"><span class="string">|12|部门3-4|=&gt;部门3-4|1|</span></span><br><span class="line"><span class="string">|13|部门3-5|=&gt;部门3-5|1|</span></span><br><span class="line"><span class="string">|14|部门3-6|=&gt;部门3-6|1|</span></span><br><span class="line"><span class="string">|15|部门3-6|=&gt;部门3-6|1|</span></span><br><span class="line"><span class="string">|16|部门2-2-1|=&gt;部门2-2-1|1|</span></span><br><span class="line"><span class="string">|17|部门2-2-2|=&gt;部门2-2-2|1|    </span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt; 这时自底向上执行如下sql输出结果同上:     </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">  `</span><span class="string">``</span><span class="keyword">sql</span></span><br><span class="line">  <span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span>,sys_connect_by_path(<span class="keyword">name</span>, <span class="string">'=&gt;'</span>) namejoins, <span class="keyword">level</span></span><br><span class="line">  <span class="keyword">from</span> dept_tree</span><br><span class="line">  <span class="keyword">start</span> <span class="keyword">with</span> <span class="number">1</span>=<span class="number">1</span></span><br><span class="line">  <span class="keyword">connect</span> <span class="keyword">by</span> <span class="keyword">id</span> = <span class="keyword">prior</span> <span class="keyword">parent</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作中遇到了递归查询部门树的需求，之前虽然用过，但隔的时间久了记不清具体用法。在这里mark一下，重新熟悉下&lt;br&gt;
    
    </summary>
    
      <category term="积累" scheme="https://dongz.me/categories/%E7%A7%AF%E7%B4%AF/"/>
    
      <category term="数据存储" scheme="https://dongz.me/categories/%E7%A7%AF%E7%B4%AF/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>HTTP常见状态码</title>
    <link href="https://dongz.me/2018/12/16/HTTP%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <id>https://dongz.me/2018/12/16/HTTP常见状态码/</id>
    <published>2018-12-16T15:12:00.000Z</published>
    <updated>2018-12-16T15:14:09.557Z</updated>
    
    <content type="html"><![CDATA[<p>当浏览器向服务器发送请求后，服务端会返回一个状态码用以表示服务器当响应状态，可以根据具体的返回码分析请求状态及问题出现的可能原因。<a id="more"></a></p><h2 id="1xx临时响应"><a href="#1xx临时响应" class="headerlink" title="1xx临时响应"></a>1xx临时响应</h2><blockquote><p>表示临时响应并需要请求者继续执行操作的状态码  </p></blockquote><ul><li>100 (继续) 服务器仅接收到部分请求，客户端应该继续发送其余的请求</li><li>101 (切换协议) 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</li></ul><h2 id="2xx成功"><a href="#2xx成功" class="headerlink" title="2xx成功"></a>2xx成功</h2><blockquote><p>表示成功处理了请求的状态码</p></blockquote><ul><li>200 (成功) 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页</li><li>201 (已创建) 成功请求并创建了新的资源</li><li>202 (已接受) 请求已被服务器接受，但是处理未完成</li><li>203 (非授权信息) 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</li><li>204 (无内容) 服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</li><li>205 (重置内容) 服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</li><li>206 (部分内容) 客户发送了一个带有Range头的GET请求，服务器完成了它</li></ul><h2 id="3xx重定向"><a href="#3xx重定向" class="headerlink" title="3xx重定向"></a>3xx重定向</h2><blockquote><p>表示要完成请求，需要进一步操作。 通常，这些状态码用来重定向</p></blockquote><ul><li>300 (多种选择) 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</li><li>301 (永久移动) 所请求的页面已经转移至新的URI，并将请求转到新URI</li><li>302 (临时移动) 与301类似。但资源只是临时被移动。客户端应继续使用原有URI</li><li>303 (查看其他地址) 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码</li><li>304 (未修改) 所请求的资源未修改（一般是提供If-Modified-Since头表示客户只想比指定日期更新的资源），服务器返回此状态码时，不会返回任何资源</li><li>305 (使用代理) 客户请求的资源应该通过Location头所指明的代理服务器提取</li><li>307 (临时重定向) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</li></ul><h2 id="4xx客户端错误"><a href="#4xx客户端错误" class="headerlink" title="4xx客户端错误"></a>4xx客户端错误</h2><blockquote><p>这些状态码表示请求可能出错，妨碍了服务器的处理。</p></blockquote><ul><li>400 (错误请求) 服务器未能理解请求</li><li>401 (未授权) 请求要求用户的身份认证</li><li>403 (禁止) 服务器端拒绝执行客户端请求</li><li>404 (未找到) 服务器找不到请求的网页</li><li>405 (方法禁用) 请求中指定的方法不被允许</li><li>406 (不接受) 服务器无法根据客户端请求的内容特性完成请求</li><li>407 (需要代理授权) 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</li><li>408 (请求超时) 请求超出了服务器的等待时间</li><li>409 (冲突) 服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息</li><li>410 (已删除) 如果请求的资源已永久删除，服务器就会返回此响应</li><li>411 (需要有效长度) 服务器无法处理客户端发送的不带Content-Length的请求信息</li><li>412 (未满足前提条件) 请求中的前提条件被服务器判定为失败</li><li>413 (请求实体过大) 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</li><li>414 (请求的 URI 过长) 请求的URI过长（URI通常为网址），服务器无法处理</li><li>415 (不支持的媒体类型) 服务器无法处理请求附带的媒体格式</li><li>416 (请求范围不符合要求) 服务器不能满足客户在请求中指定的Range头</li><li>417 (未满足期望值) 服务器无法满足Expect的请求头信息</li></ul><h2 id="5xx服务器端错误"><a href="#5xx服务器端错误" class="headerlink" title="5xx服务器端错误"></a>5xx服务器端错误</h2><blockquote><p>表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</p></blockquote><ul><li>500 (服务器内部错误) 服务器遇到错误，无法完成请求</li><li>501 (尚未实施) 服务器不具备完成请求的功能 例如，服务器无法识别请求方法时可能会返回此代码</li><li>502 (错误网关) 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</li><li>503 (服务不可用) 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</li><li>504 (网关超时) 服务器作为网关或代理，但是没有及时从上游服务器收到请求</li><li>505 (HTTP 版本不受支持) 服务器不支持请求中所用的 HTTP 协议版本</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当浏览器向服务器发送请求后，服务端会返回一个状态码用以表示服务器当响应状态，可以根据具体的返回码分析请求状态及问题出现的可能原因。
    
    </summary>
    
      <category term="网络" scheme="https://dongz.me/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>[music]-[ツナ覚醒]</title>
    <link href="https://dongz.me/2018/12/13/music-%E3%83%84%E3%83%8A%E8%A6%9A%E9%86%92/"/>
    <id>https://dongz.me/2018/12/13/music-ツナ覚醒/</id>
    <published>2018-12-12T16:28:00.000Z</published>
    <updated>2018-12-12T16:35:21.363Z</updated>
    
    <content type="html"><![CDATA[<p>一步超然动画片《家庭教师》中的插曲，特别喜欢这种燃炸天的节奏♡♡♡♡♡<br><a id="more"></a></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=29023858&auto=1&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一步超然动画片《家庭教师》中的插曲，特别喜欢这种燃炸天的节奏♡♡♡♡♡&lt;br&gt;
    
    </summary>
    
      <category term="音乐" scheme="https://dongz.me/categories/%E9%9F%B3%E4%B9%90/"/>
    
    
  </entry>
  
  <entry>
    <title>风暴之集合</title>
    <link href="https://dongz.me/2018/12/12/%E9%A3%8E%E6%9A%B4%E4%B9%8B%E9%9B%86%E5%90%88/"/>
    <id>https://dongz.me/2018/12/12/风暴之集合/</id>
    <published>2018-12-11T16:51:00.000Z</published>
    <updated>2018-12-11T16:57:41.497Z</updated>
    
    <content type="html"><![CDATA[<p>java中容器，也称集合可以容纳其它类型数据。在平时也接触类不少比如ArrayList、HashSet、LinkedList、HashMap、TreeMap等等，但真要细说还真一知半解，大体风暴类一下，有不当的地方欢迎评论中指出～～<br><a id="more"></a>  </p><h1 id="风暴之集合"><a href="#风暴之集合" class="headerlink" title="风暴之集合"></a>风暴之集合</h1><p><img src="https://coding.net/u/alvin_me/p/blogpics/git/raw/master/rongqiorjihe.jpg" alt=""></p><p><a href="http://www.edrawsoft.cn/viewer/public/s/ec6e5017846566" target="_blank" rel="noopener">看大图</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java中容器，也称集合可以容纳其它类型数据。在平时也接触类不少比如ArrayList、HashSet、LinkedList、HashMap、TreeMap等等，但真要细说还真一知半解，大体风暴类一下，有不当的地方欢迎评论中指出～～&lt;br&gt;
    
    </summary>
    
      <category term="集合" scheme="https://dongz.me/categories/%E9%9B%86%E5%90%88/"/>
    
    
      <category term="集合" scheme="https://dongz.me/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>风暴之mysql</title>
    <link href="https://dongz.me/2018/12/11/%E9%A3%8E%E6%9A%B4%E4%B9%8Bmysql/"/>
    <id>https://dongz.me/2018/12/11/风暴之mysql/</id>
    <published>2018-12-10T16:40:00.000Z</published>
    <updated>2018-12-10T17:01:35.394Z</updated>
    
    <content type="html"><![CDATA[<p>本篇以mysql常见维度展开头脑风暴。维度包括数据的存储结构、数据库事务、mysql中常见的锁、mysql使用优化、mysql中常见日志。图中有不当的地方请留言指出～～<br><a id="more"></a>  </p><h1 id="风暴之mysql"><a href="#风暴之mysql" class="headerlink" title="风暴之mysql"></a>风暴之mysql</h1><p><img src="https://coding.net/u/alvin_me/p/blogpics/git/raw/master/mysql.jpg" alt=""></p><p><a href="http://www.edrawsoft.cn/viewer/public/s/b8368745248662" target="_blank" rel="noopener">看大图</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇以mysql常见维度展开头脑风暴。维度包括数据的存储结构、数据库事务、mysql中常见的锁、mysql使用优化、mysql中常见日志。图中有不当的地方请留言指出～～&lt;br&gt;
    
    </summary>
    
      <category term="数据存储" scheme="https://dongz.me/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="mysql" scheme="https://dongz.me/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>风暴之线上问题排查</title>
    <link href="https://dongz.me/2018/11/29/%E9%A3%8E%E6%9A%B4%E4%B9%8B%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    <id>https://dongz.me/2018/11/29/风暴之线上问题排查/</id>
    <published>2018-11-28T16:23:00.000Z</published>
    <updated>2018-12-10T17:02:37.966Z</updated>
    
    <content type="html"><![CDATA[<p>实际生产环境下，应用不可避免的会遇到各种各样的问题，要熟练掌握一些命令和工具，以快速排查定位线上问题。<br><a id="more"></a>  </p><h1 id="风暴之线上问题排查"><a href="#风暴之线上问题排查" class="headerlink" title="风暴之线上问题排查"></a>风暴之线上问题排查</h1><p><img src="https://coding.net/u/alvin_me/p/blogpics/git/raw/master/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5.png" alt=""></p><p><a href="http://www.edrawsoft.cn/viewer/public/s/72167602893328" target="_blank" rel="noopener">看大图</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实际生产环境下，应用不可避免的会遇到各种各样的问题，要熟练掌握一些命令和工具，以快速排查定位线上问题。&lt;br&gt;
    
    </summary>
    
      <category term="积累" scheme="https://dongz.me/categories/%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="问题排查" scheme="https://dongz.me/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>风暴之并发和多线程</title>
    <link href="https://dongz.me/2018/11/29/%E9%A3%8E%E6%9A%B4%E4%B9%8B%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://dongz.me/2018/11/29/风暴之并发和多线程/</id>
    <published>2018-11-28T16:18:00.000Z</published>
    <updated>2018-12-10T17:03:00.135Z</updated>
    
    <content type="html"><![CDATA[<p>并发和多线程是Java编程中避不开的话题，今天主要对并发和多线程相关知识进行下头脑风暴。<br><a id="more"></a></p><h1 id="风暴之并发和多线程"><a href="#风暴之并发和多线程" class="headerlink" title="风暴之并发和多线程"></a>风暴之并发和多线程</h1><p><img src="https://coding.net/u/alvin_me/p/blogpics/git/raw/master/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" alt=""></p><p><a href="http://www.edrawsoft.cn/viewer/public/s/7e9bd056155369" target="_blank" rel="noopener">看大图</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并发和多线程是Java编程中避不开的话题，今天主要对并发和多线程相关知识进行下头脑风暴。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://dongz.me/categories/java/"/>
    
    
      <category term="并发" scheme="https://dongz.me/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="多线程" scheme="https://dongz.me/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>风暴之Redis</title>
    <link href="https://dongz.me/2018/11/29/%E9%A3%8E%E6%9A%B4%E4%B9%8BRedis/"/>
    <id>https://dongz.me/2018/11/29/风暴之Redis/</id>
    <published>2018-11-28T16:01:00.000Z</published>
    <updated>2018-12-10T17:03:26.961Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。<br><a id="more"></a></p><h1 id="风暴之Redis"><a href="#风暴之Redis" class="headerlink" title="风暴之Redis"></a>风暴之Redis</h1><p><img src="https://coding.net/u/alvin_me/p/blogpics/git/raw/master/redis%E7%9F%A5%E8%AF%86.png" alt=""></p><p><a href="http://www.edrawsoft.cn/viewer/public/s/0be97318174746" target="_blank" rel="noopener">看大图</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。&lt;br&gt;
    
    </summary>
    
      <category term="数据存储" scheme="https://dongz.me/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="redis" scheme="https://dongz.me/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>风暴之JVM</title>
    <link href="https://dongz.me/2018/11/28/%E9%A3%8E%E6%9A%B4%E4%B9%8BJVM/"/>
    <id>https://dongz.me/2018/11/28/风暴之JVM/</id>
    <published>2018-11-28T15:51:00.000Z</published>
    <updated>2018-12-10T17:03:39.290Z</updated>
    
    <content type="html"><![CDATA[<p>Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够”一次编译，到处运行“的原因。了解JVM底层有助于理解Java工作原理，更好的编程。<br><a id="more"></a></p><h1 id="风暴之JVM"><a href="#风暴之JVM" class="headerlink" title="风暴之JVM"></a>风暴之JVM</h1><p><img src="https://coding.net/u/alvin_me/p/blogpics/git/raw/master/jvm%E7%9B%B8%E5%85%B3.jpg" alt="">  </p><p><a href="http://www.edrawsoft.cn/viewer/public/s/41a60748487374" target="_blank" rel="noopener">看大图</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够”一次编译，到处运行“的原因。了解JVM底层有助于理解Java工作原理，更好的编程。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://dongz.me/categories/java/"/>
    
    
      <category term="jvm" scheme="https://dongz.me/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>风暴之Spring事务</title>
    <link href="https://dongz.me/2018/10/27/%E9%A3%8E%E6%9A%B4%E4%B9%8BSpring%E4%BA%8B%E5%8A%A1/"/>
    <id>https://dongz.me/2018/10/27/风暴之Spring事务/</id>
    <published>2018-10-27T02:14:00.000Z</published>
    <updated>2018-12-10T17:04:18.020Z</updated>
    
    <content type="html"><![CDATA[<p>Spring 简单而强大的事务管理功能，包括编程式事务和声明式事务。通过对相关知识梳理，能够理解 Spring 事务管理的本质，并灵活运用之。<br><a id="more"></a></p><h1 id="风暴之Spring事务"><a href="#风暴之Spring事务" class="headerlink" title="风暴之Spring事务"></a>风暴之Spring事务</h1><p><img src="https://coding.net/u/alvin_me/p/blogpics/git/raw/master/spring%E4%BA%8B%E5%8A%A1.jpg" alt="Spring事务"></p><p><a href="http://www.edrawsoft.cn/viewer/public/s/4cbc1230271951" target="_blank" rel="noopener">看大图</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="https://www.ibm.com/developerworks/cn/education/opensource/os-cn-spring-trans/index.html" target="_blank" rel="noopener">全面分析 Spring 的编程式事务管理及声明式事务管理</a><br>[2] <a href="https://juejin.im/post/5b00c52ef265da0b95276091" target="_blank" rel="noopener">可能是最漂亮的Spring事务管理详解</a><br>[3] <a href="https://juejin.im/post/5a5c631e6fb9a01cb508cd3d" target="_blank" rel="noopener">Spring核心系列之Spring中的事务</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring 简单而强大的事务管理功能，包括编程式事务和声明式事务。通过对相关知识梳理，能够理解 Spring 事务管理的本质，并灵活运用之。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://dongz.me/categories/java/"/>
    
    
      <category term="spring" scheme="https://dongz.me/tags/spring/"/>
    
      <category term="事务" scheme="https://dongz.me/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>风暴之Aop</title>
    <link href="https://dongz.me/2018/10/25/%E9%A3%8E%E6%9A%B4%E4%B9%8BAop/"/>
    <id>https://dongz.me/2018/10/25/风暴之Aop/</id>
    <published>2018-10-24T16:34:00.000Z</published>
    <updated>2018-12-02T14:25:44.654Z</updated>
    
    <content type="html"><![CDATA[<p>面向切面编程<br><a id="more"></a></p><h1 id="风暴之Aop"><a href="#风暴之Aop" class="headerlink" title="风暴之Aop"></a>风暴之Aop</h1><p><img src="https://coding.net/u/alvin_me/p/blogpics/git/raw/master/spring%20aop.jpg" alt=""></p><p><a href="http://www.edrawsoft.cn/viewer/public/s/032fa832508900" target="_blank" rel="noopener">看大图</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/index.html" target="_blank" rel="noopener">Spring AOP 实现原理与 CGLIB 应用</a><br>[2] <a href="http://www.importnew.com/24305.html" target="_blank" rel="noopener">Spring AOP的实现原理</a><br>[3] <a href="https://juejin.im/post/5af3bd6f518825673954bf22" target="_blank" rel="noopener">Spring AOP实现原理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面向切面编程&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://dongz.me/categories/java/"/>
    
    
      <category term="aop" scheme="https://dongz.me/tags/aop/"/>
    
  </entry>
  
  <entry>
    <title>风暴之Rocketmq消息有序</title>
    <link href="https://dongz.me/2018/10/25/%E9%A3%8E%E6%9A%B4%E4%B9%8BRocketmq%E6%B6%88%E6%81%AF%E6%9C%89%E5%BA%8F/"/>
    <id>https://dongz.me/2018/10/25/风暴之Rocketmq消息有序/</id>
    <published>2018-10-24T16:17:00.000Z</published>
    <updated>2018-12-02T14:25:57.171Z</updated>
    
    <content type="html"><![CDATA[<p>Rocketmq消息有序知识梳理<br><a id="more"></a></p><h1 id="风暴之Rocketmq消息有序"><a href="#风暴之Rocketmq消息有序" class="headerlink" title="风暴之Rocketmq消息有序"></a>风暴之Rocketmq消息有序</h1><p><img src="https://coding.net/u/alvin_me/p/blogpics/git/raw/master/rocketmq%E6%9C%89%E5%BA%8F.jpg" alt="">  </p><p><a href="http://www.edrawsoft.cn/viewer/public/s/44af6152338359" target="_blank" rel="noopener">看大图</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="https://www.zhihu.com/question/30195969" target="_blank" rel="noopener">rocketmq怎么保证队列完全顺序消费？</a><br>[2] <a href="https://www.jianshu.com/p/453c6e7ff81c" target="_blank" rel="noopener">分布式开放消息系统(RocketMQ)的原理与实践</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Rocketmq消息有序知识梳理&lt;br&gt;
    
    </summary>
    
      <category term="消息" scheme="https://dongz.me/categories/%E6%B6%88%E6%81%AF/"/>
    
    
      <category term="rocketmq" scheme="https://dongz.me/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>风暴之分布式事务</title>
    <link href="https://dongz.me/2018/10/24/%E9%A3%8E%E6%9A%B4%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <id>https://dongz.me/2018/10/24/风暴之分布式事务/</id>
    <published>2018-10-23T16:23:00.000Z</published>
    <updated>2018-12-10T17:06:23.075Z</updated>
    
    <content type="html"><![CDATA[<p>分布式事务是企业集成中的一个技术难点，也是每一个分布式系统架构中都会涉及到的一个东西，特别是在微服务架构中，几乎可以说是无法避免，本文通过思维导图做一个简单的知识梳理。<br><a id="more"></a></p><h1 id="风暴之分布式事务"><a href="#风暴之分布式事务" class="headerlink" title="风暴之分布式事务"></a>风暴之分布式事务</h1><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="800" height="800" src="http://edrawcloudpubliccn.oss-cn-shenzhen.aliyuncs.com/viewer/self/220828/share/2018-10-31/1540946315/main.svg"></iframe><p><a href="http://www.edrawsoft.cn/viewer/public/s/4c0fe347331170" target="_blank" rel="noopener">看大图</a></p><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p>[1] <a href="https://draveness.me/distributed-transaction-principle" target="_blank" rel="noopener">分布式事务的实现原理</a><br>[2] <a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" target="_blank" rel="noopener">聊聊分布式事务，再说说解决方案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分布式事务是企业集成中的一个技术难点，也是每一个分布式系统架构中都会涉及到的一个东西，特别是在微服务架构中，几乎可以说是无法避免，本文通过思维导图做一个简单的知识梳理。&lt;br&gt;
    
    </summary>
    
      <category term="分布式" scheme="https://dongz.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式事务" scheme="https://dongz.me/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之传输对象模式</title>
    <link href="https://dongz.me/2018/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongz.me/2018/10/21/设计模式之传输对象模式/</id>
    <published>2018-10-21T04:46:00.000Z</published>
    <updated>2018-10-21T04:47:51.901Z</updated>
    
    <content type="html"><![CDATA[<p>传输对象模式（Transfer Object Pattern）用于从客户端向服务器一次性传递带有多个属性的数据。传输对象也被称为数值对象。传输对象是一个具有 getter/setter 方法的简单的 POJO 类，它是可序列化的，所以它可以通过网络传输。它没有任何的行为。服务器端的业务类通常从数据库读取数据，然后填充 POJO，并把它发送到客户端或按值传递它。对于客户端，传输对象是只读的。客户端可以创建自己的传输对象，并把它传递给服务器，以便一次性更新数据库中的数值。以下是这种设计模式的实体。</p><ul><li><strong>业务对象（Business Object）</strong> - 为传输对象填充数据的业务服务。</li><li><strong>传输对象（Transfer Object）</strong> - 简单的 POJO，只有设置/获取属性的方法。</li><li><strong>客户端（Client）</strong> - 客户端可以发送请求或者发送传输对象到业务对象。<a id="more"></a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传输对象模式（Transfer Object Pattern）用于从客户端向服务器一次性传递带有多个属性的数据。传输对象也被称为数值对象。传输对象是一个具有 getter/setter 方法的简单的 POJO 类，它是可序列化的，所以它可以通过网络传输。它没有任何的行为。服务器端的业务类通常从数据库读取数据，然后填充 POJO，并把它发送到客户端或按值传递它。对于客户端，传输对象是只读的。客户端可以创建自己的传输对象，并把它传递给服务器，以便一次性更新数据库中的数值。以下是这种设计模式的实体。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;业务对象（Business Object）&lt;/strong&gt; - 为传输对象填充数据的业务服务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;传输对象（Transfer Object）&lt;/strong&gt; - 简单的 POJO，只有设置/获取属性的方法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;客户端（Client）&lt;/strong&gt; - 客户端可以发送请求或者发送传输对象到业务对象。
    
    </summary>
    
      <category term="设计模式" scheme="https://dongz.me/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="传输对象模式" scheme="https://dongz.me/tags/%E4%BC%A0%E8%BE%93%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之服务定位器模式</title>
    <link href="https://dongz.me/2018/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%AE%9A%E4%BD%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongz.me/2018/10/21/设计模式之服务定位器模式/</id>
    <published>2018-10-21T04:44:00.000Z</published>
    <updated>2018-10-21T04:45:29.984Z</updated>
    
    <content type="html"><![CDATA[<p>服务定位器模式（Service Locator Pattern）用在我们想使用 JNDI 查询定位各种服务的时候。考虑到为某个服务查找 JNDI 的代价很高，服务定位器模式充分利用了缓存技术。在首次请求某个服务时，服务定位器在 JNDI 中查找服务，并缓存该服务对象。当再次请求相同的服务时，服务定位器会在它的缓存中查找，这样可以在很大程度上提高应用程序的性能。以下是这种设计模式的实体。</p><ul><li><strong>服务（Service）</strong> - 实际处理请求的服务。对这种服务的引用可以在 JNDI 服务器中查找到。</li><li><strong>Context / 初始的 Context</strong> - JNDI Context 带有对要查找的服务的引用。</li><li><strong>服务定位器（Service Locator）</strong> - 服务定位器是通过 JNDI 查找和缓存服务来获取服务的单点接触。</li><li><strong>缓存（Cache）</strong> - 缓存存储服务的引用，以便复用它们。</li><li><strong>客户端（Client）</strong> - Client 是通过 ServiceLocator 调用服务的对象。<a id="more"></a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;服务定位器模式（Service Locator Pattern）用在我们想使用 JNDI 查询定位各种服务的时候。考虑到为某个服务查找 JNDI 的代价很高，服务定位器模式充分利用了缓存技术。在首次请求某个服务时，服务定位器在 JNDI 中查找服务，并缓存该服务对象。当再次请求相同的服务时，服务定位器会在它的缓存中查找，这样可以在很大程度上提高应用程序的性能。以下是这种设计模式的实体。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;服务（Service）&lt;/strong&gt; - 实际处理请求的服务。对这种服务的引用可以在 JNDI 服务器中查找到。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Context / 初始的 Context&lt;/strong&gt; - JNDI Context 带有对要查找的服务的引用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务定位器（Service Locator）&lt;/strong&gt; - 服务定位器是通过 JNDI 查找和缓存服务来获取服务的单点接触。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓存（Cache）&lt;/strong&gt; - 缓存存储服务的引用，以便复用它们。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;客户端（Client）&lt;/strong&gt; - Client 是通过 ServiceLocator 调用服务的对象。
    
    </summary>
    
      <category term="设计模式" scheme="https://dongz.me/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="服务器定位模式" scheme="https://dongz.me/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9A%E4%BD%8D%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之拦截过滤器模式</title>
    <link href="https://dongz.me/2018/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%8B%A6%E6%88%AA%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongz.me/2018/10/21/设计模式之拦截过滤器模式/</id>
    <published>2018-10-21T04:41:00.000Z</published>
    <updated>2018-10-21T04:45:50.414Z</updated>
    
    <content type="html"><![CDATA[<p>拦截过滤器模式（Intercepting Filter Pattern）用于对应用程序的请求或响应做一些预处理/后处理。定义过滤器，并在把请求传给实际目标应用程序之前应用在请求上。过滤器可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。</p><ul><li><strong>过滤器（Filter）</strong> - 过滤器在请求处理程序执行请求之前或之后，执行某些任务。</li><li><strong>过滤器链（Filter Chain）</strong> - 过滤器链带有多个过滤器，并在 Target 上按照定义的顺序执行这些过滤器。</li><li><strong>Target</strong> - Target 对象是请求处理程序。</li><li><strong>过滤管理器（Filter Manager）</strong> - 过滤管理器管理过滤器和过滤器链。</li><li><strong>客户端（Client）</strong> - Client 是向 Target 对象发送请求的对象。<a id="more"></a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;拦截过滤器模式（Intercepting Filter Pattern）用于对应用程序的请求或响应做一些预处理/后处理。定义过滤器，并在把请求传给实际目标应用程序之前应用在请求上。过滤器可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;过滤器（Filter）&lt;/strong&gt; - 过滤器在请求处理程序执行请求之前或之后，执行某些任务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;过滤器链（Filter Chain）&lt;/strong&gt; - 过滤器链带有多个过滤器，并在 Target 上按照定义的顺序执行这些过滤器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Target&lt;/strong&gt; - Target 对象是请求处理程序。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;过滤管理器（Filter Manager）&lt;/strong&gt; - 过滤管理器管理过滤器和过滤器链。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;客户端（Client）&lt;/strong&gt; - Client 是向 Target 对象发送请求的对象。
    
    </summary>
    
      <category term="设计模式" scheme="https://dongz.me/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="拦截过滤器模式" scheme="https://dongz.me/tags/%E6%8B%A6%E6%88%AA%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之前端控制器模式</title>
    <link href="https://dongz.me/2018/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%89%8D%E7%AB%AF%E6%8E%A7%E5%88%B6%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongz.me/2018/10/21/设计模式之前端控制器模式/</id>
    <published>2018-10-21T04:40:00.000Z</published>
    <updated>2018-10-21T04:46:19.094Z</updated>
    
    <content type="html"><![CDATA[<p>前端控制器模式（Front Controller Pattern）是用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。</p><ul><li><strong>前端控制器（Front Controller）</strong> - 处理应用程序所有类型请求的单个处理程序，应用程序可以是基于 web 的应用程序，也可以是基于桌面的应用程序。</li><li><strong>调度器（Dispatcher）</strong> - 前端控制器可能使用一个调度器对象来调度请求到相应的具体处理程序。</li><li><strong>视图（View）</strong> - 视图是为请求而创建的对象。<a id="more"></a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端控制器模式（Front Controller Pattern）是用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;前端控制器（Front Controller）&lt;/strong&gt; - 处理应用程序所有类型请求的单个处理程序，应用程序可以是基于 web 的应用程序，也可以是基于桌面的应用程序。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;调度器（Dispatcher）&lt;/strong&gt; - 前端控制器可能使用一个调度器对象来调度请求到相应的具体处理程序。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;视图（View）&lt;/strong&gt; - 视图是为请求而创建的对象。
    
    </summary>
    
      <category term="设计模式" scheme="https://dongz.me/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="前端控制器模式" scheme="https://dongz.me/tags/%E5%89%8D%E7%AB%AF%E6%8E%A7%E5%88%B6%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之数据访问对象模式</title>
    <link href="https://dongz.me/2018/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongz.me/2018/10/21/设计模式之数据访问对象模式/</id>
    <published>2018-10-21T04:38:00.000Z</published>
    <updated>2018-10-21T04:39:48.091Z</updated>
    
    <content type="html"><![CDATA[<p>数据访问对象模式（Data Access Object Pattern）或 DAO 模式用于把低级的数据访问 API 或操作从高级的业务服务中分离出来。以下是数据访问对象模式的参与者。</p><ul><li><strong>数据访问对象接口（Data Access Object Interface）</strong> - 该接口定义了在一个模型对象上要执行的标准操作。</li><li><strong>数据访问对象实体类（Data Access Object concrete class）</strong> - 该类实现了上述的接口。该类负责从数据源获取数据，数据源可以是数据库，也可以是 xml，或者是其他的存储机制。</li><li><strong>模型对象/数值对象（Model Object/Value Object）</strong> - 该对象是简单的 POJO，包含了 get/set 方法来存储通过使用 DAO 类检索到的数据。<a id="more"></a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据访问对象模式（Data Access Object Pattern）或 DAO 模式用于把低级的数据访问 API 或操作从高级的业务服务中分离出来。以下是数据访问对象模式的参与者。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数据访问对象接口（Data Access Object Interface）&lt;/strong&gt; - 该接口定义了在一个模型对象上要执行的标准操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据访问对象实体类（Data Access Object concrete class）&lt;/strong&gt; - 该类实现了上述的接口。该类负责从数据源获取数据，数据源可以是数据库，也可以是 xml，或者是其他的存储机制。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;模型对象/数值对象（Model Object/Value Object）&lt;/strong&gt; - 该对象是简单的 POJO，包含了 get/set 方法来存储通过使用 DAO 类检索到的数据。
    
    </summary>
    
      <category term="设计模式" scheme="https://dongz.me/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="数据访问对象模式" scheme="https://dongz.me/tags/%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之组合实体模式</title>
    <link href="https://dongz.me/2018/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%84%E5%90%88%E5%AE%9E%E4%BD%93%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongz.me/2018/10/21/设计模式之组合实体模式/</id>
    <published>2018-10-21T04:34:04.000Z</published>
    <updated>2018-10-21T04:35:59.932Z</updated>
    
    <content type="html"><![CDATA[<p>组合实体模式（Composite Entity Pattern）用在 EJB 持久化机制中。一个组合实体是一个 EJB 实体 bean，代表了对象的图解。当更新一个组合实体时，内部依赖对象 beans 会自动更新，因为它们是由 EJB 实体 bean 管理的。以下是组合实体 bean 的参与者。</p><ul><li><strong>组合实体（Composite Entity）</strong> - 它是主要的实体 bean。它可以是粗粒的，或者可以包含一个粗粒度对象，用于持续生命周期。</li><li><strong>粗粒度对象（Coarse-Grained Object）</strong> - 该对象包含依赖对象。它有自己的生命周期，也能管理依赖对象的生命周期。</li><li><strong>依赖对象（Dependent Object）</strong> - 依赖对象是一个持续生命周期依赖于粗粒度对象的对象。</li><li><strong>策略（Strategies）</strong> - 策略表示如何实现组合实体。<a id="more"></a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;组合实体模式（Composite Entity Pattern）用在 EJB 持久化机制中。一个组合实体是一个 EJB 实体 bean，代表了对象的图解。当更新一个组合实体时，内部依赖对象 beans 会自动更新，因为它们是由 EJB 实体 bean 管理的。以下是组合实体 bean 的参与者。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;组合实体（Composite Entity）&lt;/strong&gt; - 它是主要的实体 bean。它可以是粗粒的，或者可以包含一个粗粒度对象，用于持续生命周期。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;粗粒度对象（Coarse-Grained Object）&lt;/strong&gt; - 该对象包含依赖对象。它有自己的生命周期，也能管理依赖对象的生命周期。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;依赖对象（Dependent Object）&lt;/strong&gt; - 依赖对象是一个持续生命周期依赖于粗粒度对象的对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;策略（Strategies）&lt;/strong&gt; - 策略表示如何实现组合实体。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式之业务代表模式</title>
    <link href="https://dongz.me/2018/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%B8%9A%E5%8A%A1%E4%BB%A3%E8%A1%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongz.me/2018/10/21/设计模式之业务代表模式/</id>
    <published>2018-10-21T04:32:36.000Z</published>
    <updated>2018-10-21T04:33:41.205Z</updated>
    
    <content type="html"><![CDATA[<p>业务代表模式（Business Delegate Pattern）用于对表示层和业务层解耦。它基本上是用来减少通信或对表示层代码中的业务层代码的远程查询功能。在业务层中我们有以下实体。</p><ul><li><strong>客户端（Client）</strong> - 表示层代码可以是 JSP、servlet 或 UI java 代码。</li><li><strong>业务代表（Business Delegate）</strong> - 一个为客户端实体提供的入口类，它提供了对业务服务方法的访问。</li><li><strong>查询服务（LookUp Service）</strong> - 查找服务对象负责获取相关的业务实现，并提供业务对象对业务代表对象的访问。</li><li><strong>业务服务（Business Service）</strong> - 业务服务接口。实现了该业务服务的实体类，提供了实际的业务实现逻辑。<a id="more"></a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;业务代表模式（Business Delegate Pattern）用于对表示层和业务层解耦。它基本上是用来减少通信或对表示层代码中的业务层代码的远程查询功能。在业务层中我们有以下实体。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;客户端（Client）&lt;/strong&gt; - 表示层代码可以是 JSP、servlet 或 UI java 代码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;业务代表（Business Delegate）&lt;/strong&gt; - 一个为客户端实体提供的入口类，它提供了对业务服务方法的访问。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;查询服务（LookUp Service）&lt;/strong&gt; - 查找服务对象负责获取相关的业务实现，并提供业务对象对业务代表对象的访问。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;业务服务（Business Service）&lt;/strong&gt; - 业务服务接口。实现了该业务服务的实体类，提供了实际的业务实现逻辑。
    
    </summary>
    
    
  </entry>
  
</feed>
