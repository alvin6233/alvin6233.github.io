<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>alvin&#39;s blog</title>
  
  <subtitle>Good memory is worse than bad writing</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dongme.site/"/>
  <updated>2018-10-15T16:12:19.522Z</updated>
  <id>https://dongme.site/</id>
  
  <author>
    <name>alvin dong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>jdk新特性之jdk8</title>
    <link href="https://dongme.site/2018/10/15/jdk%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8Bjdk8/"/>
    <id>https://dongme.site/2018/10/15/jdk新特性之jdk8/</id>
    <published>2018-10-15T15:43:54.000Z</published>
    <updated>2018-10-15T16:12:19.522Z</updated>
    
    <content type="html"><![CDATA[<p>毫无疑问，Java 8是Java自Java 5（发布于2004年）之后的最重要的版本。这个版本包含语言、编译器、库、工具和JVM等方面的十多个新特性。<br><a id="more"></a></p><h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><p>Lambda表达式，也称为闭包。Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中）。<br>使用Lambda表达式可以使代码变的更加简洁紧凑。<br>Lambda 表达式免去了使用匿名方法的麻烦，并且给予Java简单但是强大的函数化的编程能力。  </p><p>语法：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br><span class="line">或</span><br><span class="line">(parameter) -&gt; &#123;expression;&#125;</span><br></pre></td></tr></table></figure><p>Lambda表达式的特征如下：  </p><blockquote><p>可选类型声明：不需要声明参数类型，编译器可以统一识别。<br>可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。<br>可选的大括号：如果主体包含了一个语句，就不需要使用大括号。<br>可选的返回关键字：如果主体只有一个表达式  </p></blockquote><p>简单例子：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 1. 不需要参数,返回值为 5  </span><br><span class="line">() -&gt; 5  </span><br><span class="line">  </span><br><span class="line">// 2. 接收一个参数(数字类型),返回其2倍的值  </span><br><span class="line">x -&gt; 2 * x  </span><br><span class="line">  </span><br><span class="line">// 3. 接受2个参数(数字),并返回他们的差值  </span><br><span class="line">(x, y) -&gt; x – y  </span><br><span class="line">  </span><br><span class="line">// 4. 接收2个int型整数,返回他们的和  </span><br><span class="line">(int x, int y) -&gt; x + y  </span><br><span class="line">  </span><br><span class="line">// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  </span><br><span class="line">(String s) -&gt; System.out.print(s)</span><br></pre></td></tr></table></figure><p>测试：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class Java8Lambda &#123;</span><br><span class="line">    interface MathOperation &#123;</span><br><span class="line">        int operation(int a, int b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface GreetingService &#123;</span><br><span class="line">        void sayMessage(String message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int operate(int a, int b, MathOperation mathOperation) &#123;</span><br><span class="line">        return mathOperation.operation(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Java8Lambda java8Lambda = new Java8Lambda();</span><br><span class="line">        // 参数类型声明</span><br><span class="line">        MathOperation addition = (int a, int b) -&gt; a + b;</span><br><span class="line">        // 不用类型声明</span><br><span class="line">        MathOperation subtraction = (a, b) -&gt; a - b;</span><br><span class="line">        // 大括号中返回语句</span><br><span class="line">        MathOperation multiplication = (int a, int b) -&gt; &#123;</span><br><span class="line">            return a * b;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 没有大括号及返回语句</span><br><span class="line">        MathOperation division = (int a, int b) -&gt; a / b;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;6 + 2 = &quot; + java8Lambda.operate(6, 2, addition));</span><br><span class="line">        System.out.println(&quot;6 - 2 = &quot; + java8Lambda.operate(6, 2, subtraction));</span><br><span class="line">        System.out.println(&quot;6 * 2 = &quot; + java8Lambda.operate(6, 2, multiplication));</span><br><span class="line">        System.out.println(&quot;6 / 2 = &quot; + java8Lambda.operate(6, 2, division));</span><br><span class="line">        // 不用括号</span><br><span class="line">        GreetingService gs1 = message -&gt; System.out.println(&quot;hello, &quot; + message);</span><br><span class="line">        // 用括号</span><br><span class="line">        GreetingService gs2 = (message) -&gt; System.out.println(&quot;Hello,&quot; + message);</span><br><span class="line"></span><br><span class="line">        gs1.sayMessage(&quot;Runoob&quot;);</span><br><span class="line">        gs2.sayMessage(&quot;Google&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">#### 接口默认方法</span><br><span class="line">简单说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。我们只需在方法名前面加个default关键字即可实现默认方法。</span><br><span class="line"></span><br><span class="line">**为什么要有这个特性？**</span><br><span class="line">&gt; 首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类，目前的java 8之前的集合框架没有foreach方法，通常能想到的解决办法是在JDK里给相关的接口添加新的方法及实现。然而，对于已经发布的版本，是没法在给接口添加新方法的同时不影响已有的实现。所以引进的默认方法。他们的目的是为了解决接口的修改与现有的实现不兼容的问题。</span><br><span class="line"></span><br><span class="line">**语法**</span><br></pre></td></tr></table></figure><p>public interface Vehicle {<br>   default void print(){<br>      System.out.println(“she is lily”);<br>   }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**多个默认方法：**</span><br><span class="line">一个接口有默认方法，考虑这样的情况，一个类实现了多个接口，且这些接口有相同的默认方法，以下实例说明了这种情况的解决方法：</span><br></pre></td></tr></table></figure></p><p>public interface Vehicle {<br>   default void print(){<br>      System.out.println(“我是一辆车!”);<br>   }<br>}</p><p>public interface FourWheeler {<br>   default void print(){<br>      System.out.println(“我是一辆四轮车!”);<br>   }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一个解决方案是创建自己的默认方法，来覆盖重写接口的默认方法：</span><br></pre></td></tr></table></figure></p><p>public class Car implements Vehicle, FourWheeler {<br>   default void print(){<br>      System.out.println(“我是一辆四轮汽车!”);<br>   }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第二种解决方案可以使用 super 来调用指定接口的默认方法：</span><br></pre></td></tr></table></figure></p><p>public class Car implements Vehicle, FourWheeler {<br>   public void print(){<br>      Vehicle.super.print();<br>   }</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java 8 的另一个特性是接口可以声明（并且可以提供实现）静态方法。例如：</span><br></pre></td></tr></table></figure><p>public class Java8Tester {<br>   public static void main(String args[]){<br>      Vehicle vehicle = new Car();<br>      vehicle.print();<br>   }<br>}</p><p>interface Vehicle {<br>   default void print(){<br>      System.out.println(“我是一辆车!”);<br>   }</p><p>   static void blowHorn(){<br>      System.out.println(“按喇叭!!!”);<br>   }<br>}</p><p>interface FourWheeler {<br>   default void print(){<br>      System.out.println(“我是一辆四轮车!”);<br>   }<br>}</p><p>class Car implements Vehicle, FourWheeler {<br>   public void print(){<br>      Vehicle.super.print();<br>      FourWheeler.super.print();<br>      Vehicle.blowHorn();<br>      System.out.println(“我是一辆汽车!”);<br>   }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#### 函数式接口</span><br><span class="line">函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。   </span><br><span class="line">函数式接口可以被隐式转换为lambda表达式。  </span><br><span class="line">函数式接口可以现有的函数友好地支持 lambda。  </span><br><span class="line"></span><br><span class="line">+ JDK 1.8之前已有的函数式接口</span><br></pre></td></tr></table></figure></p><p>java.lang.Runnable<br>java.util.concurrent.Callable<br>java.security.PrivilegedAction<br>java.util.Comparator<br>java.io.FileFilter<br>java.nio.file.PathMatcher<br>java.lang.reflect.InvocationHandler<br>java.beans.PropertyChangeListener<br>java.awt.event.ActionListener<br>javax.swing.event.ChangeListener  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">+ JDK 1.8 新增加的函数接口 </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">java.util.function</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">+ java.util.function 它包含了很多类，用来支持 Java的 函数式编程，该包中的函数式接口有     </span><br><span class="line"></span><br><span class="line">| 序号 | 接口 &amp; 描述 |</span><br><span class="line">|:----|:------|</span><br><span class="line">|1|BiConsumer&lt;T,U&gt; 代表了一个接受两个输入参数的操作，并且不返回任何结果|</span><br><span class="line">|2|BiFunction&lt;T,U,R&gt; 代表了一个接受两个输入参数的方法，并且返回一个结果|</span><br><span class="line">|3|BinaryOperator&lt;T&gt; 代表了一个作用于于两个同类型操作符的操作，并且返回了操作符同类型的结果|</span><br><span class="line">|4|BiPredicate&lt;T,U&gt; 代表了一个两个参数的boolean值方法|</span><br><span class="line">|5|BooleanSupplier代表了boolean值结果的提供方|</span><br><span class="line">|6|Consumer&lt;T&gt;代表了接受一个输入参数并且无返回的操作|</span><br><span class="line">|7|DoubleBinaryOperator 代表了作用于两个double值操作符的操作，并且返回了一个double值的结果。|</span><br><span class="line">|8|DoubleConsumer 代表一个接受double值参数的操作，并且不返回结果。|</span><br><span class="line">|9|DoubleFunction&lt;R&gt; 代表接受一个double值参数的方法，并且返回结果|</span><br><span class="line">|10|DoublePredicate 代表一个拥有double值参数的boolean值方法|</span><br><span class="line">|11|DoubleSupplier 代表一个double值结构的提供方|</span><br><span class="line">|12|DoubleToIntFunction 接受一个double类型输入，返回一个int类型结果|   </span><br><span class="line">|13|DoubleToLongFunction 接受一个double类型输入，返回一个long类型结果|   </span><br><span class="line">|14|DoubleUnaryOperator 接受一个参数同为类型double,返回值类型也为double |   </span><br><span class="line">|15|Function&lt;T,R&gt; 接受一个输入参数，返回一个结果 |   </span><br><span class="line">|16|IntBinaryOperator 接受两个参数同为类型int,返回值类型也为int |   </span><br><span class="line">|17|IntConsumer 接受一个int类型的输入参数，无返回值 |   </span><br><span class="line">|18|IntFunction&lt;R&gt; 接受一个int类型输入参数，返回一个结果 |   </span><br><span class="line">|19|IntPredicate 接受一个int输入参数，返回一个布尔值的结果|   </span><br><span class="line">|...|...|</span><br><span class="line"></span><br><span class="line">+ 函数式接口实例   </span><br><span class="line">redicate &lt;T&gt; 接口是一个函数式接口，它接受一个输入参数 T，返回一个布尔值结果。   </span><br><span class="line">该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）。    </span><br><span class="line">该接口用于测试对象是 true 或 false。      </span><br><span class="line">我们可以通过以下实例（Java8Tester.java）来了解函数式接口 Predicate &lt;T&gt; 的使用：    </span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.function.Predicate;</span><br><span class="line"> </span><br><span class="line">public class Java8Tester &#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);</span><br><span class="line">        </span><br><span class="line">      // Predicate&lt;Integer&gt; predicate = n -&gt; true</span><br><span class="line">      // n 是一个参数传递到 Predicate 接口的 test 方法</span><br><span class="line">      // n 如果存在则 test 方法返回 true</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;输出所有数据:&quot;);</span><br><span class="line">        </span><br><span class="line">      // 传递参数 n</span><br><span class="line">      eval(list, n-&gt;true);</span><br><span class="line">        </span><br><span class="line">      // Predicate&lt;Integer&gt; predicate1 = n -&gt; n%2 == 0</span><br><span class="line">      // n 是一个参数传递到 Predicate 接口的 test 方法</span><br><span class="line">      // 如果 n%2 为 0 test 方法返回 true</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;输出所有偶数:&quot;);</span><br><span class="line">      eval(list, n-&gt; n%2 == 0 );</span><br><span class="line">        </span><br><span class="line">      // Predicate&lt;Integer&gt; predicate2 = n -&gt; n &gt; 3</span><br><span class="line">      // n 是一个参数传递到 Predicate 接口的 test 方法</span><br><span class="line">      // 如果 n 大于 3 test 方法返回 true</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;输出大于 3 的所有数字:&quot;);</span><br><span class="line">      eval(list, n-&gt; n &gt; 3 );</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   public static void eval(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate) &#123;</span><br><span class="line">      for(Integer n: list) &#123;</span><br><span class="line">        </span><br><span class="line">         if(predicate.test(n)) &#123;</span><br><span class="line">            System.out.println(n + &quot; &quot;);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">+ eval 函数可以写为如下格式  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">private static void eval(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate) &#123;</span><br><span class="line">    list.stream().filter(predicate).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">或者直接可以不用定义 eval 函数，使用:</span><br></pre></td></tr></table></figure><p>list.stream().filter(n -&gt; n &gt; 3).forEach(System.out::println);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">来输出所有大于 3 的数字。   </span><br><span class="line"></span><br><span class="line">#### 方法引用  </span><br><span class="line">方法引用通过方法的名字来指向一个方法。  </span><br><span class="line">方法引用可以使语言的构造更紧凑简洁，减少冗余代码。  </span><br><span class="line">方法引用使用一对冒号`::`。  </span><br><span class="line"> </span><br><span class="line"> 下面，我们在 Car 类中定义了 4 个方法作为例子来区分 Java 中 4 种不同方法的引用。  </span><br><span class="line"> </span><br><span class="line"> ``` </span><br><span class="line"> @FunctionalInterface</span><br><span class="line"> public interface Supplier&lt;T&gt; &#123;</span><br><span class="line">     T get();</span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line"> class Car &#123;</span><br><span class="line">     //Supplier是jdk1.8的接口，这里和lamda一起使用了</span><br><span class="line">     public static Car create(final Supplier&lt;Car&gt; supplier) &#123;</span><br><span class="line">         return supplier.get();</span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">     public static void collide(final Car car) &#123;</span><br><span class="line">         System.out.println(&quot;Collided &quot; + car.toString());</span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">     public void follow(final Car another) &#123;</span><br><span class="line">         System.out.println(&quot;Following the &quot; + another.toString());</span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">     public void repair() &#123;</span><br><span class="line">         System.out.println(&quot;Repaired &quot; + this.toString());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> ```    </span><br><span class="line"> </span><br><span class="line"> **构造器引用：**它的语法是Class::new，或者更一般的Class&lt; T &gt;::new实例如下：</span><br><span class="line"> </span><br><span class="line">```  </span><br><span class="line">final Car car = Car.create( Car::new );</span><br><span class="line">final List&lt; Car &gt; cars = Arrays.asList( car );</span><br><span class="line">```   </span><br><span class="line">**静态方法引用：**它的语法是Class::static_method，实例如下：    </span><br><span class="line">``` </span><br><span class="line">cars.forEach( Car::collide );</span><br><span class="line">```  </span><br><span class="line">**特定类的任意对象的方法引用：**它的语法是Class::method实例如下：   </span><br><span class="line">``` </span><br><span class="line">cars.forEach( Car::repair );</span><br><span class="line">```   </span><br><span class="line">**特定对象的方法引用：**它的语法是instance::method实例如下：    </span><br><span class="line">``` </span><br><span class="line">final Car police = Car.create( Car::new );</span><br><span class="line">cars.forEach( police::follow );</span><br><span class="line">```   </span><br><span class="line">+ 方法引用实例     </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"> public static void main(String args[])&#123;</span><br><span class="line">      List names = new ArrayList();</span><br><span class="line">        </span><br><span class="line">      names.add(&quot;Google&quot;);</span><br><span class="line">      names.add(&quot;Runoob&quot;);</span><br><span class="line">      names.add(&quot;Taobao&quot;);</span><br><span class="line">      names.add(&quot;Baidu&quot;);</span><br><span class="line">      names.add(&quot;Sina&quot;);</span><br><span class="line">        </span><br><span class="line">      names.forEach(System.out::println);</span><br><span class="line">   &#125;</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">#### Stream   </span><br><span class="line">Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明式的方式处理数据。   </span><br><span class="line">Stream使用一种类似用SQL语句从数据库查询数据的直观方式来提供一种对Java集合运算和表达的高阶抽象。   </span><br><span class="line">Stream API可以极大的提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。   </span><br><span class="line">这种风格将要处理的元素集合看作一种流，流在管道中传输，并且可以在管道的节点上进行处理，比如筛选、排序、聚合等。   </span><br><span class="line">元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作（terminal operation）得到前面处理的结果。   </span><br><span class="line">``` </span><br><span class="line">+--------------------+       +------+   +------+   +---+   +-------+</span><br><span class="line">| stream of elements +-----&gt; |filter+-&gt; |sorted+-&gt; |map+-&gt; |collect|</span><br><span class="line">+--------------------+       +------+   +------+   +---+   +-------+</span><br></pre></td></tr></table></figure></p><p>以上的流程转换为 Java 代码为： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; transactionsIds = </span><br><span class="line">widgets.stream()</span><br><span class="line">             .filter(b -&gt; b.getColor() == RED)</span><br><span class="line">             .sorted((x,y) -&gt; x.getWeight() - y.getWeight())</span><br><span class="line">             .mapToInt(Widget::getWeight)</span><br><span class="line">             .sum();</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">+ 什么是 Stream？   </span><br><span class="line">Stream（流）是一个来自数据源的元素队列并支持聚合操作</span><br><span class="line"></span><br><span class="line">&gt; 元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。   </span><br><span class="line">&gt; **数据源** 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。   </span><br><span class="line">&gt; **聚合操作** 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。   </span><br><span class="line"></span><br><span class="line">和以前的Collection操作不同， Stream操作还有两个基础的特征：   </span><br><span class="line">&gt; **Pipelining:** 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。   </span><br><span class="line">&gt; **内部迭代：** 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。   </span><br><span class="line"></span><br><span class="line">+ 生成流   </span><br><span class="line">在 Java 8 中, 集合接口有两个方法来生成流：   </span><br><span class="line">1）stream() − 为集合创建串行流。   </span><br><span class="line">2）parallelStream() − 为集合创建并行流。   </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line">```  </span><br><span class="line">+ forEach   </span><br><span class="line">Stream 提供了新的方法 &apos;forEach&apos; 来迭代流中的每个数据。以下代码片段使用 forEach 输出了10个随机数：  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">Random random = new Random();</span><br><span class="line">random.ints().limit(10).forEach(System.out::println);</span><br><span class="line">```  </span><br><span class="line">+ map   </span><br><span class="line">map 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：   </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);</span><br><span class="line">// 获取对应的平方数</span><br><span class="line">List&lt;Integer&gt; squaresList = numbers.stream().map( i -&gt; i*i).distinct().collect(Collectors.toList());</span><br><span class="line">```  </span><br><span class="line">+ filter   </span><br><span class="line">filter 方法用于通过设置的条件过滤出元素。以下代码片段使用 filter 方法过滤出空字符串：  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">List&lt;String&gt;strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">// 获取空字符串的数量</span><br><span class="line">int count = strings.stream().filter(string -&gt; string.isEmpty()).count();</span><br><span class="line">```   </span><br><span class="line">+ limit  </span><br><span class="line">limit 方法用于获取指定数量的流。 以下代码片段使用 limit 方法打印出 10 条数据：  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">Random random = new Random();</span><br><span class="line">random.ints().limit(10).forEach(System.out::println);</span><br><span class="line">```   </span><br><span class="line">+ sorted   </span><br><span class="line">sorted 方法用于对流进行排序。以下代码片段使用 sorted 方法对输出的 10 个随机数进行排序：   </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">Random random = new Random();</span><br><span class="line">random.ints().limit(10).sorted().forEach(System.out::println);</span><br><span class="line">```  </span><br><span class="line">+ 并行（parallel）程序   </span><br><span class="line">parallelStream 是流并行处理程序的代替方法。以下实例我们使用 parallelStream 来输出空字符串的数量： </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">// 获取空字符串的数量</span><br><span class="line">int count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span><br><span class="line">```   </span><br><span class="line">+ Collectors   </span><br><span class="line">Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors 可用于返回列表或字符串：</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">List&lt;String&gt;strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line">System.out.println(&quot;筛选列表: &quot; + filtered);</span><br><span class="line">String mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(&quot;, &quot;));</span><br><span class="line">System.out.println(&quot;合并字符串: &quot; + mergedString);</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">+ 统计   </span><br><span class="line">另外，一些产生统计结果的收集器也非常有用。它们主要用于int、double、long等基本类型上，它们可以用来产生类似如下的统计结果。</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);</span><br><span class="line">IntSummaryStatistics stats = integers.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line">System.out.println(&quot;列表中最大的数 : &quot; + stats.getMax());</span><br><span class="line">System.out.println(&quot;列表中最小的数 : &quot; + stats.getMin());</span><br><span class="line">System.out.println(&quot;所有数之和 : &quot; + stats.getSum());</span><br><span class="line">System.out.println(&quot;平均数 : &quot; + stats.getAverage());</span><br><span class="line">```    </span><br><span class="line">+ Stream 完整实例    </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.IntSummaryStatistics;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Random;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line">import java.util.Map;</span><br><span class="line"> </span><br><span class="line">public class Java8Tester &#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      System.out.println(&quot;使用 Java 7: &quot;);</span><br><span class="line">        </span><br><span class="line">      // 计算空字符串</span><br><span class="line">      List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">      System.out.println(&quot;列表: &quot; +strings);</span><br><span class="line">      long count = getCountEmptyStringUsingJava7(strings);</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;空字符数量为: &quot; + count);</span><br><span class="line">      count = getCountLength3UsingJava7(strings);</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;字符串长度为 3 的数量为: &quot; + count);</span><br><span class="line">        </span><br><span class="line">      // 删除空字符串</span><br><span class="line">      List&lt;String&gt; filtered = deleteEmptyStringsUsingJava7(strings);</span><br><span class="line">      System.out.println(&quot;筛选后的列表: &quot; + filtered);</span><br><span class="line">        </span><br><span class="line">      // 删除空字符串，并使用逗号把它们合并起来</span><br><span class="line">      String mergedString = getMergedStringUsingJava7(strings,&quot;, &quot;);</span><br><span class="line">      System.out.println(&quot;合并字符串: &quot; + mergedString);</span><br><span class="line">      List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);</span><br><span class="line">        </span><br><span class="line">      // 获取列表元素平方数</span><br><span class="line">      List&lt;Integer&gt; squaresList = getSquares(numbers);</span><br><span class="line">      System.out.println(&quot;平方数列表: &quot; + squaresList);</span><br><span class="line">      List&lt;Integer&gt; integers = Arrays.asList(1,2,13,4,15,6,17,8,19);</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;列表: &quot; +integers);</span><br><span class="line">      System.out.println(&quot;列表中最大的数 : &quot; + getMax(integers));</span><br><span class="line">      System.out.println(&quot;列表中最小的数 : &quot; + getMin(integers));</span><br><span class="line">      System.out.println(&quot;所有数之和 : &quot; + getSum(integers));</span><br><span class="line">      System.out.println(&quot;平均数 : &quot; + getAverage(integers));</span><br><span class="line">      System.out.println(&quot;随机数: &quot;);</span><br><span class="line">        </span><br><span class="line">      // 输出10个随机数</span><br><span class="line">      Random random = new Random();</span><br><span class="line">        </span><br><span class="line">      for(int i=0; i &lt; 10; i++)&#123;</span><br><span class="line">         System.out.println(random.nextInt());</span><br><span class="line">      &#125;</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;使用 Java 8: &quot;);</span><br><span class="line">      System.out.println(&quot;列表: &quot; +strings);</span><br><span class="line">        </span><br><span class="line">      count = strings.stream().filter(string-&gt;string.isEmpty()).count();</span><br><span class="line">      System.out.println(&quot;空字符串数量为: &quot; + count);</span><br><span class="line">        </span><br><span class="line">      count = strings.stream().filter(string -&gt; string.length() == 3).count();</span><br><span class="line">      System.out.println(&quot;字符串长度为 3 的数量为: &quot; + count);</span><br><span class="line">        </span><br><span class="line">      filtered = strings.stream().filter(string -&gt;!string.isEmpty()).collect(Collectors.toList());</span><br><span class="line">      System.out.println(&quot;筛选后的列表: &quot; + filtered);</span><br><span class="line">        </span><br><span class="line">      mergedString = strings.stream().filter(string -&gt;!string.isEmpty()).collect(Collectors.joining(&quot;, &quot;));</span><br><span class="line">      System.out.println(&quot;合并字符串: &quot; + mergedString);</span><br><span class="line">        </span><br><span class="line">      squaresList = numbers.stream().map( i -&gt;i*i).distinct().collect(Collectors.toList());</span><br><span class="line">      System.out.println(&quot;Squares List: &quot; + squaresList);</span><br><span class="line">      System.out.println(&quot;列表: &quot; +integers);</span><br><span class="line">        </span><br><span class="line">      IntSummaryStatistics stats = integers.stream().mapToInt((x) -&gt;x).summaryStatistics();</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;列表中最大的数 : &quot; + stats.getMax());</span><br><span class="line">      System.out.println(&quot;列表中最小的数 : &quot; + stats.getMin());</span><br><span class="line">      System.out.println(&quot;所有数之和 : &quot; + stats.getSum());</span><br><span class="line">      System.out.println(&quot;平均数 : &quot; + stats.getAverage());</span><br><span class="line">      System.out.println(&quot;随机数: &quot;);</span><br><span class="line">        </span><br><span class="line">      random.ints().limit(10).sorted().forEach(System.out::println);</span><br><span class="line">        </span><br><span class="line">      // 并行处理</span><br><span class="line">      count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span><br><span class="line">      System.out.println(&quot;空字符串的数量为: &quot; + count);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private static int getCountEmptyStringUsingJava7(List&lt;String&gt; strings)&#123;</span><br><span class="line">      int count = 0;</span><br><span class="line">        </span><br><span class="line">      for(String string: strings)&#123;</span><br><span class="line">        </span><br><span class="line">         if(string.isEmpty())&#123;</span><br><span class="line">            count++;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return count;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private static int getCountLength3UsingJava7(List&lt;String&gt; strings)&#123;</span><br><span class="line">      int count = 0;</span><br><span class="line">        </span><br><span class="line">      for(String string: strings)&#123;</span><br><span class="line">        </span><br><span class="line">         if(string.length() == 3)&#123;</span><br><span class="line">            count++;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return count;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private static List&lt;String&gt; deleteEmptyStringsUsingJava7(List&lt;String&gt; strings)&#123;</span><br><span class="line">      List&lt;String&gt; filteredList = new ArrayList&lt;String&gt;();</span><br><span class="line">        </span><br><span class="line">      for(String string: strings)&#123;</span><br><span class="line">        </span><br><span class="line">         if(!string.isEmpty())&#123;</span><br><span class="line">             filteredList.add(string);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return filteredList;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private static String getMergedStringUsingJava7(List&lt;String&gt; strings, String separator)&#123;</span><br><span class="line">      StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">        </span><br><span class="line">      for(String string: strings)&#123;</span><br><span class="line">        </span><br><span class="line">         if(!string.isEmpty())&#123;</span><br><span class="line">            stringBuilder.append(string);</span><br><span class="line">            stringBuilder.append(separator);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      String mergedString = stringBuilder.toString();</span><br><span class="line">      return mergedString.substring(0, mergedString.length()-2);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private static List&lt;Integer&gt; getSquares(List&lt;Integer&gt; numbers)&#123;</span><br><span class="line">      List&lt;Integer&gt; squaresList = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">      for(Integer number: numbers)&#123;</span><br><span class="line">         Integer square = new Integer(number.intValue() * number.intValue());</span><br><span class="line">            </span><br><span class="line">         if(!squaresList.contains(square))&#123;</span><br><span class="line">            squaresList.add(square);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return squaresList;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private static int getMax(List&lt;Integer&gt; numbers)&#123;</span><br><span class="line">      int max = numbers.get(0);</span><br><span class="line">        </span><br><span class="line">      for(int i=1;i &lt; numbers.size();i++)&#123;</span><br><span class="line">        </span><br><span class="line">         Integer number = numbers.get(i);</span><br><span class="line">            </span><br><span class="line">         if(number.intValue() &gt; max)&#123;</span><br><span class="line">            max = number.intValue();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return max;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private static int getMin(List&lt;Integer&gt; numbers)&#123;</span><br><span class="line">      int min = numbers.get(0);</span><br><span class="line">        </span><br><span class="line">      for(int i=1;i &lt; numbers.size();i++)&#123;</span><br><span class="line">         Integer number = numbers.get(i);</span><br><span class="line">        </span><br><span class="line">         if(number.intValue() &lt; min)&#123;</span><br><span class="line">            min = number.intValue();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return min;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private static int getSum(List numbers)&#123;</span><br><span class="line">      int sum = (int)(numbers.get(0));</span><br><span class="line">        </span><br><span class="line">      for(int i=1;i &lt; numbers.size();i++)&#123;</span><br><span class="line">         sum += (int)numbers.get(i);</span><br><span class="line">      &#125;</span><br><span class="line">      return sum;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private static int getAverage(List&lt;Integer&gt; numbers)&#123;</span><br><span class="line">      return getSum(numbers) / numbers.size();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">```   </span><br><span class="line">执行以上脚本，输出结果为：   </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">$ javac Java8Tester.java </span><br><span class="line">$ java Java8Tester</span><br><span class="line">使用 Java 7: </span><br><span class="line">列表: [abc, , bc, efg, abcd, , jkl]</span><br><span class="line">空字符数量为: 2</span><br><span class="line">字符串长度为 3 的数量为: 3</span><br><span class="line">筛选后的列表: [abc, bc, efg, abcd, jkl]</span><br><span class="line">合并字符串: abc, bc, efg, abcd, jkl</span><br><span class="line">平方数列表: [9, 4, 49, 25]</span><br><span class="line">列表: [1, 2, 13, 4, 15, 6, 17, 8, 19]</span><br><span class="line">列表中最大的数 : 19</span><br><span class="line">列表中最小的数 : 1</span><br><span class="line">所有数之和 : 85</span><br><span class="line">平均数 : 9</span><br><span class="line">随机数: </span><br><span class="line">-393170844</span><br><span class="line">-963842252</span><br><span class="line">447036679</span><br><span class="line">-1043163142</span><br><span class="line">-881079698</span><br><span class="line">221586850</span><br><span class="line">-1101570113</span><br><span class="line">576190039</span><br><span class="line">-1045184578</span><br><span class="line">1647841045</span><br><span class="line">使用 Java 8: </span><br><span class="line">列表: [abc, , bc, efg, abcd, , jkl]</span><br><span class="line">空字符串数量为: 2</span><br><span class="line">字符串长度为 3 的数量为: 3</span><br><span class="line">筛选后的列表: [abc, bc, efg, abcd, jkl]</span><br><span class="line">合并字符串: abc, bc, efg, abcd, jkl</span><br><span class="line">Squares List: [9, 4, 49, 25]</span><br><span class="line">列表: [1, 2, 13, 4, 15, 6, 17, 8, 19]</span><br><span class="line">列表中最大的数 : 19</span><br><span class="line">列表中最小的数 : 1</span><br><span class="line">所有数之和 : 85</span><br><span class="line">平均数 : 9.444444444444445</span><br><span class="line">随机数: </span><br><span class="line">-1743813696</span><br><span class="line">-1301974944</span><br><span class="line">-1299484995</span><br><span class="line">-779981186</span><br><span class="line">136544902</span><br><span class="line">555792023</span><br><span class="line">1243315896</span><br><span class="line">1264920849</span><br><span class="line">1472077135</span><br><span class="line">1706423674</span><br><span class="line">空字符串的数量为: 2</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">#### Optional 类   </span><br><span class="line">&gt; Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。  </span><br><span class="line">&gt; Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。  </span><br><span class="line">&gt; Optional 类的引入很好的解决空指针异常。  </span><br><span class="line"></span><br><span class="line">+ 类声明   </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">public final class Optional&lt;T&gt;</span><br><span class="line">extends Object</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">+ 类方法  </span><br><span class="line"></span><br><span class="line">| 序号 | 方法 &amp; 描述 |</span><br><span class="line">|:---|:----|</span><br><span class="line">|1|static &lt;T&gt; Optional&lt;T&gt; empty() 返回空的 Optional 实例。|</span><br><span class="line">|2|boolean equals(Object obj) 判断其他对象是否等于 Optional。|</span><br><span class="line">|3|Optional&lt;T&gt; filter(Predicate&lt;? super &lt;T&gt; predicate)  如果值存在，并且这个值匹配给定的 predicate，返回一个Optional用以描述这个值，否则返回一个空的Optional。|</span><br><span class="line">|4|&lt;U&gt; Optional&lt;U&gt; flatMap(Function&lt;? super T,Optional&lt;U&gt;&gt; mapper) 如果值存在，返回基于Optional包含的映射方法的值，否则返回一个空的Optional|</span><br><span class="line">|5| T get() 如果在这个Optional中包含这个值，返回值，否则抛出异常：NoSuchElementException |</span><br><span class="line">|6|int hashCode() 返回存在值的哈希码，如果值不存在 返回 0。|</span><br><span class="line">|7|void ifPresent(Consumer&lt;? super T&gt; consumer) 如果值存在则使用该值调用 consumer , 否则不做任何事情。|</span><br><span class="line">|8| boolean isPresent() 如果值存在则方法会返回true，否则返回 false。|</span><br><span class="line">|9|&lt;U&gt;Optional&lt;U&gt; map(Function&lt;? super T,? extends U&gt; mapper) 如果存在该值，提供的映射方法，如果返回非null，返回一个Optional描述结果。|</span><br><span class="line">|10|static &lt;T&gt; Optional&lt;T&gt; of(T value) 返回一个指定非null值的Optional。|</span><br><span class="line">|11|static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value) 如果为非空，返回 Optional 描述的指定值，否则返回空的 Optional。|</span><br><span class="line">|12|T orElse(T other) 如果存在该值，返回值， 否则返回 other。|</span><br><span class="line">|13|T orElseGet(Supplier&lt;? extends T&gt; other) 如果存在该值，返回值， 否则触发 other，并返回 other 调用的结果。|</span><br><span class="line">|14|&lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) 如果存在该值，返回包含的值，否则抛出由 Supplier 继承的异常。|</span><br><span class="line">|15|String toString()  返回一个Optional的非空字符串，用来调试|</span><br><span class="line"></span><br><span class="line">**注意：** 这些方法是从 java.lang.Object 类继承来的。  </span><br><span class="line"></span><br><span class="line">+ Optional 实例    </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">import java.util.Optional;</span><br><span class="line"> </span><br><span class="line">public class Java8Tester &#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">   </span><br><span class="line">      Java8Tester java8Tester = new Java8Tester();</span><br><span class="line">      Integer value1 = null;</span><br><span class="line">      Integer value2 = new Integer(10);</span><br><span class="line">        </span><br><span class="line">      // Optional.ofNullable - 允许传递为 null 参数</span><br><span class="line">      Optional&lt;Integer&gt; a = Optional.ofNullable(value1);</span><br><span class="line">        </span><br><span class="line">      // Optional.of - 如果传递的参数是 null，抛出异常 NullPointerException</span><br><span class="line">      Optional&lt;Integer&gt; b = Optional.of(value2);</span><br><span class="line">      System.out.println(java8Tester.sum(a,b));</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   public Integer sum(Optional&lt;Integer&gt; a, Optional&lt;Integer&gt; b)&#123;</span><br><span class="line">    </span><br><span class="line">      // Optional.isPresent - 判断值是否存在</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;第一个参数值存在: &quot; + a.isPresent());</span><br><span class="line">      System.out.println(&quot;第二个参数值存在: &quot; + b.isPresent());</span><br><span class="line">        </span><br><span class="line">      // Optional.orElse - 如果值存在，返回它，否则返回默认值</span><br><span class="line">      Integer value1 = a.orElse(new Integer(0));</span><br><span class="line">        </span><br><span class="line">      //Optional.get - 获取值，值需要存在</span><br><span class="line">      Integer value2 = b.get();</span><br><span class="line">      return value1 + value2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">执行以上脚本，输出结果为：  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">第一个参数值存在: false</span><br><span class="line">第二个参数值存在: true</span><br><span class="line">10</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">####  Nashorn JavaScript   </span><br><span class="line">Nashorn 一个 javascript 引擎。  </span><br><span class="line">从JDK 1.8开始，Nashorn取代Rhino(JDK 1.6, JDK1.7)成为Java的嵌入式JavaScript引擎。Nashorn完全支持ECMAScript 5.1规范以及一些扩展。它使用基于JSR 292的新语言特性，其中包含在JDK 7中引入的 invokedynamic，将JavaScript编译成Java字节码。</span><br><span class="line">与先前的Rhino实现相比，这带来了2到10倍的性能提升。  </span><br><span class="line"></span><br><span class="line">##### jjs  </span><br><span class="line">jjs是个基于Nashorn引擎的命令行工具。它接受一些JavaScript源代码为参数，并且执行这些源代码。  </span><br><span class="line">例如，我们创建一个具有如下内容的example.js文件：  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">print(&apos;Ping Pong&apos;)</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">打开控制台，输入以下命令：  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">$ jjs example.js</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">以上程序输出结果为：  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">Ping Pong!</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">##### jjs交互式编程  </span><br><span class="line">打开控制台，输入以下命令：  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">$ jjs</span><br><span class="line">jjs&gt; print(&quot;Ping, Pong!&quot;)</span><br><span class="line">Ping, Pong!</span><br><span class="line">jjs&gt; quit()</span><br><span class="line">&gt;&gt;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">##### 传递参数  </span><br><span class="line">打开控制台，输入以下命令：  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">jjs -- h i j k</span><br><span class="line">jjs&gt; print(&apos;字符：&apos; + arguments.join(&quot;,&quot;))</span><br><span class="line">字符：h,i,j,k</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">##### java中调用JavaScript  </span><br><span class="line">使用ScriptEngineManager，JavaScript代码可以在Java中执行，实例如下：  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">public class Jdk8Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ScriptEngineManager scriptEngineManager = new ScriptEngineManager();</span><br><span class="line">        ScriptEngine nashorn = scriptEngineManager.getEngineByName(&quot;nashorn&quot;);</span><br><span class="line"></span><br><span class="line">        String name = &quot;Nashorn&quot;;</span><br><span class="line">        Integer result = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            nashorn.eval(&quot;print(&apos;&quot; + name + &quot;&apos;)&quot;);</span><br><span class="line">            result = (Integer) nashorn.eval(&quot;6 + 2&quot;);</span><br><span class="line">        &#125; catch (ScriptException e) &#123;</span><br><span class="line">            System.out.println(&quot;js脚本执行异常：&quot; + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```   </span><br><span class="line">执行脚本输出如下：  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">Nashorn</span><br><span class="line">8</span><br><span class="line">```   </span><br><span class="line">##### JavaScript中调用Java   </span><br><span class="line">实例如下：  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">var BigDecimal = Java.type(&apos;java.math.BigDecimal&apos;);</span><br><span class="line"></span><br><span class="line">function calculate(amount, percentage) &#123;</span><br><span class="line">   var result = new BigDecimal(amount).multiply(</span><br><span class="line">   new BigDecimal(percentage)).divide(new BigDecimal(&quot;100&quot;), 2, BigDecimal.ROUND_HALF_EVEN);</span><br><span class="line">   return result.toPlainString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result = calculate(10086000000001,15.8);</span><br><span class="line">print(result);</span><br><span class="line">```  </span><br><span class="line">执行如上输出：  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">$ jjs example.js</span><br><span class="line">1593588000000.16</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">#### 日期时间 API   </span><br><span class="line"> Java 8通过发布新的Date-Time API (JSR 310)来进一步加强对日期与时间的处理。   </span><br><span class="line"> 旧版时间API存在的问题主要有：  </span><br><span class="line"> + **非线程安全&gt; ** java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一。    </span><br><span class="line"> + **设计很差&gt; **Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计。  </span><br><span class="line"> + **时区处理麻烦&gt; **日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有的问题。  </span><br><span class="line"> </span><br><span class="line"> Java8在java.time包下提供了很多新的API。以下为两个重要的比较：  </span><br><span class="line"> + **Local(本地)&gt; **简化了日期时间的处理，没有时区的问题。  </span><br><span class="line"> + **Zoned(时区)&gt; **通过制定的时区处理日期时间。  </span><br><span class="line"> </span><br><span class="line"> 新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。  </span><br><span class="line"> </span><br><span class="line"> ##### 本地化日期时间 API  </span><br><span class="line"> LocalDate/LocalTime 和 LocalDateTime 类可以在处理时区不是必须的情况。代码如下：   </span><br><span class="line"> ```  </span><br><span class="line"> public class Jdk8Demo &#123;</span><br><span class="line">     public static void main(String args[])&#123;</span><br><span class="line">         Jdk8Demo jdk8Demo = new Jdk8Demo();</span><br><span class="line">         jdk8Demo.testLocalDateTime();</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     public void testLocalDateTime()&#123;</span><br><span class="line"> </span><br><span class="line">         // 获取当前的日期时间</span><br><span class="line">         LocalDateTime currentTime = LocalDateTime.now();</span><br><span class="line">         System.out.println(&quot;当前时间: &quot; + currentTime);</span><br><span class="line"> </span><br><span class="line">         LocalDate date1 = currentTime.toLocalDate();</span><br><span class="line">         System.out.println(&quot;当前日期: &quot; + date1);</span><br><span class="line"> </span><br><span class="line">         Month month = currentTime.getMonth();</span><br><span class="line">         int day = currentTime.getDayOfMonth();</span><br><span class="line">         int seconds = currentTime.getSecond();</span><br><span class="line"> </span><br><span class="line">         System.out.println(&quot;月: &quot; + month.getValue() +&quot;, 日: &quot; + day +&quot;, 秒: &quot; + seconds);</span><br><span class="line"> </span><br><span class="line">         //修改当前时间 设置年月日</span><br><span class="line">         LocalDateTime date2 = currentTime.withDayOfMonth(10).withYear(2012).withMonth(10);</span><br><span class="line">         System.out.println(&quot;当前时间设置后: &quot; + date2);</span><br><span class="line"> </span><br><span class="line">         // 修改当前时间 设置年月日</span><br><span class="line">         LocalDate date3 = LocalDate.of(2014, Month.DECEMBER, 12);</span><br><span class="line">         System.out.println(&quot;当前时间设置后1: &quot; + date3);</span><br><span class="line"> </span><br><span class="line">         // 修改当前时间 设置时分</span><br><span class="line">         LocalTime date4 = LocalTime.of(22, 15);</span><br><span class="line">         System.out.println(&quot;当前时间设置后2: &quot; + date4);</span><br><span class="line"> </span><br><span class="line">         // 解析字符串</span><br><span class="line">         LocalTime date5 = LocalTime.parse(&quot;20:15:30&quot;);</span><br><span class="line">         System.out.println(&quot;解析字符时间为日期对象: &quot; + date5);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> ```   </span><br><span class="line">以上执行输出：  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">当前时间: 2018-09-27T16:22:35.565</span><br><span class="line">当前日期: 2018-09-27</span><br><span class="line">月: 9, 日: 27, 秒: 35</span><br><span class="line">当前时间设置后: 2012-10-10T16:22:35.565</span><br><span class="line">当前时间设置后1: 2014-12-12</span><br><span class="line">当前时间设置后2: 22:15</span><br><span class="line">解析字符时间为日期对象: 20:15:30</span><br><span class="line">```  </span><br><span class="line">##### 使用时区的日期时间API  </span><br><span class="line">如果我们需要考虑到时区，就可以使用时区的日期时间API：  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">public class Jdk8Demo &#123;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        Jdk8Demo jdk8Demo = new Jdk8Demo();</span><br><span class="line">        jdk8Demo.testZonedDateTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void testZonedDateTime()&#123;</span><br><span class="line"></span><br><span class="line">        // 解析字符串时间</span><br><span class="line">        ZonedDateTime date1 = ZonedDateTime.parse(&quot;2015-12-03T10:15:30+05:30[Asia/Shanghai]&quot;);</span><br><span class="line">        System.out.println(&quot;解析字符串时间: &quot; + date1);</span><br><span class="line"></span><br><span class="line">        //设置zoneid</span><br><span class="line">        ZoneId id = ZoneId.of(&quot;Europe/Paris&quot;);</span><br><span class="line">        System.out.println(&quot;输出zoneid: &quot; + id);</span><br><span class="line"></span><br><span class="line">        ZoneId currentZone = ZoneId.systemDefault();</span><br><span class="line">        System.out.println(&quot;默认当期时区: &quot; + currentZone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上执行输出：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解析字符串时间: 2015-12-03T10:15:30+08:00[Asia/Shanghai]</span><br><span class="line">输出zoneid: Europe/Paris</span><br><span class="line">默认当期时区: Asia/Shanghai</span><br></pre></td></tr></table></figure><h4 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h4><p>在Java8中，Base64编码已经成为Java类库的标准。<br>Java8内置了Base64编码的编码器和解码器。<br>Base64工具类提供了一套静态方法获取下面三种BASE64编解码器：  </p><ul><li><strong>基本：</strong> 输出被映射到一组字符A-Za-z0-9+/，编码不添加任何行标，输出的解码仅支持A-Za-z0-9+/  </li><li><strong>URL：</strong> 输出映射到一组字符A-Za-z0-9+_，输出是URL和文件。  </li><li><strong>MIME：</strong> 输出映射到MIME友好格式。输出每行不超过76字符，并且使用’\r’并跟随’\n’作为分割。编码输出最后没有行分割。  </li></ul><h5 id="内嵌类"><a href="#内嵌类" class="headerlink" title="内嵌类"></a>内嵌类</h5><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">内嵌类 &amp; 描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">static class Base64.Decoder 该类实现一个解码器用于，使用 Base64 编码来解码字节数据。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">static class Base64.Encoder 该类实现一个编码器，使用 Base64 编码来编码字节数据。</td></tr></tbody></table><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">方法 &amp; 描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">static Base64.Decoder getDecoder() 返回一个 Base64.Decoder ，解码使用基本型 base64 编码方案。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">static Base64.Encoder getEncoder() 返回一个 Base64.Encoder ，编码使用基本型 base64 编码方案。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">static Base64.Decoder getMimeDecoder() 返回一个 Base64.Decoder ，解码使用 MIME 型 base64 编码方案。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">static Base64.Encoder getMimeEncoder() 返回一个 Base64.Encoder ，编码使用 MIME 型 base64 编码方案。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">static Base64.Encoder getMimeEncoder(int lineLength, byte[] lineSeparator) 返回一个 Base64.Encoder ，编码使用 MIME 型 base64 编码方案，可以通过参数指定每行的长度及行的分隔符。</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">static Base64.Decoder getUrlDecoder() 返回一个 Base64.Decoder ，解码使用 URL 和文件名安全型 base64 编码方案。</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">static Base64.Encoder getUrlEncoder() 返回一个 Base64.Encoder ，编码使用 URL 和文件名安全型 base64 编码方案。</td></tr></tbody></table><blockquote><p>注意：Base64 类的很多方法从 java.lang.Object 类继承。  </p></blockquote><h5 id="Base64-实例"><a href="#Base64-实例" class="headerlink" title="Base64 实例"></a>Base64 实例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Jdk8Demo &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Jdk8Demo jdk8Demo = new Jdk8Demo();</span><br><span class="line">        jdk8Demo.testBase64();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void testBase64() &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">            // 基本编码</span><br><span class="line">            String base64encodedString = Base64.getEncoder().encodeToString(&quot;this 是 java8&quot;.getBytes(&quot;utf-8&quot;));</span><br><span class="line">            System.out.println(&quot;Base64字符串 (基本) :&quot; + base64encodedString);</span><br><span class="line"></span><br><span class="line">            // 解码</span><br><span class="line">            byte[] base64decodedBytes = Base64.getDecoder().decode(base64encodedString);</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;原始字符串: &quot; + new String(base64decodedBytes, &quot;utf-8&quot;));</span><br><span class="line">            base64encodedString = Base64.getUrlEncoder().encodeToString(&quot;url编码 &quot;.getBytes(&quot;utf-8&quot;));</span><br><span class="line">            System.out.println(&quot;Base64 编码字符串 (URL) :&quot; + base64encodedString);</span><br><span class="line"></span><br><span class="line">            StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">                stringBuilder.append(UUID.randomUUID().toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            byte[] mimeBytes = stringBuilder.toString().getBytes(&quot;utf-8&quot;);</span><br><span class="line">            String mimeEncodedString = Base64.getMimeEncoder().encodeToString(mimeBytes);</span><br><span class="line">            System.out.println(&quot;Base64 编码字符串 (MIME) :&quot; + mimeEncodedString);</span><br><span class="line"></span><br><span class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">            System.out.println(&quot;Error :&quot; + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Base64字符串 (基本) :dGhpcyDmmK8gamF2YTg=</span><br><span class="line">原始字符串: this 是 java8</span><br><span class="line">Base64 编码字符串 (URL) :dXJs57yW56CBIA==</span><br><span class="line">Base64 编码字符串 (MIME) :YTgxZDgxOTAtZTM3ZS00ODQ1LTk0YjEtOGI4MWViY2VlNmZmZmFhNTdiMTItZTI0NS00ZTJhLWIx</span><br><span class="line">OTQtNGQ4OTFmNTc4MjFiNmU1MGZlNjYtYzhmZS00OWIzLWIzMzItNzA4YWU0NTdhNDQ2MGZjNDg2</span><br><span class="line">NzYtNjc2ZS00M2Y0LWIwNjgtYWQ1ZTA5NTYzNWVlNjZmNTRkZjgtNDljNi00MmVlLTllMjUtZjRl</span><br><span class="line">ZjM3ZjQ3NDk0YjAwMjJhOGYtYjJkMC00MzNhLWEyNDktZGFhNTFiMzMwMTAyYWY1OGEwZmMtZDQ5</span><br><span class="line">MC00ZjUyLWFlYzYtNzk2OTNkZDUwMWEzYzk3OTI2NDUtN2Q5Ni00ZTEzLWFiZWUtNzFlNDMxNTY3</span><br><span class="line">Nzg2YjE2NTU3OTAtMGViOS00YmM4LTg1NjAtYzcxMmNmMDk0NTgxNjdiN2JkMzUtNDVjZS00MjZk</span><br><span class="line">LTgzZTktNmQ3ZGM5YzQ1Njk1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;毫无疑问，Java 8是Java自Java 5（发布于2004年）之后的最重要的版本。这个版本包含语言、编译器、库、工具和JVM等方面的十多个新特性。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>jdk新特性之jdk7</title>
    <link href="https://dongme.site/2018/09/26/jdk%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8Bjdk7/"/>
    <id>https://dongme.site/2018/09/26/jdk新特性之jdk7/</id>
    <published>2018-09-26T09:07:00.000Z</published>
    <updated>2018-10-15T15:39:24.390Z</updated>
    
    <content type="html"><![CDATA[<p>jdk7新特性主要有switch中可以使用字串、泛型实例化类型自动推断、资源自动关闭、新增一些取环境信息的工具方法、Boolean类型反转，空指针安全，参与位运算、字符之间可以使用equals、安全的加减乘除、对Java集合（Collections）的增强支持、数值文本、支持二进制文字、在try catch异常扑捉中，一个catch可以写多个异常类型，用”|”隔开。<br><a id="more"></a>  </p><h4 id="jdk7新特性"><a href="#jdk7新特性" class="headerlink" title="jdk7新特性"></a>jdk7新特性</h4><hr><h5 id="switch中可以使用字串"><a href="#switch中可以使用字串" class="headerlink" title="switch中可以使用字串"></a>switch中可以使用字串</h5> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;a&quot;;</span><br><span class="line">switch (s) &#123;</span><br><span class="line">case &quot;a&quot; :</span><br><span class="line">System.out.println(&quot;a&quot;);</span><br><span class="line">break;</span><br><span class="line">case &quot;b&quot; :</span><br><span class="line">System.out.println(&quot;b&quot;);</span><br><span class="line">break;</span><br><span class="line">default :</span><br><span class="line">System.out.println(&quot;default&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="泛型实例化类型自动推断"><a href="#泛型实例化类型自动推断" class="headerlink" title="泛型实例化类型自动推断"></a>泛型实例化类型自动推断</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// java 7前，前后&lt;&gt;都必须声明类型</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">//java 7 &lt;&gt;不须声明类型，自动根据前面&lt;&gt;推断其类型</span><br><span class="line">List&lt;String&gt; list1 = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><h5 id="资源自动关闭"><a href="#资源自动关闭" class="headerlink" title="资源自动关闭"></a>资源自动关闭</h5><p>在Java中，有许多的资源在使用完成之后需要对其进行关闭操作。举个栗子，InputStream，Writer，Sockets，Connection等等。在Java 7 之前通常都是显示调用其close()方法，在Java 7，你可以不用理会其是否未关闭，我们可以使用try-with-resources代码块。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceCloseTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * java 7以前版本，关闭资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">oldCloseResource</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(path));</span><br><span class="line">            <span class="keyword">return</span> br.readLine();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"BufferedReader Exception"</span> + e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (br != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                    <span class="comment">//br.ready();//资源关闭后，访问资源抛出异常</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.err.println(<span class="string">"BufferedReader close Exception"</span> + e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * java 7版本关闭资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">newCloseResource</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 当try语句块运行结束时，FileInputStream 会被自动关闭。这是因为FileInputStream 实现了java中的java.lang.AutoCloseable接口。</span></span><br><span class="line"><span class="comment">         * 所有实现了这个接口的类都可以在try-with-resources结构中使用。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(path))) &#123;<span class="comment">//try()中可以定义多个资源</span></span><br><span class="line">            <span class="keyword">return</span> br.readLine();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"BufferedReader Exception"</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        oldCloseResource(<span class="string">"C:\\Users\\alvin\\Desktop\\a.txt"</span>);</span><br><span class="line">        newCloseResource(<span class="string">"C:\\Users\\alvin\\Desktop\\a.txt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="新增一些取环境信息的工具方法"><a href="#新增一些取环境信息的工具方法" class="headerlink" title="新增一些取环境信息的工具方法"></a>新增一些取环境信息的工具方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">File System.getUserHomeDir() // 当前用户目录</span><br><span class="line">File System.getUserDir() // 启动java进程时所在的目录</span><br><span class="line">File System.getJavaIoTempDir() // io临时文件夹</span><br><span class="line">File System.getJavaHomeDir() // jre的安装目录</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><h5 id="Boolean类型反转，空指针安全，参与位运算"><a href="#Boolean类型反转，空指针安全，参与位运算" class="headerlink" title="Boolean类型反转，空指针安全，参与位运算"></a>Boolean类型反转，空指针安全，参与位运算</h5><p>在java8中找不到Booleans这个类，是废弃了吗？  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Boolean Booleans.negate(Boolean booleanObj)</span><br><span class="line">True =&gt; False , False =&gt; True, Null =&gt; Null</span><br><span class="line">boolean Booleans.and(boolean[] array)</span><br><span class="line">boolean Booleans.or(boolean[] array)</span><br><span class="line">boolean Booleans.xor(boolean[] array)</span><br><span class="line">boolean Booleans.and(Boolean[] array)</span><br><span class="line">boolean Booleans.or(Boolean[] array)</span><br><span class="line">boolean Booleans.xor(Boolean[] array)</span><br></pre></td></tr></table></figure><h5 id="字符之间可以使用equals"><a href="#字符之间可以使用equals" class="headerlink" title="字符之间可以使用equals"></a>字符之间可以使用equals</h5><p>在java8中不管用呢，是废弃了吗？   </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean Character.equalsIgnoreCase(char ch1, char ch2)</span><br></pre></td></tr></table></figure><h5 id="安全的加减乘除"><a href="#安全的加减乘除" class="headerlink" title="安全的加减乘除"></a>安全的加减乘除</h5><p>在java8中不管用呢，是废弃了吗？  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int Math.safeToInt(long value)</span><br><span class="line">int Math.safeNegate(int value)</span><br><span class="line">long Math.safeSubtract(long value1, int value2)</span><br><span class="line">long Math.safeSubtract(long value1, long value2)</span><br><span class="line">int Math.safeMultiply(int value1, int value2)</span><br><span class="line">long Math.safeMultiply(long value1, int value2)</span><br><span class="line">long Math.safeMultiply(long value1, long value2)</span><br><span class="line">long Math.safeNegate(long value)</span><br><span class="line">int Math.safeAdd(int value1, int value2)</span><br><span class="line">long Math.safeAdd(long value1, int value2)</span><br><span class="line">long Math.safeAdd(long value1, long value2)</span><br><span class="line">int Math.safeSubtract(int value1, int value2)</span><br></pre></td></tr></table></figure><h5 id="对Java集合（Collections）的增强支持"><a href="#对Java集合（Collections）的增强支持" class="headerlink" title="对Java集合（Collections）的增强支持"></a>对Java集合（Collections）的增强支持</h5><p>jdk7以前：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//创建List接口对象</span><br><span class="line">List&lt;String&gt; list=new ArrayList&lt;String&gt;();</span><br><span class="line">list.add(&quot;item1&quot;); //用add()方法获取对象</span><br><span class="line">String Item=list.get(0); //用get()方法获取对象</span><br><span class="line"></span><br><span class="line">//创建Set接口对象</span><br><span class="line">Set&lt;String&gt; set=new HashSet&lt;String&gt;();</span><br><span class="line">set.add(&quot;item1&quot;); //用add()方法添加对象</span><br><span class="line"></span><br><span class="line">//创建Map接口对象</span><br><span class="line">Map&lt;String,String&gt; map=new HashMap&lt;String,String&gt;();</span><br><span class="line">map.put(&quot;key1&quot;, &quot;value1&quot;); //用put()方法添加对象</span><br><span class="line">String value=map.get(&quot;key1&quot;);</span><br></pre></td></tr></table></figure><p>jdk7：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list=[&quot;item1&quot;]; //向List集合中添加元素</span><br><span class="line">String item=list[0]; //从List集合中获取元素</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; set=&#123;&quot;item1&quot;&#125;; //向Set集合对象中添加元素</span><br><span class="line">Map&lt;String,String&gt; map=&#123;&quot;key1&quot;:&quot;value1&quot;&#125;; //向Map集合中添加对象</span><br><span class="line">String value=map[&quot;key1&quot;]; //从Map集合中获取对象</span><br></pre></td></tr></table></figure><p>but：在java8不管用呢。。。  </p><h5 id="数值文本"><a href="#数值文本" class="headerlink" title="数值文本"></a>数值文本</h5><p>未方便数0。。。，支持下划线划分。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如：int twoMillion = 2_000_000;</span><br><span class="line">或  </span><br><span class="line">int twoMillion = 200_0000;</span><br></pre></td></tr></table></figure></p><h5 id="支持二进制文字"><a href="#支持二进制文字" class="headerlink" title="支持二进制文字"></a>支持二进制文字</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例如：int binary = 0b1001_1001;</span><br><span class="line">//下划线可以划在ob1之后到0b10011001之前任何位置</span><br></pre></td></tr></table></figure><h5 id="在try-catch异常扑捉中，一个catch可以写多个异常类型，用”-”隔开"><a href="#在try-catch异常扑捉中，一个catch可以写多个异常类型，用”-”隔开" class="headerlink" title="在try catch异常扑捉中，一个catch可以写多个异常类型，用”|”隔开"></a>在try catch异常扑捉中，一个catch可以写多个异常类型，用”|”隔开</h5><p>jdk7之前：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   ......</span><br><span class="line">&#125; <span class="keyword">catch</span>(ClassNotFoundException ex) &#123;</span><br><span class="line">   ex.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span>(SQLException ex) &#123;</span><br><span class="line">   ex.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk7：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   ......</span><br><span class="line">&#125; <span class="keyword">catch</span>(ClassNotFoundException|SQLException ex) &#123;</span><br><span class="line">   ex.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jdk7新特性主要有switch中可以使用字串、泛型实例化类型自动推断、资源自动关闭、新增一些取环境信息的工具方法、Boolean类型反转，空指针安全，参与位运算、字符之间可以使用equals、安全的加减乘除、对Java集合（Collections）的增强支持、数值文本、支持二进制文字、在try catch异常扑捉中，一个catch可以写多个异常类型，用”|”隔开。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://dongme.site/categories/java/"/>
    
    
      <category term="jdk" scheme="https://dongme.site/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>jdk新特性之jdk6</title>
    <link href="https://dongme.site/2018/09/26/jdk%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8Bjdk6/"/>
    <id>https://dongme.site/2018/09/26/jdk新特性之jdk6/</id>
    <published>2018-09-26T08:53:00.000Z</published>
    <updated>2018-10-15T14:25:23.106Z</updated>
    
    <content type="html"><![CDATA[<p>jdk6新特性主要体现在如下模块：Desktop类和SystemTray类、使用JAXB2来实现对象与XML之间的映射、StAX、使用Compiler API、轻量级Http Server API、插入式注解处理API(Pluggable Annotation Processing API)、用Console开发控制台程序、对脚本语言的支持、Common Annotations及其它一些小改动。<br><a id="more"></a>  </p><h4 id="jdk6新特性"><a href="#jdk6新特性" class="headerlink" title="jdk6新特性"></a>jdk6新特性</h4><hr><h5 id="Desktop类和SystemTray类"><a href="#Desktop类和SystemTray类" class="headerlink" title="Desktop类和SystemTray类"></a>Desktop类和SystemTray类</h5><p>AWT新增加了两个类：Desktop和SystemTray<br>Desktop可以用来打开系统默认浏览器浏览指定的URL，打开系统默认邮件客户端给指定的邮箱发邮件，用默认应用程序打开或编辑文件，<br>用系统默认的打印机打印文档。<br>SystemTray可以在系统托盘区创建一个托盘程序。  </p><h5 id="使用JAXB2来实现对象与XML之间的映射"><a href="#使用JAXB2来实现对象与XML之间的映射" class="headerlink" title="使用JAXB2来实现对象与XML之间的映射"></a>使用JAXB2来实现对象与XML之间的映射</h5><p>JAXB是Java Architecture for XML Binding的缩写，可以将一个Java对象转变成为XML格式，反之亦然。<br>我们把对象与关系数据库之间的映射称为ORM，其实也可以把对象与XML之间的映射称为OXM（Object XML Mapping）。原来JAXB是Java EE<br>的一部分，在JDK1.6中，SUN将其放到了Java SE中，这也是SUN的一贯做法。JDK1.6中自带的这个JAXB版本是2.0，比起1.0来，JAXB2用JDK5<br>的新特性Annotation来标识要作绑定的类和属性，这就极大简化了开发的工作量。<br>实际上，在Java EE 5.0中，EJB和Web Services也通过Annotation来简化开发工作。另外，JAXB2在底层是用StAX(JSR 173)来处理XML文档。<br>除了JAXB之外，我们还可以通过XMLBeans和Castor等来实现同样的功能。  </p><h5 id="StAX"><a href="#StAX" class="headerlink" title="StAX"></a>StAX</h5><p>StAX(JSR 173)是JDK1.6.0中除了DOM和SAX之外的又一种处理XML文档的API。<br>StAX 的来历：在JAXP1.3(JSR 206)有两种处理XML文档的方法：DOM(Document Object Model)和SAX(Simple API for XML)。<br>由于JDK1.6.0中的JAXB2(JSR 222)和JAX-WS 2.0(JSR 224)都会用到StAX所以Sun决定把StAX加入到JAXP家族当中来，并将JAXP的版本升级到1.4(JAXP1.4是JAXP1.3的维护版本)。JDK1.6里面JAXP的版本就是1.4。<br>StAX是The Streaming API for XML的缩写，一种利用拉模式解析(pull-parsing)XML文档的API。StAX通过提供一种基于事件迭代器(Iterator)的API让程序员去控制xml文档解析过程，程序遍历这个事件迭代器去处理每一个解析事件，解析事件可以看做是程序拉出来的，也就是程序促使解析器产生一个解析事件然后处理该事件，之后又促使解析器产生下一个解析事件，如此循环直到碰到文档结束符；<br>SAX也是基于事件处理xml文档，但却是用推模式解析，解析器解析完整个xml文档后，才产生解析事件，然后推给程序去处理这些事件；DOM采用的方式是将整个xml文档映射到一颗内存树，这样就可以很容易地得到父节点和子结点以及兄弟节点的数据，但如果文档很大，将会严重影响性能。  </p><h5 id="使用Compiler-API"><a href="#使用Compiler-API" class="headerlink" title="使用Compiler API"></a>使用Compiler API</h5><p>现在我 们可以用JDK1.6 的Compiler API(JSR 199)去动态编译Java源文件，Compiler API结合反射功能就可以实现动态的产生Java代码并编译执行这些代码，有点动态语言的特征。<br>这个特性对于某些需要用到动态编译的应用程序相当有用，比如JSP Web Server，当我们手动修改JSP后，是不希望需要重启Web Server才可以看到效果的，这时候我们就可以用Compiler API来实现动态编译JSP文件，当然，现在的JSP Web Server也是支持JSP热部署的，现在的JSP Web Server通过在运行期间通过Runtime.exec或ProcessBuilder来调用javac来编译代码，这种方式需要我们产生另一个进程去做编译工作，不够优雅而且容易使代码依赖与特定的操作系统；Compiler API通过一套易用的标准的API提供了更加丰富的方式去做动态编译，而且是跨平台的。  </p><h5 id="轻量级Http-Server-API"><a href="#轻量级Http-Server-API" class="headerlink" title="轻量级Http Server API"></a>轻量级Http Server API</h5><p>JDK1.6 提供了一个简单的Http Server API，据此我们可以构建自己的嵌入式Http Server，它支持Http和Https协议，提供了HTTP1.1的部分实现，没有被实现的那部分可以通过扩展已有的Http Server API来实现，程序员必须自己实现HttpHandler接口，HttpServer会调用HttpHandler实现类的回调方法来处理客户端请求，在这里，我们把一个Http请求和它的响应称为一个交换，包装成HttpExchange类，HttpServer负责将HttpExchange传给HttpHandler实现类的回调方法。  </p><h5 id="插入式注解处理API-Pluggable-Annotation-Processing-API"><a href="#插入式注解处理API-Pluggable-Annotation-Processing-API" class="headerlink" title="插入式注解处理API(Pluggable Annotation Processing API)"></a>插入式注解处理API(Pluggable Annotation Processing API)</h5><p>插入式注解处理API(JSR 269)提供一套标准API来处理Annotations(JSR 175)。<br>实际上JSR 269不仅仅用来处理Annotation，我觉得更强大的功能是它建立了Java语言本身的一个模型，它把method，package，constructor，type，variable， enum，annotation等Java语言元素映射为Types和Elements(两者有什么区别?)，从而将Java语言的语义映射成为对象，我们可以在javax.lang.model包下面可以看到这些类。 所以我们可以利用JSR 269提供的API来构建一个功能丰富的元编程(metaprogramming)环境。<br>JSR 269用Annotation Processor在编译期间而不是运行期间处理Annotation，Annotation Processor相当于编译器的一个插件，所以称为插入式注解处理.如果Annotation Processor处理Annotation时(执行process方法)产生了新的Java代码，编译器会再调用一次Annotation Processor，如果第二次处理还有新代码产生，就会接着调用Annotation Processor，直到没有新代码产生为止.每执行一次process()方法被称为一个”round”，这样整个Annotation processing过程可以看作是一个round的序列。<br>JSR 269主要被设计成为针对Tools或者容器的API. 举个例子，我们想建立一套基于Annotation的单元测试框架(如TestNG)，在测试类里面用Annotation来标识测试期间需要执行的测试方法。  </p><h5 id="用Console开发控制台程序"><a href="#用Console开发控制台程序" class="headerlink" title="用Console开发控制台程序"></a>用Console开发控制台程序</h5><p>JDK1.6中提供了java.io.Console 类专用来访问基于字符的控制台设备。你的程序如果要与Windows下的cmd或者Linux下的Terminal交互，就可以用Console类代劳。但我们不总是能得到可用的Console，一个JVM是否有可用的Console依赖于底层平台和JVM如何被调用。如果JVM是在交互式命令行(比如Windows的cmd)中启动的，并且输入输出没有重定向到另外的地方，那么就可以得到一个可用的Console实例。  </p><h5 id="对脚本语言的支持"><a href="#对脚本语言的支持" class="headerlink" title="对脚本语言的支持"></a>对脚本语言的支持</h5><p>如：ruby，groovy，javascript。  </p><h5 id="Common-Annotations"><a href="#Common-Annotations" class="headerlink" title="Common Annotations"></a>Common Annotations</h5><p>Common annotations原本是Java EE 5.0(JSR 244)规范的一部分，现在SUN把它的一部分放到了Java SE 6.0中。<br>随着Annotation元数据功能(JSR 175)加入到Java SE 5.0里面，很多Java 技术(比如EJB，Web Services)都会用Annotation部分代替XML文件来配置运行参数（或者说是支持声明式编程,如EJB的声明式事务），如果这些技术为通用目的都单独定义了自己的Annotations,显然有点重复建设, 所以,为其他相关的Java技术定义一套公共的Annotation是有价值的，可以避免重复建设的同时，也保证Java SE和Java EE 各种技术的一致性。  </p><h5 id="有一些小的改动"><a href="#有一些小的改动" class="headerlink" title="有一些小的改动"></a>有一些小的改动</h5><p><strong>如下方法获取磁盘使用信息：</strong><br>getTotalSpace() - 返回此抽象路径名指定的分区大小。以字节为单位。  getFreeSpace() - 返回此抽象路径名指定的分区中未分配的字节数。<br>getUsableSpace() - 返回此抽象路径名指定的分区上可用于此虚拟机的字节数。若有可能，此方法将检查写权限和其他操作系统限制，因此与 getFreeSpace() 相比，此方法能更准确地估计可实际写入的新数据数。 </p><p><strong>如下方法获取文件权限：</strong><br>setWritable(boolean writable, boolean ownerOnly) 和 setWritable(boolean writable) - 设置此抽象路径名的所有者或所有用户的写权限。<br>setReadable(boolean readable, boolean ownerOnly) 和 setReadable(boolean readable) - 设置此抽象路径名的所有者或所有用户的读权限。<br>setExecutable(boolean executable, boolean ownerOnly) 和 setExecutable(boolean executable) - 设置此抽象路径名的所有者或所有用户的执行权限。<br>canExecute() - 测试应用程序是否可以执行此抽象路径名表示的文件。 </p><p><strong>IOException类增加构造函数</strong><br>IOException支持异常链通过新的构造函数：IOException(String, Throwable) 和IOException(Throwable)。<br>File.isFile()方法的行为发生变化。<br>Windows环境下对保留设备名如： CON, NUL, AUX, LPT, 等等，永远返回false。  </p><p><strong>java GUI界面的显示的改动</strong><br>JDK6.0（也就是JDK1.6）支持最新的windows vista系统的Windows Aero视窗效果，而JDK1.5不支持。<br>你要在vista环境下编程的话最好装jdk6.0，否则它总是换到windows basic视窗效果。  </p><p><strong>java.nio模块，增加java.nio.channels.SelectorProvider实现类等</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jdk6新特性主要体现在如下模块：Desktop类和SystemTray类、使用JAXB2来实现对象与XML之间的映射、StAX、使用Compiler API、轻量级Http Server API、插入式注解处理API(Pluggable Annotation Processing API)、用Console开发控制台程序、对脚本语言的支持、Common Annotations及其它一些小改动。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://dongme.site/categories/java/"/>
    
    
      <category term="jdk" scheme="https://dongme.site/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>java编程思想[21]-并发</title>
    <link href="https://dongme.site/2018/09/26/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-21/"/>
    <id>https://dongme.site/2018/09/26/java编程思想-21/</id>
    <published>2018-09-26T05:23:00.000Z</published>
    <updated>2018-10-15T14:26:06.723Z</updated>
    
    <content type="html"><![CDATA[<p>并发老生常谈，确实也是java中十分重要的模块，该部分重点讲解并发相关的零碎知识点。<br><a id="more"></a>   </p><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><hr><h5 id="并发的多面性"><a href="#并发的多面性" class="headerlink" title="并发的多面性"></a>并发的多面性</h5><p>用并发解决的问题大体上可以分为速度和设计可管理性两种。  </p><ul><li>更快的执行<br>为了程序运行的更快，并发充分利用这些额外的处理器。<br>单核处理器上并发带来的开销比顺序执行大，因为其中增加了大量的上下文切换。但在单核上使用并发可以防止程序停止，即使一个任务阻塞了，其它任务可以继续执行。  </li><li>改进代码设计<br>单核机器通过并发可以仿真，仿真目标一般都是多任务的，每个线程处理单独的任务。  </li></ul><h5 id="基本的线程机制"><a href="#基本的线程机制" class="headerlink" title="基本的线程机制"></a>基本的线程机制</h5><p>并发编程使我们可以将程序划分为多个分离的、独立运行的任务。通过使用多线程机制，这些独立任务中的每一个都将由执行线程来驱动。  </p><ul><li>定义任务<br>实现Runnable接口，实现方法run。<br>在main方法中直接调用run方法，是顺序执行，并不会启动一个新的线程处理。  </li><li>Thread类<br>将Runnable对象转变为工作任务的传统方式是把它提交给一个Thread构造器。  </li><li><p>使用Executor  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">for()&#123;</span><br><span class="line">   exec.execute(实现Runnable的对象实例);</span><br><span class="line">&#125;</span><br><span class="line">exec.shutdown();</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">可以将上面的CachedThreadPool替换为不同类型的Executor。FixedThreadPool使用了有限的线程集来执行所提交的任务。  </span><br><span class="line">``` </span><br><span class="line">ExecutorService exec = Executor.newFixedThreadPool(5);</span><br><span class="line">for()&#123;</span><br><span class="line">    exec.execute(实现Runnable的对象实例);</span><br><span class="line">&#125;</span><br><span class="line">exec.shutdown();</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">SingleThreadExecutor就像是线程数量为1的FixedTreadPool。这对于希望在另一个线程中连续运行的事物来说，都是很有用的。  </span><br><span class="line">``` </span><br><span class="line">ExecutorService exec = Executor.SingleThreadExecutor();</span><br><span class="line">for()&#123;</span><br><span class="line">    exec.execute(实现Runnable的对象实例);</span><br><span class="line">&#125;</span><br><span class="line">exec.shutdown();</span><br></pre></td></tr></table></figure></li><li><p>从任务中产生返回值<br>Runnable独立执行任务，不返回值。Callable是一种具有类型参数的泛型，它的类型参数表示的是从call()方法返回的值，并且必须使用ExecutorService.submit()方法调用它。如下： </p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line">class TaskWithResult implements Callable&lt;String&gt; &#123;</span><br><span class="line">    private int id;</span><br><span class="line"></span><br><span class="line">    public TaskWithResult(int id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        return &quot;result of TaskWithResult &quot; + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CallableDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        ArrayList&lt;Future&lt;String&gt;&gt; results = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            results.add(exec.submit(new TaskWithResult(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        for (Future&lt;String&gt; fs : results) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(fs.get());</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">                return;</span><br><span class="line">            &#125; catch (ExecutionException e) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;finally &#123;</span><br><span class="line">                exec.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">+ 休眠  </span><br><span class="line">sleep(long)将使任务中止执行指定时间。  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">try &#123;</span><br><span class="line">  TimeUnit.MILLISECONDS.sleep(100);</span><br><span class="line">&#125; catch (InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">+ 优先级  </span><br><span class="line">线程的优先级将该线程的重要性传递给了调度器。优先级较低的线程仅仅是执行的频率较低。  </span><br><span class="line">设置线程的优先级通过setPriority()方法进行设置。  </span><br><span class="line"></span><br><span class="line">+ 后台线程即守护线程  </span><br><span class="line">当所有非后台线程结束时，程序也就终止了，同时会杀死进程中所有的后台线程。  </span><br><span class="line">只要有任何非后台线程还在执行，程序就不好终止。  </span><br><span class="line">通过setDeamon()方法设置为后台线程。</span><br><span class="line"></span><br><span class="line">+ 让步</span><br><span class="line">调用yield()时，你也是在建议具有相同优先级的其他线程可以运行。</span><br><span class="line"></span><br><span class="line">+ 编码的变体</span><br><span class="line">通过继承Thread创建线程类。通过构造器设置线程名。</span><br><span class="line"></span><br><span class="line">+ 术语</span><br><span class="line">任务和线程并不等价。在描述将要执行的任务时使用术语&quot;任务&quot;，只有在引用到驱动任务的具体机制时，才使用线程。只在概念</span><br><span class="line">级别上讨论系统，就可以只使用任务，而不需要提及驱动机制。</span><br><span class="line"></span><br><span class="line">+ 加入一个线程</span><br><span class="line">一个线程可以在其他线程之上调用join()方法，其效果是等待一段时间直到第二个线程结束才继续执行。如果某个线程在另一个线程t上调用</span><br><span class="line">t.join()，此线程将被挂起，直到目标t结束才恢复（即t.isAlive()返回为false）。</span><br><span class="line">也可以在调用join()时带上一个超时参数，如果目标线程在这段时间到期时还没有结束，join()总能返回。</span><br><span class="line">对join()对方法调用可以被中断，做法是在调用线程上调用interrupt()方法，这时需要用到try-catch字句。  </span><br><span class="line"></span><br><span class="line">+ 线程组  </span><br><span class="line">线程组持有一个线程集合。可以把线程组看成是一次不成功的尝试，忽略就好。  </span><br><span class="line"></span><br><span class="line">+ 捕获异常  </span><br><span class="line">由于线程的本质特性，使得你不能捕获从线程中逃逸的异常。一旦异常逃出任务的run()方法，它就会向外传播到控制台。可以用Executor来解决这个问题。</span><br><span class="line">通过在每个Thread对象上都附着一个异常处理器。Thread.UncaughtExceptionHandler.uncaughtException()会在线程因未捕获的异常而临近死亡时被调用。创建一个新类型的ThreadFactory，</span><br><span class="line">它将在每个新创建的Thread对象上附着一个Thread.UncaughtExceptionHandler。  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">class ExceptionThread2 implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        System.out.println(&quot;run() by &quot; + t);</span><br><span class="line">        System.out.println(&quot;eh = &quot; + t.getUncaughtExceptionHandler());</span><br><span class="line">        throw new RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void uncaughtException(Thread t, Throwable e) &#123;</span><br><span class="line">        System.out.println(&quot;caught &quot; + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HandlerThreadFactory implements ThreadFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Thread newThread(Runnable r) &#123;</span><br><span class="line">        System.out.println(this + &quot;creating new Thread&quot;);</span><br><span class="line">        Thread t = new Thread(r);</span><br><span class="line">        System.out.println(&quot;created &quot; + t);</span><br><span class="line">        t.setUncaughtExceptionHandler(new MyUncaughtExceptionHandler());</span><br><span class="line">        System.out.println(&quot;eh = &quot; + t.getUncaughtExceptionHandler());</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CaptureUncaughtException &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool(new HandlerThreadFactory());</span><br><span class="line">        exec.execute(new ExceptionThread2());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">##### 共享受限资源  </span><br><span class="line">基本上所有的并发模式在解决线程冲突问题的时候，都是采用序列化访问共享资源的方案。  </span><br><span class="line">在共享资源的代码前加锁语句来实现，使得一段时间内只有一个任务访问共享资源。锁语句产生了一种互相排斥的效果，所以这种机制常常称为互斥量。  </span><br><span class="line"></span><br><span class="line">+ 描述  </span><br><span class="line"></span><br><span class="line">屋子里的浴室实例：房子里的多个人都希望单独使用浴室。为了使用浴室，一个人先敲门，看看能否使用。如果没人的话，他就进入浴室锁上门。这时其它人</span><br><span class="line">要使用浴室的话，就会被阻挡，所以他们要在门口等待，直到浴室可用。  </span><br><span class="line">当浴室使用完毕，当锁住浴室门的那个人打开锁准备离开的时候，簇拥在门口的人中，离门口最近的那个最有可能成为下一个进入浴室的人。可以通过yield</span><br><span class="line">和setPriority来给线程调度器建议，但这些建议未必有多大效果，这取决于具体的平台和JVM实现。  </span><br><span class="line"></span><br><span class="line">共享资源一般是以对象存在的内存片段，但也可以是文件、输入/输出端口、或者是打印机。要控制对共享资源的访问，得先把它包装成对象，然后把所有要</span><br><span class="line">访问这个资源的方法都标记为synchronized。  </span><br><span class="line"></span><br><span class="line">在使用并发时，将域设置为private是非常重要的。否则，synchronized就不能防止其它任务直接访问域，这样就会产生冲突。  </span><br><span class="line"></span><br><span class="line">一个任务可以多次获得对象的锁，如果调用了一个对象的同步方法，方法中又调用了同一对象的另一个同步方法，JVM负责跟踪统计对象加锁的次数，每进入这个对象</span><br><span class="line">的同步方法，计数加1；每退出这个对象的同步方法，计数减一。如果对象被解锁，计数为0。  </span><br><span class="line"></span><br><span class="line">针对每个类，也有一个锁（作为类的Class对象的一部分），所以synchronized static可以在类的范围内防止对static数据的并发访问。  </span><br><span class="line"></span><br><span class="line">每个访问临界共享资源的方法都应该被同步，否则它们就不能正确的工作。  </span><br><span class="line"></span><br><span class="line">+ 使用显式的Lock对象  </span><br><span class="line"></span><br><span class="line">java.util.concurrent类库包含定义在java.util.concurrent.locks中显示的互斥机制。Lock对象必须被显式地创建、锁定</span><br><span class="line">和释放。与内建的锁形式相比，代码缺乏优雅性，出错的可能性比较大。但是，对于解决某些类型的问题来说，它更加灵活。  </span><br><span class="line"></span><br><span class="line">+ 原子性与易变性  </span><br><span class="line"></span><br><span class="line">原子操作是不能被线程调度机制中断的操作；一旦操作开始，那么它一定在 &quot;上下文切换&quot; 之前执行完毕。原子性不能替代同步，除非</span><br><span class="line">有十足的把握。  </span><br><span class="line">原子性可以应用于除long和double之外的所有基本类型之上的简单操作。当你定义long或double变量时，如果使用volatitle</span><br><span class="line">关键字，就会获得原子性。  </span><br><span class="line"></span><br><span class="line">在多处理器系统上，相对于单处理器系统而言，可视性问题远比原子性问题多得多。一个任务做出的修改，即使在不中断的意义上讲</span><br><span class="line">是原子性的，对其他任务也可能是不可视的。  </span><br><span class="line"></span><br><span class="line">volatitle确保了应用中的可视性。一个域声明为volatitle的，那么只要对这个域产生了写操作，那么所有的读操作就都可以看到</span><br><span class="line">这个修改。volatitle域会立即被写入到主内存中，而读取操作就发生在主内存中。  </span><br><span class="line"></span><br><span class="line">synchronized会将工作内存变量值刷新到主内存中，用synchronized一般不需要volatitle。  </span><br><span class="line"></span><br><span class="line">使用volatile而不是synchronized关键字的唯一安全的情况是类中只有一个可变的域。再次提醒，你的第一选择应该是使用synchronized</span><br><span class="line">关键字，这是最安全的方式，而尝试其他任何方式都是有风险的。</span><br><span class="line"></span><br><span class="line">+ 原子类  </span><br><span class="line"></span><br><span class="line">AtomicInteger、AtomicLong、AtomicReference等原子变量类，一般涉及到性能调优会用到。常规编程也很少用到。  </span><br><span class="line"></span><br><span class="line">+ 临界区  </span><br><span class="line"></span><br><span class="line">也称为同步代码块；防止多个线程同时访问方法内部的部分代码而不是防止访问整个方法。通过这种方式分离出的代码段被称为</span><br><span class="line">临界区，形式如下：  </span><br><span class="line">``` </span><br><span class="line">synchronized(syncObject) &#123;</span><br><span class="line">  //</span><br><span class="line">  //</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在其他对象上同步   </li></ul><p>synchronized块必须给定一个在其上进行同步的对象，使用synchronized(this)时，其他synchronized方法和临界区就不能<br>被调用。因此一般设置一个私有成员变量，以该变量作为同步对象。  </p><ul><li>线程本地存储  </li></ul><p>线程本地存储是一种自动化机制，可以为使用相同变量的每个不同的线程都创建不同的存储。<br>创建和管理本地存储一般使用java.lang.ThreadLocal类来实现。<br>ThreadLocal对象通常当作静态域存储。在创建ThreadLocal时，你只能通过get()和set()方法来访问该对象内容。<br>其中get()方法将返回与其线程相关联的对象的副本，而set()会将参数插入到为其线程存储的对象中，并返回存储中<br>原有的对象。  </p><h5 id="终结任务"><a href="#终结任务" class="headerlink" title="终结任务"></a>终结任务</h5><ul><li>装饰性花园  </li><li>在阻塞时终结  </li></ul><p>sleep()的一种情况，它使任务从执行状态变为被阻塞状态，而有时你必须终止被阻塞的任务。  </p><p><strong>线程状态</strong><br>1）新建（New）:当线程被创建时，它只会短暂地处于这种状态。此时它已经分配了必须的系统资源，并执行了<br>初始化。此刻线程已有资格获得CPU时间了，之后调度器将把这个线程转变为可运行状态或阻塞状态。<br>2）就绪（Runnable）：在这种状态下，只要调度器把时间片分配给线程，线程就可以运行。<br>3）阻塞（Blocked）：线程能够运行，但有某个条件阻止它的运行。当线程处于阻塞状态时，调度器将忽略线程，不会<br>分配线程任何cpu时间。直到线程重新进入就绪状态。<br>4）死亡（Dead）：处于死亡或终止状态的线程将不再是可调度的，并且再也不会得到cpu时间，它的任务已结束，或不再<br>是可运行的。任务死亡的通常方式是从run()方法返回，但是任务的线程还可以被中断。  </p><p><strong>进入阻塞状态</strong><br>进入阻塞状态的原因有如下：<br>1）通过调用sleep(milliseconds)使任务进入休眠状态，在这种情况下，任务在指定时间内不会运行。<br>2）调用wait()使线程挂起。直到线程得到了notify()或notifyAll()的消息（或在java.util.concurrent类库中等价的signal()或signalAll()消息），<br>线程才会进入就绪状态。<br>3）任务在等待某个输入/输出完成。<br>4）任务试图在某个对象上调用其同步控制方法，但是对象锁不可用，因为另一个任务已经获取了这个锁。<br>在较早的代码中可能看到suspend()和resume()来阻塞和唤醒线程，因为可能导致死锁，现在已经废弃了。stop()<br>方法也已经被弃用了，因为它不释放线程获得的锁，并且如果线程处于不一致状态，其它任务可以在这种状态下浏览并<br>修改它们，造成的问题难以发现。  </p><ul><li><p>中断<br>异常中断通过调用Thread的interrupt()方法。<br>当线程抛出异常InterruptedException或调用中断方法时，中断状态将被复位。<br>SleepBlocked是可中断，IOBlocked和SynchronizedBlocked是不可以中断的，对于这类问题可以关闭任务在其上发生阻塞的底层资源。  </p></li><li><p>被互斥所阻塞  </p></li><li>检查中断<br>通过调用interrupted()来检查中断状态。  </li></ul><h5 id="线程之间的协作"><a href="#线程之间的协作" class="headerlink" title="线程之间的协作"></a>线程之间的协作</h5><ul><li>wait()与notifyAll()<br>调用sleep()和yield()时候锁并没有被释放。<br>wait()调用时，线程将被挂起，对象上的锁被释放。在该对象上的其它synchronized方法在wait()期间被调用。<br>两种形式的wait：第一种接受毫秒作为参数，意为在此期间等待；第二种没有参数，一直等待。两种方式都可以通过notify和notifyAll恢复执行。<br>wait、notify、notifyAll这些方法是基类Object的一部分。在调用这些方法前必须先获取该对象的锁。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sychronized(x) &#123;</span><br><span class="line">    x.notifyAll();</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">+ 错失的信号  </span><br><span class="line">+ notify()与nitifyAll()  </span><br><span class="line">使用nitify()而不是nitifyAll()是一种优化。  </span><br><span class="line">使用notify()时，在众多等待同一个锁的任务中只有一个会被唤醒，因此要使用notify就必须保证被唤醒的是恰当的任务。  </span><br><span class="line"></span><br><span class="line">+ 生产者与消费者  </span><br><span class="line"></span><br><span class="line">+ 使用显示的Lock和Condition对象</span><br></pre></td></tr></table></figure></li></ul><p>private Lock lock = new ReentrantLock();<br>private Condition condition = lock.newCondition();<br>public void test() {<br>    lock.lock();<br>    try {<br>      condition.await();<br>      condition.signalAll();//<br>    } finally {<br>      lock.unlock();<br>    }<br>}<br>```  </p><ul><li>生产者-消费者队列  </li><li>任务间使用管道进行输入/输出  </li></ul><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><h5 id="新类库中的构件"><a href="#新类库中的构件" class="headerlink" title="新类库中的构件"></a>新类库中的构件</h5><ul><li>CountDownLatch<br>它被用来同步一个或多个任务，强制它们等待由其他任务执行的一组操作完成。不能充值。  </li><li>CyclicBarrier<br>你希望创建一组任务，它们并行地执行工作，然后在进行下一个步骤之前等待，直至所有任务都完成。可以重置。  </li><li>DelayQueue<br>一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象的延迟<br>到期的时间最长。如果没有任何延迟到期，那么就不会有任何头元素。  </li><li>PriorityBlockingQueue<br>这是一个很基础的优先级队列，它具有可阻塞的读取操作。  </li><li>使用ScheduledExecutor的温室控制器  </li><li>Semaphore<br>计数信号量允许n个任务同时访问这个资源。  </li><li>Exchanger<br>Exchanger是在两个任务之间交换对象的栅栏。当这些任务进入栅栏时，它们各自拥有一个对象，当它们离开时，它们都拥有之前由对象持有的对象。  </li></ul><h5 id="仿真"><a href="#仿真" class="headerlink" title="仿真"></a>仿真</h5><h5 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h5><h5 id="活动对象"><a href="#活动对象" class="headerlink" title="活动对象"></a>活动对象</h5>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并发老生常谈，确实也是java中十分重要的模块，该部分重点讲解并发相关的零碎知识点。&lt;br&gt;
    
    </summary>
    
    
      <category term="编程思想" scheme="https://dongme.site/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>java编程思想[17]-容器</title>
    <link href="https://dongme.site/2018/09/25/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-17/"/>
    <id>https://dongme.site/2018/09/25/java编程思想-17/</id>
    <published>2018-09-25T10:32:00.000Z</published>
    <updated>2018-10-15T14:26:29.570Z</updated>
    
    <content type="html"><![CDATA[<p>在Java当中，如果有一个类专门用来存放其它类的对象，这个类就叫做容器，或者就叫做集合，集合就是将若干性质相同或相近的类对象组合在一起而形成的一个整体。<br><a id="more"></a> </p><h4 id="容器深入研究"><a href="#容器深入研究" class="headerlink" title="容器深入研究"></a>容器深入研究</h4><hr><h5 id="完整的容器分类法"><a href="#完整的容器分类法" class="headerlink" title="完整的容器分类法"></a>完整的容器分类法</h5><h5 id="填充容器"><a href="#填充容器" class="headerlink" title="填充容器"></a>填充容器</h5><p>使用Collections.nCopies()进行填充，可以自定义添加填充个数，而Collections.fill()只能替换元素不能添加元素。  </p><h5 id="Collections的功能方法"><a href="#Collections的功能方法" class="headerlink" title="Collections的功能方法"></a>Collections的功能方法</h5><p>如下Collection所有操作，也是可以通过Set或List执行的所有操作（List还有额外功能）。Map不是继承自Collecion所以不使用下面方法。  </p><ul><li>boolean add(T) 确保容器持有具有泛型类型T的参数。如果没有将此参数添加进容器，则返回false。  </li><li>boolean addAll(Collection&lt;? extends T&gt;) 添加参数中的所有元素，只要添加了任意元素就返回true。  </li><li>void clear()  移除容器中的所有元素。  </li><li>boolean contains(T) 如果容器已经持有具有泛型类型T此参数，则返回true。  </li><li>Boolean containsAll(Collecion&lt;?&gt;) 如果容器持有此参数的所有元素，则返回true。  </li><li>boolean isEmpty() 容器中没有任何元素返回true。  </li><li>Iterator<t> iterator() 返回一个Iterator<t>，可以用来遍历容器中的元素。  </t></t></li><li>Boolean remove(Object) 如果参数在容器中，则移除此元素一个实例。如果做了移除动作，返回true。  </li><li>boolean removeAll(Collection&lt;?&gt;) 移除参数中的所有元素。只要有移除动作发生就返回true。  </li><li>Boolean retainAll(Collection&lt;?&gt;) 只保存参数中的元素（应用集合论的”交集”概念）。 只要集合发生了改变就返回true。  </li><li>int size()返回容器中元素数目。  </li><li>Object[] toArray() 返回一个数组，该数组包含容器中的所有元素。  </li><li><t> T[] toArray(T[] a) 返回一个数组，该数组包含容器中的所有元素。返回结果的运行时类型与参数数组a的相同，而不是单纯的Object。  </t></li></ul><h5 id="可选操作"><a href="#可选操作" class="headerlink" title="可选操作"></a>可选操作</h5><h5 id="List的功能方法"><a href="#List的功能方法" class="headerlink" title="List的功能方法"></a>List的功能方法</h5><h5 id="Set和存储顺序"><a href="#Set和存储顺序" class="headerlink" title="Set和存储顺序"></a>Set和存储顺序</h5><p>Set中的存储顺序如何维护，Set的不同实现之间有所变化。因此不同Set实现不仅有不同的行为，而且它们对于可以在特定的Set中放置的元素的类型也有不同的要求  </p><blockquote><p><strong>Set（interface）:</strong>存入Set的每个元素必须是唯一的，因为Set不保存重复元素。加入Set的元素必须定义equals()方法以确保对象的唯一性。Set与Collection有完全一样的接口。Set接口不保证维护元素的次序。<br><strong>HashSet：</strong>为快速查找而设计的Set，存入HashSet的元素必须定义hashCode()，没有其他的限制，应默认采取该方式，对速度进行了优化。<br><strong>TreeSet：</strong>保持次序的Set，底层为树结构。使用它可以从Set中提取有序的序列。元素必须实现Comparable<br><strong>LinkedHashSet：</strong>具有HashSet的查询速度，且内部使用链表维护元素的顺序（插入的次序）。于是在使用迭代器遍历Set时，结果会按元素插入的次序显示，元素也必须定义hashCode()方法   </p></blockquote><ul><li>SortedSet<br>SortedSet中的元素可以保证处于排序状态，具有如下方法提供的附加功能：<br><strong>Comparator comparator()</strong>返回当前Set使用的Comparator。<br><strong>Object first()</strong>返回容器中的第一个元素。<br><strong>Object last()</strong>返回容器中的最末一个元素。<br><strong>SortedSet subSet(fromElement, toElement)</strong>返回从fromElement（包含）到toElement（不包含）<br><strong>SortedSet headSet(toElement)</strong>生成此Set的子集，由小于toElement的元素组成。<br><strong>SortedSet tailSet(fromElement)</strong>生成此Set的子集，由大于或等于fromElement的元素组成。  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">public class SortedSetDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SortedSet&lt;String&gt; sortedSet = new TreeSet&lt;&gt;();</span><br><span class="line">        Collections.addAll(sortedSet, &quot;one two three four five six seven eight&quot;.split(&quot; &quot;));</span><br><span class="line">        System.out.println(sortedSet);</span><br><span class="line">        String low = sortedSet.first();</span><br><span class="line">        String high = sortedSet.last();</span><br><span class="line">        System.out.println(low);</span><br><span class="line">        System.out.println(high);</span><br><span class="line">        Iterator&lt;String&gt; it = sortedSet.iterator();</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt;= 6; i++) &#123;</span><br><span class="line">    if (i == 3) &#123;</span><br><span class="line">    low = it.next();</span><br><span class="line">    System.out.println(&quot;i==3 low:&quot; + low);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    if (i == 6) &#123;</span><br><span class="line">    high = it.next();</span><br><span class="line">    System.out.println(&quot;i==6 high:&quot; + high);</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    String temp =  it.next();</span><br><span class="line">    System.out.println(&quot;temp:&quot; + temp);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(low);</span><br><span class="line">    System.out.println(high);</span><br><span class="line">    System.out.println(sortedSet.subSet(low,high));</span><br><span class="line">    System.out.println(sortedSet.headSet(high));</span><br><span class="line">    System.out.println(sortedSet.tailSet(low));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// output : </span><br><span class="line">[eight, five, four, one, seven, six, three, two]</span><br><span class="line">eight</span><br><span class="line">two</span><br><span class="line">temp:eight</span><br><span class="line">temp:five</span><br><span class="line">temp:four</span><br><span class="line">i==3 low:one</span><br><span class="line">temp:seven</span><br><span class="line">temp:six</span><br><span class="line">temp:three</span><br><span class="line">i==6 high:two</span><br><span class="line">one</span><br><span class="line">two</span><br><span class="line">[one, seven, six, three]</span><br><span class="line">[eight, five, four, one, seven, six, three]</span><br><span class="line">[one, seven, six, three, two]</span><br><span class="line">```  </span><br><span class="line">注意：SortedSet是按照元素的比较函数对元素排序，而不是元素插入的顺序。出入顺序可以用LinkedHashSet保存。   </span><br><span class="line"></span><br><span class="line">##### 队列  </span><br><span class="line">+ Java SE5中仅有的两个实现是LinkedList和PriorityQueue，它们差异在于排序行为而不是性能。  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">public class QueueBehavior &#123;</span><br><span class="line">    private static int count = 10;</span><br><span class="line"></span><br><span class="line">    static &lt;T&gt; void test(Queue&lt;T&gt; queue, Generator&lt;T&gt; gen) &#123;</span><br><span class="line">        for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            queue.offer(gen.next());//队尾添加元素，队满返回false</span><br><span class="line">        &#125;</span><br><span class="line">        while (queue.peek() != null) &#123;//取队头，没有返回null</span><br><span class="line">            System.out.print(queue.remove() + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    static class Gen implements Generator&lt;String&gt; &#123;</span><br><span class="line">        String[] s = (&quot;one two three four five six seven eight nine ten&quot;).split(&quot; &quot;);</span><br><span class="line">        int i;</span><br><span class="line">        public String next() &#123;</span><br><span class="line">            return s[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        test(new LinkedList&lt;String&gt;(), new Gen());</span><br><span class="line">        test(new PriorityQueue&lt;String&gt;(), new Gen());//优先队列的作用是能保证每次取出的元素都是队列中权值最小的</span><br><span class="line">        test(new ArrayBlockingQueue&lt;&gt;(count), new Gen());//阻塞队列</span><br><span class="line">        test(new ConcurrentLinkedDeque&lt;&gt;(), new Gen());//非阻塞线程安全队列</span><br><span class="line">        test(new LinkedBlockingDeque&lt;&gt;(), new Gen());//基于链表的双端阻塞队列，支持FIFO和FILO，线程安全</span><br><span class="line">        test(new PriorityBlockingQueue&lt;&gt;(), new Gen());//阻塞优先级队列，线程安全</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">+ 双向队列   </span><br><span class="line">ArrayDeque不是线程安全的，可以双向（队头和队尾操作），主要方法：</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">1.添加元素</span><br><span class="line">        addFirst(E e)在数组前面添加元素</span><br><span class="line">        addLast(E e)在数组后面添加元素</span><br><span class="line">        offerFirst(E e) 在数组前面添加元素，并返回是否添加成功</span><br><span class="line">        offerLast(E e) 在数组后天添加元素，并返回是否添加成功</span><br><span class="line"></span><br><span class="line">  2.删除元素</span><br><span class="line">        removeFirst()删除第一个元素，并返回删除元素的值,如果元素为null，将抛出异常</span><br><span class="line">        pollFirst()删除第一个元素，并返回删除元素的值，如果元素为null，将返回null</span><br><span class="line">        removeLast()删除最后一个元素，并返回删除元素的值，如果为null，将抛出异常</span><br><span class="line">        pollLast()删除最后一个元素，并返回删除元素的值，如果为null，将返回null</span><br><span class="line">        removeFirstOccurrence(Object o) 删除第一次出现的指定元素</span><br><span class="line">        removeLastOccurrence(Object o) 删除最后一次出现的指定元素</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   3.获取元素</span><br><span class="line">        getFirst() 获取第一个元素,如果没有将抛出异常</span><br><span class="line">        getLast() 获取最后一个元素，如果没有将抛出异常</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    4.队列操作</span><br><span class="line">        add(E e) 在队列尾部添加一个元素</span><br><span class="line">        offer(E e) 在队列尾部添加一个元素，并返回是否成功</span><br><span class="line">        remove() 删除队列中第一个元素，并返回该元素的值，如果元素为null，将抛出异常(其实底层调用的是removeFirst())</span><br><span class="line">        poll()  删除队列中第一个元素，并返回该元素的值,如果元素为null，将返回null(其实调用的是pollFirst())</span><br><span class="line">        element() 获取第一个元素，如果没有将抛出异常</span><br><span class="line">        peek() 获取第一个元素，如果返回null</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">    5.栈操作</span><br><span class="line">        push(E e) 栈顶添加一个元素</span><br><span class="line">        pop(E e) 移除栈顶元素,如果栈顶没有元素将抛出异常</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    6.其他</span><br><span class="line">        size() 获取队列中元素个数</span><br><span class="line">        isEmpty() 判断队列是否为空</span><br><span class="line">        iterator() 迭代器，从前向后迭代</span><br><span class="line">        descendingIterator() 迭代器，从后向前迭代</span><br><span class="line">        contain(Object o) 判断队列中是否存在该元素</span><br><span class="line">        toArray() 转成数组</span><br><span class="line">        clear() 清空队列</span><br><span class="line">        clone() 克隆(复制)一个新的队列</span><br></pre></td></tr></table></figure><h5 id="理解Map"><a href="#理解Map" class="headerlink" title="理解Map"></a>理解Map</h5><ul><li>性能<br>HashMap是使用对象的hashCode()进行快速查询的，此方法能够显著提高性能。<br>下面是基本的Map实现。在HashMap上打星号表示如果没有其他的限制，它就应该成为你的默认选择，因为它对速度进行了优化。其它实现强调了其他的特性，因此都不如HashMap快。  </li></ul><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">HashMap</td><td style="text-align:left">Map基于散列表的实现。插入和查询键值对的开销是固定的。可以通过构造器设置容量和负载因子，以调整容器的性能。</td></tr><tr><td style="text-align:left">LinkedHashMap</td><td style="text-align:left">类似于HashMap，但是迭代遍历它时，取得键值对的顺序是其插入次序，或者是最近最少使用的次序。只比HashMap慢一点，而在迭代访问时反而更快，因为它使用链表维护内部次序。</td></tr><tr><td style="text-align:left">TreeMap</td><td style="text-align:left">基于红黑树的实现。查看键或键值对时，它们会被排序（有Comparable或Comparator决定）。TreeMap的特点在于，所得到的结果是经过排序的。唯一带有subMap()方法的Map。</td></tr><tr><td style="text-align:left">WeakHashMap</td><td style="text-align:left">弱键映射，允许释放映射所指向的对象；为解决某类特殊问题而设计的。如果映射之外没有引用指向某个键，则此键可以被垃圾回收器回收。</td></tr><tr><td style="text-align:left">ConcurrentHashMap</td><td style="text-align:left">一种线程安全的Map，它不涉及同步加锁。</td></tr><tr><td style="text-align:left">IdentityHashMap</td><td style="text-align:left">使用==代替equals对键进行比较的散列映射。</td></tr></tbody></table><ul><li><p>SortedMap<br>使用SortedMap（TreeMap是现阶段唯一实现），可以确保键处于排序状态。  </p><pre><code>//返回元素比较器。如果是自然顺序，则返回null；  Comparator&lt;? super K&gt; comparator();  //返回从fromKey到toKey的集合：含头不含尾  java.util.SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey);  //返回从头到toKey的集合：不包含toKey  java.util.SortedMap&lt;K,V&gt; headMap(K toKey);  //返回从fromKey到结尾的集合：包含fromKey  java.util.SortedMap&lt;K,V&gt; tailMap(K fromKey);  //返回集合中的第一个元素：  K firstKey();  //返回集合中的最后一个元素：  K lastKey();  //返回集合中所有key的集合：  Set&lt;K&gt; keySet();  //返回集合中所有value的集合：  Collection&lt;V&gt; values();  //返回集合中的元素映射：  Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</code></pre></li><li>LinkedHashMap<br>LinkedHashMap 是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，<br>按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。  </li></ul><h5 id="散列和散列码"><a href="#散列和散列码" class="headerlink" title="散列和散列码"></a>散列和散列码</h5><p>假如键没有按照一定的顺序进行保存，那么查询的时候就只能按照顺序进行线性查询，然而，线性查询是最慢的查询方式。所以，将键值按照一定的顺序排序，并且使用二分查找能购有效的提升速度。散列在此之上，更近一步，他将键保存在数组中(数组的查询速度最快)，用数组来表示键的信息，但是由于Map的容量是可变的，而数组的容量是不变的。要解决这个问题，数组中存的并不是键本身，而是键对象生成的一个数字，将其作为数组的下标，这个数字就是散列码。<br>而这种办法所产生的问题就是下标重复。而我们的解决办法就是配合equals来确定键值。<br>查询的过程首先就是计算散列码，然后用散列码来查询函数(下标)，通常，我们的数组中保存的是值的list，因此，我们计算出散列码之后，通过下表取到的对应部分的list，然后通过equals就可以快速找到键值。  </p><p>散列码：通过hashCode返回int类型的数值，即为对象的散列码。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Java当中，如果有一个类专门用来存放其它类的对象，这个类就叫做容器，或者就叫做集合，集合就是将若干性质相同或相近的类对象组合在一起而形成的一个整体。&lt;br&gt;
    
    </summary>
    
    
      <category term="编程思想" scheme="https://dongme.site/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>java编程思想[16]-数组</title>
    <link href="https://dongme.site/2018/08/23/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-16/"/>
    <id>https://dongme.site/2018/08/23/java编程思想-16/</id>
    <published>2018-08-23T07:34:00.000Z</published>
    <updated>2018-10-15T14:26:47.016Z</updated>
    
    <content type="html"><![CDATA[<p>泛型对数组是极大的威胁，带有泛型的容器拥有更强大的适用性。只有在证明性能受限时，才会考虑使用数组，但数组还是必须掌握的基础知识。<br><a id="more"></a>  </p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><hr><h5 id="数组为什么特殊"><a href="#数组为什么特殊" class="headerlink" title="数组为什么特殊"></a>数组为什么特殊</h5><ul><li>数组是一种效率最高的存储和随机访问对象引用序列的方式。数组就是一个简单的线性序列，这使得元素访问非常快速。数据大小固定。  </li></ul><p>数组与泛型容器比较：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class BerylliumSphere &#123;</span><br><span class="line">private static long counter;</span><br><span class="line">private final long id = counter++;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;Sphere &quot; + id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ContainerComparison &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">BerylliumSphere[] spheres = new BerylliumSphere[10];</span><br><span class="line">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">spheres[i] = new BerylliumSphere();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(spheres));</span><br><span class="line">System.out.println(spheres[4]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">List&lt;BerylliumSphere&gt; sphereList = new ArrayList&lt;&gt;();</span><br><span class="line">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">sphereList.add(new BerylliumSphere());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sphereList);</span><br><span class="line">System.out.println(sphereList.get(4));</span><br><span class="line"></span><br><span class="line">int[] integers = &#123;0, 1, 2, 3, 4, 5&#125;;</span><br><span class="line">System.out.println(Arrays.toString(integers));</span><br><span class="line">System.out.println(integers[4]);</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; intList = new ArrayList&lt;&gt;(Arrays.asList(0, 1, 2, 3, 4, 5));</span><br><span class="line">intList.add(97);</span><br><span class="line">System.out.println(intList);</span><br><span class="line">System.out.println(intList.get(4));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h5><p>初始化赋值，也可以循环赋。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MultidimensionalPrimitiveArray &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  int[][] a = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;&#125;;</span><br><span class="line">  System.out.println(Arrays.deepToString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="数组与泛型"><a href="#数组与泛型" class="headerlink" title="数组与泛型"></a>数组与泛型</h5><p>不能实例化具有参数化类型的数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">Peel&lt;Banana&gt;[] peels = new Peel&lt;Banana&gt;[10];//Illegal</span><br><span class="line">```  </span><br><span class="line">擦除会移除参数类型信息，而数组必须知道它们所持有的确切类型，以强制保证类型安全。  </span><br><span class="line">但是，可以参数化数组本身的类型：  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">class ClassParameter&lt;T&gt; &#123;</span><br><span class="line">    public T[] f(T[] arg) &#123;</span><br><span class="line">        return arg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MethodParameter &#123;</span><br><span class="line">    public static &lt;T&gt; T[] f(T[] arg) &#123;</span><br><span class="line">        return arg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ParameteriaedArrayType &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer[] ints = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">        Double[] doubles = &#123;1.1, 2.2, 3.3, 4.4, 5.5&#125;;</span><br><span class="line">        Integer[] ints2 = new ClassParameter&lt;Integer&gt;().f(ints);</span><br><span class="line">        Double[] doubles2 = new ClassParameter&lt;Double&gt;().f(doubles);</span><br><span class="line">        ints2 = MethodParameter.f(ints);</span><br><span class="line">        doubles = MethodParameter.f(doubles);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">##### 创建测试数据  </span><br><span class="line">+ Arrays.fill()  </span><br><span class="line">只能用同一个值填充各个位置，而针对对象而言，就是复制同一个引用进行填充。  </span><br><span class="line">``` </span><br><span class="line">public class FillingArrays &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int size = 6;</span><br><span class="line">        boolean[] a1 = new boolean[size];</span><br><span class="line">        byte[] a2 = new byte[size];</span><br><span class="line">        char[] a3 = new char[size];</span><br><span class="line">        short[] a4 = new short[size];</span><br><span class="line">        int[] a5 = new int[size];</span><br><span class="line">        long[] a6 = new long[size];</span><br><span class="line">        float[] a7 = new float[size];</span><br><span class="line">        double[] a8 = new double[size];</span><br><span class="line">        String[] a9 = new String[size];</span><br><span class="line">        Arrays.fill(a1, true);</span><br><span class="line">        System.out.println(&quot;a1 = &quot; + Arrays.toString(a1));</span><br><span class="line">        Arrays.fill(a2, (byte)11);</span><br><span class="line">        System.out.println(&quot;a2 = &quot; + Arrays.toString(a2));</span><br><span class="line">        Arrays.fill(a3, &apos;x&apos;);</span><br><span class="line">        System.out.println(&quot;a3 = &quot; + Arrays.toString(a3));</span><br><span class="line">        Arrays.fill(a4, (short)17);</span><br><span class="line">        System.out.println(&quot;a4 = &quot; + Arrays.toString(a4));</span><br><span class="line">        Arrays.fill(a5, 19);</span><br><span class="line">        System.out.println(&quot;a5 = &quot; + Arrays.toString(a5));</span><br><span class="line">        Arrays.fill(a6, 23);</span><br><span class="line">        System.out.println(&quot;a6 = &quot; + Arrays.toString(a6));</span><br><span class="line">        Arrays.fill(a7, 29);</span><br><span class="line">        System.out.println(&quot;a7 = &quot; + Arrays.toString(a7));</span><br><span class="line">        Arrays.fill(a8, 47);</span><br><span class="line">        System.out.println(&quot;a8 = &quot; + Arrays.toString(a8));</span><br><span class="line">        Arrays.fill(a9, &quot;hello&quot;);</span><br><span class="line">        System.out.println(&quot;a9 = &quot; + Arrays.toString(a9));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="Arrays实用功能"><a href="#Arrays实用功能" class="headerlink" title="Arrays实用功能"></a>Arrays实用功能</h5><ul><li>数组复制  </li></ul><blockquote><p>Java标准类库提供有static方法 <code>System.arraycopy()</code>，用它复制数组比用for循环快很多。<br>该方法不会执行自动拆包和自动包装，两个数组必须具有相同的确切类型。<br>如果数组存储的是对象，则拷贝属于浅复制，仅复制对象引用。</p></blockquote><p>参数详解：<br> <code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code> 其中，src表示源数组，srcPos表示源数组要复制的起始位置，dest表示目标数组，<br>destPos表示目标数组开始复制的起始位置，length表示要复制的长度。  </p><ul><li>数组的比较  </li></ul><blockquote><p>Arrays类提供了重载后的equals()方法，用来比较整个数组。<br>数组相等的条件是个数必须相等，并且对于位置的元素也相等，对每一个元素使用equals()作比较来判断。  </p></blockquote><p>参数详解：<br><code>Arrays.equals(a1, a2)</code>其中，a1为数组1，a2为数组2。  </p><ul><li>数组元素的比较  </li></ul><blockquote><p>基本数据类型的数组不需要实现自己的比较器，java提供默认比较器。  </p></blockquote><p>提供两种实现方式，对象实现接口java.lang.Comparable接口，使你的类天生具有”天生”比较能力。此方法要实现compareTo()一个方法。此方法接收另一个Object为参数，如果当前对象小于参数则返回负值，<br>如果相等就返回零，如果当前对象大于参数则返回正值。数组排序依赖于数组元素的比较，在数组对象实现Comparable接口后，调用<code>Arrays.sort(object)</code>其中object为目标数组，进行排序，只提供了升序排列。  </p><p>第二种也可以实现自己的比较器Comparator。然后调用<code>Arrays.sort(object, 比较器)</code>其中object为目标数组，比较器是自己实现的比较器。如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ComTypeComparator implements Comparator&lt;Object&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Object o1, Object o2) &#123;</span><br><span class="line">        return o1.hashCode() &lt; o2.hashCode() ? -1 : o1.hashCode() == o2.hashCode() ? 0 : 1 ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在已排序的数组中查找<br><code>Arrays.binarySearch(object[], object key)</code>其中object[]为查找的目标数组，key为要查找的值。如果key在数组中，则返回搜索值的索引；否则返回-1或者”-“(插入点)。插入点是索引键将要插入数组的那一点，即第一个大于该键的元素索引。  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int a[] = new int[] &#123;1, 3, 4, 6, 8, 9&#125;;</span><br><span class="line">    int x1 = Arrays.binarySearch(a, 5);</span><br><span class="line">    int x2 = Arrays.binarySearch(a, 4);</span><br><span class="line">    int x3 = Arrays.binarySearch(a, 0);</span><br><span class="line">    int x4 = Arrays.binarySearch(a, 10);</span><br><span class="line">    System.out.println(&quot;x1:&quot; + x1 + &quot;, x2:&quot; + x2);</span><br><span class="line">    System.out.println(&quot;x3:&quot; + x3 + &quot;, x4:&quot; + x4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;泛型对数组是极大的威胁，带有泛型的容器拥有更强大的适用性。只有在证明性能受限时，才会考虑使用数组，但数组还是必须掌握的基础知识。&lt;br&gt;
    
    </summary>
    
    
      <category term="编程思想" scheme="https://dongme.site/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>java编程思想[15]-范型</title>
    <link href="https://dongme.site/2018/08/23/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-15/"/>
    <id>https://dongme.site/2018/08/23/java编程思想-15/</id>
    <published>2018-08-23T07:32:00.000Z</published>
    <updated>2018-10-15T14:27:03.398Z</updated>
    
    <content type="html"><![CDATA[<p>泛型正如其名称暗示的：它是一种方法，通过它可以写出更泛化的代码，这些代码对于它们所操作的类型有更少的限制，因此单个代码段可以应用到更多的类型上，减少重复编码。<br><a id="more"></a></p><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><h5 id="简单泛型"><a href="#简单泛型" class="headerlink" title="简单泛型"></a>简单泛型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public calss Holder&lt;T&gt; &#123;</span><br><span class="line"> private T a;</span><br><span class="line"> public Holder(T a) &#123;</span><br><span class="line">  this.a = a;</span><br><span class="line"> &#125;</span><br><span class="line"> public T get() &#123;</span><br><span class="line">  return a;</span><br><span class="line"> &#125;</span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">  Holder&lt;Automobile&gt; h = </span><br><span class="line">    new Holder&lt;Automobile&gt;(new Automobile);</span><br><span class="line">  Automobile a = h.get();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有了泛型，可以很容易地创建元组，令其返回一组任意类型的对象。通过元组的方式实现返回多个对象的功能  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class TwoTuple&lt;A, B&gt; &#123;</span><br><span class="line">    public final A first;</span><br><span class="line">    public  final B second;</span><br><span class="line"></span><br><span class="line">    public TwoTuple(A a, B b) &#123;</span><br><span class="line">        this.first = a;</span><br><span class="line">        this.second = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;(&quot; + first + &quot;，&quot; + second + &quot;)&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TwoTuple&lt;String, Integer&gt; ttsi = new TwoTuple&lt;&gt;(&quot;hi&quot;, 666);</span><br><span class="line">        System.out.println(ttsi.first);</span><br><span class="line">        System.out.println(ttsi.second);</span><br><span class="line">        System.out.println(ttsi.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">**可以通过继承实现更长的元组：**</span><br></pre></td></tr></table></figure><p>public class ThreeTuple<a, b,="" c=""> extends TwoTuple<a, b=""> {<br>    public final C c;<br>    public ThreeTuple(A a, B b, C c) {<br>        super(a, b);<br>        this.c = c;<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ 泛型实现一个堆栈类  </span><br><span class="line">不使用已有的Stack和LinkedList实现一个堆栈类  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">public class LinkedStack&lt;T&gt; &#123;</span><br><span class="line">    private static class Node&lt;U&gt; &#123;</span><br><span class="line">        U item;</span><br><span class="line">        Node&lt;U&gt; next;</span><br><span class="line">        Node() &#123;</span><br><span class="line">            item = null;</span><br><span class="line">            next = null;</span><br><span class="line">        &#125;</span><br><span class="line">        Node(U item, Node&lt;U&gt; next) &#123;</span><br><span class="line">            this.item = item;</span><br><span class="line">            this.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        boolean end() &#123;</span><br><span class="line">            return item == null &amp;&amp; next == null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Node&lt;T&gt; top = new Node&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void push(T item) &#123;</span><br><span class="line">        top = new Node&lt;&gt;(item, top);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T pop() &#123;</span><br><span class="line">        T result = top.item;</span><br><span class="line">        if (!top.end()) &#123;</span><br><span class="line">            top = top.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></a,></a,></p><h5 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h5><p>泛型也可以应用于接口。如生成器</p><p>接口类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Generator&lt;T&gt; &#123;</span><br><span class="line">    T next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以生成各类咖啡对象为例，这里准备一些Coffee类：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Coffee &#123;</span><br><span class="line">    private static long counter = 0;</span><br><span class="line">    private final long id = counter++;</span><br><span class="line"></span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return getClass().getSimpleName() + &quot; &quot; + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Americano extends Coffee &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Breve extends Coffee &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Cappuccino extends Coffee &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Latte extends Coffee &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Mocha extends Coffee &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写CoffeeGenerator类实现Generator<coffee>接口，随机生成不同类型的Coffee对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class CoffeeGenerator implements Generator&lt;Coffee&gt;, Iterable&lt;Coffee&gt;&#123;</span><br><span class="line"></span><br><span class="line">    private Class[] types = &#123;Latte.class, Mocha.class, Cappuccino.class, Americano.class, Breve.class&#125;;</span><br><span class="line">    private static Random rand = new Random(47);</span><br><span class="line"></span><br><span class="line">    public CoffeeGenerator() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int size = 0;</span><br><span class="line"></span><br><span class="line">    public CoffeeGenerator(int sz) &#123;</span><br><span class="line">        this.size = sz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Iterator&lt;Coffee&gt; iterator() &#123;</span><br><span class="line">        return new CoffeeIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Coffee next() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Coffee)types[rand.nextInt(types.length)].newInstance();</span><br><span class="line">        &#125;  catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class CoffeeIterator implements Iterator&lt;Coffee&gt; &#123;</span><br><span class="line">        int count = size;</span><br><span class="line">        @Override</span><br><span class="line">        public Coffee next() &#123;</span><br><span class="line">            count--;</span><br><span class="line">            return CoffeeGenerator.this.next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void remove() &#123;</span><br><span class="line">            throw new UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean hasNext() &#123;</span><br><span class="line">            return count &gt; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CoffeeGenerator gen = new CoffeeGenerator();</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            System.out.println(gen.next());</span><br><span class="line">        &#125;</span><br><span class="line">        for (Coffee c : new CoffeeGenerator(5)) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></coffee></p><h5 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h5><blockquote><p>泛型方法所在的类可以是泛型类，也可以不是泛型类<br>能用泛型方法，尽量不用泛型类，更清楚明白<br>static方法无法使用泛型类的类型参数，static要使用泛型能力，就必须成为泛型方法  </p></blockquote><p>要定义泛型方法，只需将泛型参数列表置于返回值之前：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class GenericMethods &#123;</span><br><span class="line">    public &lt;T&gt; void f(T x) &#123;</span><br><span class="line">        System.out.println(x.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        GenericMethods gm = new GenericMethods();</span><br><span class="line">        gm.f(&quot;&quot;);</span><br><span class="line">        gm.f(1);</span><br><span class="line">        gm.f(1.0);</span><br><span class="line">        gm.f(1.0f);</span><br><span class="line">        gm.f(&apos;c&apos;);</span><br><span class="line">        gm.f(gm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ 类型参数推断  </span><br><span class="line">当使用泛型类时，必须在创建对象的时候指定类型参数的值，而使用泛型方法的时候，通常不必指明参数类型，因为编译器会为我们找出具体的类型。  </span><br><span class="line"></span><br><span class="line">+ 可变参数与泛型方法  </span><br><span class="line">泛型方法与可变参数列表可以很好的共存  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">public class GenericVarargs &#123;</span><br><span class="line">    public static &lt;T&gt; List&lt;T&gt; makeList(T... args) &#123;</span><br><span class="line">        List&lt;T&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        for (T item : args) &#123;</span><br><span class="line">            result.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; ls = makeList(&quot;A&quot;);</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">        ls = makeList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">        ls = makeList(&quot;ABCDEFGHIJKLMNOPQ&quot;.split(&quot;&quot;));</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="泛型应用到内部类及匿名内部类"><a href="#泛型应用到内部类及匿名内部类" class="headerlink" title="泛型应用到内部类及匿名内部类"></a>泛型应用到内部类及匿名内部类</h5><p>Customer和Teller只有private构造器，必须使用Generator对象。Customer中generator方法，每次生成一个Generator<customer>对象。<br>其实不需要这么多Generator对象，Teller只创建了一个public的generator对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Customer &#123;</span><br><span class="line">    private static long counter = 1;</span><br><span class="line">    private final long id = counter++;</span><br><span class="line">    private Customer() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Customer &quot; + id;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Generator&lt;Customer&gt; generator() &#123;</span><br><span class="line">        return new Generator&lt;Customer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Customer next() &#123;</span><br><span class="line">                return new Customer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Teller &#123;</span><br><span class="line">    private static long counter = 1;</span><br><span class="line">    private final long id = counter++;</span><br><span class="line"></span><br><span class="line">    private Teller() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;teller: &quot; + id;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Generator&lt;Teller&gt; generator =</span><br><span class="line">            new Generator&lt;Teller&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public Teller next() &#123;</span><br><span class="line">                    return new Teller();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BankTeller &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></customer></p><h5 id="擦除的神秘之处"><a href="#擦除的神秘之处" class="headerlink" title="擦除的神秘之处"></a>擦除的神秘之处</h5><p>ArrayList<string>和ArrayList<integer>很容易被认为是不同的类型，其实不然：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">public class ErasedTypeEquivalence &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Class c1 = new ArrayList&lt;String&gt;().getClass();</span><br><span class="line">        Class c2 = new ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">        System.out.println(c1 == c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line">上面运行返回true，下面示例是解答：  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">class Frob &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Fnorkle &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Quark&lt;Q&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Particle&lt;POSITION, MOMENTUM&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class LostInformation &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Frob&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;Frob, Fnorkle&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        Quark&lt;Fnorkle&gt; quark = new Quark&lt;&gt;();</span><br><span class="line">        Particle&lt;Long, Double&gt; p = new Particle&lt;&gt;();</span><br><span class="line">        System.out.println(Arrays.toString(list.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(map.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(quark.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(p.getClass().getTypeParameters()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/* Output</span><br><span class="line">[E]</span><br><span class="line">[K, V]</span><br><span class="line">[Q]</span><br><span class="line">[POSITION, MOMENTUM]</span><br><span class="line">*///:~</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; Class.getTypeParameters()将返回一个TypeVariable对象数组，表示有泛型声明所声明的类型参数。但是从输出可以看出，返回的仅仅的是参数占位符并不是具体的参数类型。  </span><br><span class="line">&gt; Java泛型是使用擦除实现的，但使用泛型时，任何具体的类型信息都被擦除了。因此List&lt;String&gt;和List&lt;Integer&gt;在运行时是相同的类型，因为运行时都被擦除为原生类型即List。</span><br><span class="line"></span><br><span class="line">##### 擦除的补偿  </span><br><span class="line">为了确定参数类型，通过显示的传递类型的Class对象。  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">class Building &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class House extends Building &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class ClassTypeCapture&lt;T&gt; &#123;</span><br><span class="line">    Class&lt;T&gt; kind;</span><br><span class="line"></span><br><span class="line">    public ClassTypeCapture(Class&lt;T&gt; kind) &#123;</span><br><span class="line">        this.kind = kind;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean f(Object arg) &#123;</span><br><span class="line">        return kind.isInstance(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ClassTypeCapture&lt;Building&gt; ctt1 = new ClassTypeCapture&lt;&gt;(Building.class);</span><br><span class="line">        System.out.println(ctt1.f(new Building()));</span><br><span class="line">        System.out.println(ctt1.f(new House()));</span><br><span class="line">        ClassTypeCapture&lt;House&gt; ctt2 = new ClassTypeCapture&lt;&gt;(House.class);</span><br><span class="line">        System.out.println(ctt2.f(new Building()));</span><br><span class="line">        System.out.println(ctt2.f(new House()));</span><br><span class="line">    &#125;</span><br><span class="line">    /*output</span><br><span class="line">    true</span><br><span class="line">    true</span><br><span class="line">    false</span><br><span class="line">    true</span><br><span class="line">     */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></integer></string></p><h5 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h5><p>为了将泛型参数限定为某个类型子集，那么你就可以用这些类型子集来调用方法。为了执行限制，java泛型重用了extends关键字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">interface HasColor &#123;</span><br><span class="line">    Color getColor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Colored&lt;T extends HasColor&gt; &#123;</span><br><span class="line">    T item;</span><br><span class="line"></span><br><span class="line">    Colored(T item) &#123;</span><br><span class="line">        this.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T getItem() &#123;</span><br><span class="line">        return item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Color color() &#123;</span><br><span class="line">        return item.getColor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dimension &#123;</span><br><span class="line">    public int x,y, z;</span><br><span class="line">&#125;</span><br><span class="line">class ColoredDimension&lt;T extends Dimension &amp; HasColor&gt;&#123;</span><br><span class="line">    T item;</span><br><span class="line"></span><br><span class="line">    ColoredDimension(T item) &#123;</span><br><span class="line">        this.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T getItem() &#123;</span><br><span class="line">        return item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Color color() &#123;</span><br><span class="line">        return item.getColor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getX() &#123;</span><br><span class="line">        return item.x;</span><br><span class="line">    &#125;</span><br><span class="line">    int getY() &#123;</span><br><span class="line">        return item.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getZ() &#123;</span><br><span class="line">        return item.z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Weight &#123;</span><br><span class="line">    int weight();</span><br><span class="line">&#125;</span><br><span class="line">class Solid&lt;T extends Dimension &amp; HasColor &amp; Weight&gt;&#123;</span><br><span class="line">    T item;</span><br><span class="line"></span><br><span class="line">    Solid(T item) &#123;</span><br><span class="line">        this.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T getItem() &#123;</span><br><span class="line">        return item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Color color() &#123;</span><br><span class="line">        return item.getColor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getX() &#123;</span><br><span class="line">        return item.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getY() &#123;</span><br><span class="line">        return item.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getZ() &#123;</span><br><span class="line">        return item.z;</span><br><span class="line">    &#125;</span><br><span class="line">    int weight() &#123;</span><br><span class="line">        return item.weight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bounded extends Dimension implements HasColor, Weight &#123;</span><br><span class="line">   public Color getColor() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int weight() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class BasicBounds &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Solid&lt;Bounded&gt; solid = new Solid&lt;&gt;(new Bounded());</span><br><span class="line">        solid.color();</span><br><span class="line">        solid.getY();</span><br><span class="line">        solid.weight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h5><p>如下方式在编译器中是不通过的：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class NonCovariantGenerics &#123;</span><br><span class="line">//    List&lt;Fruit&gt; flist = new ArrayList&lt;Apple&gt;();//编译错误</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通配符为?，例如 <code>List&lt;? extends Fruit&gt;</code> 指具有任何从Fruit继承的类型的列表。但最终需要具体的继承自Fruit的对象数组被该引用所引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class GenericsAndCovariance &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;? extends Fruit&gt; flist = new ArrayList&lt;Apple&gt;(); //一旦向上转型就不能添加任何对象，不过可以将任何继承自Fruit的list对象数组赋值给该数组</span><br><span class="line">        //下面编译出错，不能添加任何对象</span><br><span class="line">//        flist.add(new Apple());</span><br><span class="line">//        flist.add(new Fruit());</span><br><span class="line">//        flist.add(new Object());</span><br><span class="line">//        flist.add(null);//合法但无意义</span><br><span class="line">        Fruit f = flist.get(0);</span><br><span class="line"></span><br><span class="line">        flist.clear();</span><br><span class="line">        List&lt;Apple&gt; appleList = new ArrayList&lt;&gt;();</span><br><span class="line">        appleList.add(new Apple());</span><br><span class="line">        flist = appleList;</span><br><span class="line">        Fruit fruit = flist.get(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>超类型通配符<br>可以声明通配符是由某个特定类的任何基类来界定的，方法是指定 <code>&lt;? super MyClass&gt;</code>，甚至或者使用类型参数：&lt;? super T&gt;，但不能声明 <code>T super MyClass</code>。  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class SuperTypeWildCards &#123;</span><br><span class="line">    static void writeTo(List&lt;? super Apple&gt; apples) &#123;</span><br><span class="line">        apples.add(new Apple());</span><br><span class="line">        apples.add(new Jonathan());</span><br><span class="line">        // apples.add(new Fruit()); // Error</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>无界通配符<br>无界通配符&lt;?&gt;意味着 “任何事物”，因此使用无界通配符好像等价于使用原生类型。事实上，编译器是支持这种判断的。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class UnboundedWildcards1 &#123;</span><br><span class="line">    static List list1;</span><br><span class="line">    static List&lt;?&gt; list2;</span><br><span class="line">    static List&lt;? extends Object&gt; list3;</span><br><span class="line">    static void assign1(List list) &#123;</span><br><span class="line">        list1 = list;</span><br><span class="line">        list2 = list;</span><br><span class="line">        list3 = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void assign2(List&lt;?&gt; list) &#123;</span><br><span class="line">        list1 = list;</span><br><span class="line">        list2 = list;</span><br><span class="line">        list3 = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void assign3(List&lt;? extends Object&gt; list) &#123;</span><br><span class="line">        list1 = list;</span><br><span class="line">        list2 = list;</span><br><span class="line">        list3 = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        assign1(new ArrayList());</span><br><span class="line">        assign2(new ArrayList());</span><br><span class="line">        assign3(new ArrayList());</span><br><span class="line">        assign1(new ArrayList&lt;String&gt;());</span><br><span class="line">        assign2(new ArrayList&lt;String&gt;());</span><br><span class="line">        assign3(new ArrayList&lt;String&gt;());</span><br><span class="line"></span><br><span class="line">        List&lt;?&gt; wildList = new ArrayList();</span><br><span class="line">        wildList = new ArrayList&lt;String&gt;();</span><br><span class="line">        assign1(wildList);</span><br><span class="line">        assign2(wildList);</span><br><span class="line">        assign3(wildList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ul><li>任何基本类型不能用作类型参数，不如不能创建 <code>ArrayList&lt;Integer&gt;</code>  </li><li><p>一个类不能实现同一个泛型接口的两种变体<br>下面的写法会产生冲突：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Payable&lt;T&gt; &#123;&#125;</span><br><span class="line">class Employee implements Payable&lt;Employee&gt; &#123;&#125;</span><br><span class="line">class Hourly extends Employee implements Payable&lt;Hourly&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>转型和警告<br>使用带有泛型类型参数的转型或instanceof不会有任何效果。  </p></li><li>重载<br>由于擦除的原因，重载方法将产生相同的类型签名。  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class UseList&lt;W, T&gt; &#123;</span><br><span class="line">    void f(List&lt;T&gt; v) &#123;&#125;;</span><br><span class="line">    void f(List&lt;W&gt; v) &#123;&#125;;//两种方法签名一样</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自限定的类型<br><code>class SelfBounded&lt;T extends SelfBounded&lt;T&gt;&gt; {</code> SelfBounded类接受泛型参数T，而T由一个边界类限定，这个边界就是拥有T作为其参数的SelfBounded。<br>它强调的是当extends关键字用于边界与用来创建子类明显是不同的。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;泛型正如其名称暗示的：它是一种方法，通过它可以写出更泛化的代码，这些代码对于它们所操作的类型有更少的限制，因此单个代码段可以应用到更多的类型上，减少重复编码。&lt;br&gt;
    
    </summary>
    
    
      <category term="编程思想" scheme="https://dongme.site/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>java编程思想[14]-RTTI</title>
    <link href="https://dongme.site/2018/08/16/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-14/"/>
    <id>https://dongme.site/2018/08/16/java编程思想-14/</id>
    <published>2018-08-16T10:13:00.000Z</published>
    <updated>2018-10-15T14:27:27.232Z</updated>
    
    <content type="html"><![CDATA[<p>RTTI，运行时类型信息。可以使你在程序运行时发现和使用类型信息。<br><a id="more"></a>  </p><h4 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h4><hr><p><strong>RTTI：</strong>Runtime Type Identification，即运行时类型识别。</p><h5 id="class-对象"><a href="#class-对象" class="headerlink" title="class 对象"></a>class 对象</h5><ul><li>class对象就是用来创建类的所有常规对象的，每个类都有一个class对象。换言之，每当编写并且编译了一个新类，就会产生一个class对象  </li><li>类中static成员初始化，是在类加载时进行的，<code>Class.forName(&quot; 类名 &quot;)</code>根据类名获取类对象，需要try块  </li><li>在知道具体的类型的对象时，获取类对象通过 <code>getClass()</code>方法  </li><li>类字面常量：java提供的另一种方法来生产class对象的引用。类似：<code>FancyToy.class</code>，该方式编译时受到检查，更简单，更安全  </li><li>类字面变量不仅可以应用于普通类，也可以应用于接口、数组以及基本数据类型  </li><li><p>使用 <code>.class</code>来创建class对象引用时，不会自动地初始化该Class对象，为使用类需做如下准备：  </p><ol><li>加载，由类加载器执行的。查找字节码（.class文件），并从字节码中创建一个Class对象</li><li>链接，该阶段将验证类中字节码，为静态域分配存储空间，如果必需的话，将解析这个类创建的对其它类的所有引用</li><li>初始化，若该类具有超类，则对其初始化，执行静态初始化器和静态初始化块。首次引用静态方法（构造器隐式静态）或非常数静态域才执行初始化。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Initable</span> </span>&#123;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> staticFianl = <span class="number">47</span>;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> staticFinal2 = ClassInitialzation.rand.nextInt(<span class="number">1000</span>);</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">static</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">"Initializing Initable"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Initable2</span> </span>&#123;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">int</span> staticNoFinal = <span class="number">147</span>;</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">static</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">"Initializing Initable2"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Initable3</span> </span>&#123;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">int</span> staticNoFinal = <span class="number">74</span>;</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">static</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">"Initializing Initable3"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInitialzation</span> </span>&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">   </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">           Class initable = Initable.class;</span><br><span class="line">           System.out.println(<span class="string">"After creating Initable ref"</span>);</span><br><span class="line">           <span class="comment">//不触发初始化</span></span><br><span class="line">           System.out.println(Initable.staticFianl);</span><br><span class="line">           <span class="comment">//触发初始化</span></span><br><span class="line">           System.out.println(Initable.staticFinal2);</span><br><span class="line">           <span class="comment">//触发初始化</span></span><br><span class="line">           System.out.println(Initable2.staticNoFinal);</span><br><span class="line">           <span class="comment">//触发初始化</span></span><br><span class="line">           Class initable3 = Class.forName(<span class="string">"me.donge.factorypackage.Initable3"</span>);</span><br><span class="line">           System.out.println(<span class="string">"Afer creating Initable3 ref"</span>);</span><br><span class="line">           <span class="comment">//已经被初始化过的 不会再次触发初始化</span></span><br><span class="line">           System.out.println(Initable3.staticNoFinal);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  ```  </span><br><span class="line">+ 泛化的Class引用  </span><br><span class="line">  <span class="number">1</span>. 使用泛化的Class引用时放松限制，使用通配符，<span class="string">"?"</span>表示任何事物</span><br></pre></td></tr></table></figure><p>Class&lt;?&gt; intClass = int.class;<br>intClass = double.class;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. `newInstance()`方法可以创建某个类类型的实例对象</span><br></pre></td></tr></table></figure><p>Class<integer> intClass = int.class;<br>int a = intClass.newInstance();</integer></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">3. 类型转换前先做检查  </span><br><span class="line">**3.1 RTTI形式：**  </span><br><span class="line">3.1.1 传统的类型转换，即强制类型转换，如果执行了一个错误的类型转换，就会抛出一个ClassCastException异常。  </span><br><span class="line">3.1.2 代表对象的类型的Class对象。通过查询Class对象可以获取运行时所需的信息。  </span><br><span class="line">3.1.3 instanceof关键字，如判断x对象实例变量是否属于类Apple的实例，使用 `x instanceof Apple` 返回true or false，该方式不推荐使用，</span><br><span class="line">该方式只可将其与命名类进行比较，而不能与Class对象作比较。  </span><br><span class="line">但是 instanceof 在 java 的编译状态和运行状态是有区别的：  </span><br><span class="line">在编译状态中 class 可以是 object 对象的父类、自身类、子类，在这三种情况下 java 编译时不会报错；    </span><br><span class="line">在运行转态中 class 可以是 object 对象的父类、自身类，但不能是子类，当为父类、自身类的情况下 result 结果为 true，为子类的情况下为 false。  </span><br><span class="line">3.1.4 动态的instanceof  </span><br><span class="line">Class.isInstance方法提供了一种动态地测试对象的方法，可替换单调的instanceof语句。语法：`class.isInstance(obj)`，表明这个对象能不能</span><br><span class="line">被转化为这个类  </span><br><span class="line">**3.2 反射：运行时的类信息 **  </span><br><span class="line">RTTI和反射的区别在于，对RTTI来说，编译器在编译时打开和检查.class文件（可以用普通方式调用对象所有方法）；对于反射机制来说，.class文件在</span><br><span class="line">编译时是不可获取的，所以是在运行时打开和检查.class文件。  </span><br><span class="line">3.2.1 类方法提取器  </span><br><span class="line">3.2.1.1 提取类方法包括基类的方法</span><br></pre></td></tr></table></figure><p>Class&lt;?&gt; c = Class.forName(args[0]);<br>Method[] methods = c.getMethods();<br>Constructor[] ctors = c.getConstructors();</p><pre><code>3.2.1.2 动态代理  不直接操作实际对象，而是通过代理对象简介操作实际对象，充当着中间人的角色。</code></pre><p>interface Interface {</p><pre><code>void doSomething();void somethingElse(String arg);</code></pre><p>}</p><p>class RealObject implements Interface {</p><pre><code>@Overridepublic void doSomething() {    System.out.println(&quot;doSomething&quot;);}@Overridepublic void somethingElse(String arg) {    System.out.println(&quot;somethingElse &quot; + arg);}</code></pre><p>}</p><p>class SimpleProxy implements Interface {</p><pre><code>private Interface proxied;public SimpleProxy(Interface proxied) {    this.proxied = proxied;}@Overridepublic void doSomething() {    System.out.println(&quot;SimpleProxy doSomething&quot;);    proxied.doSomething();}@Overridepublic void somethingElse(String arg) {    System.out.println(&quot;SimpleProxy somethingElse &quot; + arg);    proxied.somethingElse(arg);}</code></pre><p>}</p><p>class SimpleProxyDemo {</p><pre><code>public static void consumer(Interface iface) {    iface.doSomething();    iface.somethingElse(&quot;bonobo&quot;);}public static void main(String[] args) {    consumer(new RealObject());    consumer(new SimpleProxy(new RealObject()));}</code></pre><p>}<br>```  </p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RTTI，运行时类型信息。可以使你在程序运行时发现和使用类型信息。&lt;br&gt;
    
    </summary>
    
    
      <category term="编程思想" scheme="https://dongme.site/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>java编程思想[10-13]-内部类、持有对象、异常</title>
    <link href="https://dongme.site/2018/08/16/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-10-13/"/>
    <id>https://dongme.site/2018/08/16/java编程思想-10-13/</id>
    <published>2018-08-16T09:52:00.000Z</published>
    <updated>2018-10-15T14:30:55.212Z</updated>
    
    <content type="html"><![CDATA[<p>继续看java编程思想，这篇主要记录了书中第十章：内部类、第十一章：持有对象、第十二章：通过异常处理错误中的碎片知识。<br><a id="more"></a>  </p><h4 id="1-内部类"><a href="#1-内部类" class="headerlink" title="1.内部类"></a>1.内部类</h4><ul><li>内部类拥有对外部类所有元素的访问权限</li><li>利用内部类实现迭代器模式  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Selector</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">current</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sequence</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        items = <span class="keyword">new</span> Object[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.items[next++] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceSelector</span> <span class="keyword">implements</span> <span class="title">Selector</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i == items.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">current</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> items[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; items.length) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Selector <span class="title">selector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SequenceSelector();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Sequence sequence = <span class="keyword">new</span> Sequence(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            sequence.add(Integer.toString(i));</span><br><span class="line">        &#125;</span><br><span class="line">        Selector selector = sequence.selector();</span><br><span class="line">        <span class="keyword">while</span> (!selector.end()) &#123;</span><br><span class="line">            System.out.println(selector.current() + <span class="string">" "</span>);</span><br><span class="line">            selector.next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>内外类互调，假如Outer为外部类，Inner为内部类<br><strong>内部类调用外部类:</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Outer outer = Outer.this;</span><br></pre></td></tr></table></figure><p> <strong>外部类调用内部类</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">外部类调用:</span><br><span class="line">Inner inner = new Inner();</span><br><span class="line"></span><br><span class="line">其它类调用:</span><br><span class="line">Outer.Inner inner = new Outer.Inner();//内部类为static才可以这样创建</span><br><span class="line">或</span><br><span class="line">Outer outer = new Outer();//通用</span><br><span class="line">Outer.Inner inner = outer.new Inner();</span><br></pre></td></tr></table></figure></p><ul><li>在方法和作用域内的内部类  <blockquote><p>作用:实现了某类型的接口，于是可以创建并返回对其的引用；需要解决一个复杂问题，想创建一个辅助类解决，又不想该类暴露出去；内部类使多重继承更加丰富。</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> public interface Destination &#123;</span><br><span class="line">    String readLabel();</span><br><span class="line">&#125;</span><br><span class="line">public interface Contents &#123;</span><br><span class="line">    int value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1) 一个定义在方法中的类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Parcel5 &#123;</span><br><span class="line">    public Destination destination(String s) &#123;</span><br><span class="line">        class PDestination implements Destination &#123;</span><br><span class="line">            private String label;</span><br><span class="line"></span><br><span class="line">            private PDestination(String whereTo) &#123;</span><br><span class="line">                label = whereTo;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public String readLabel() &#123;</span><br><span class="line">                return label;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new PDestination(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Parcel5 parcel5 = new Parcel5();</span><br><span class="line">        Destination destination = parcel5.destination(&quot;alvin&quot;);</span><br><span class="line">        System.out.println(destination.readLabel());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 2) 一个定义在作用域内的类，此作用域在方法的内部</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> public class Parcel6 &#123;</span><br><span class="line">    private void internalTracking(boolean b) &#123;</span><br><span class="line">        if (b) &#123;</span><br><span class="line">            class TrackingSlip &#123;</span><br><span class="line">                private String id;</span><br><span class="line"></span><br><span class="line">                TrackingSlip(String s) &#123;</span><br><span class="line">                    id = s;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                String getSlip() &#123;</span><br><span class="line">                    return id;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            TrackingSlip ts = new TrackingSlip(&quot;slip&quot;);</span><br><span class="line">            String s = ts.getSlip();</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void track() &#123;</span><br><span class="line">        internalTracking(true);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Parcel6 parcel6 = new Parcel6();</span><br><span class="line">        parcel6.track();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 3) 实现了接口的匿名类<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> public class Parcel7 &#123;</span><br><span class="line">    public Contents contents() &#123;</span><br><span class="line">        return new Contents() &#123;</span><br><span class="line">            private int i = 11;</span><br><span class="line"></span><br><span class="line">            public int value() &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Parcel7 parcel7 = new Parcel7();</span><br><span class="line">        Contents contents = parcel7.contents();</span><br><span class="line">        System.out.println(contents.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 等价于</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Parcel7b &#123;</span><br><span class="line">    class MyContents implements Contents &#123;</span><br><span class="line">        private int i = 11;</span><br><span class="line"></span><br><span class="line">        public int value() &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public Contents contents() &#123;</span><br><span class="line">        return new MyContents();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Parcel7b parcel7b = new Parcel7b();</span><br><span class="line">        Contents contents = parcel7b.contents();</span><br><span class="line">        System.out.println(contents.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 4) 一个匿名类，它扩展了具有非默认构造器的类<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> public class Parcel8 &#123;</span><br><span class="line">    public Wrapping wrapping(int x) &#123;</span><br><span class="line">        return new Wrapping(x) &#123;</span><br><span class="line">            public int value() &#123;</span><br><span class="line">                return super.value() * 47;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Parcel8 parcel8 = new Parcel8();</span><br><span class="line">        Wrapping wrapping = parcel8.wrapping(10);</span><br><span class="line">        System.out.println(wrapping.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 尽管Wrapping只是一个具有具体实现的普通类，但它还是被其导出类当做”公共接口”使用:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> public class Wrapping &#123;</span><br><span class="line">    private int i;</span><br><span class="line">    public Wrapping(int x) &#123;</span><br><span class="line">        i = x;</span><br><span class="line">    &#125;</span><br><span class="line">    public int value() &#123;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 5）一个匿名类，它执行字段初始化<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> public class Parcel9 &#123;</span><br><span class="line">    public Destination destination(final String dest) &#123;</span><br><span class="line">        return new Destination() &#123;</span><br><span class="line">            private String label = dest;</span><br><span class="line">            @Override</span><br><span class="line">            public String readLabel() &#123;</span><br><span class="line">                return dest;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Parcel9 parcel9 = new Parcel9();</span><br><span class="line">        Destination destination = parcel9.destination(&quot;alvin&quot;);</span><br><span class="line">        System.out.println(destination.readLabel());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>内部类使用外部对象作为参数，要将参数声明为final类型，否则编译报错。注意必须内部类内部使用到才必须声明为final。</p></blockquote><p> 6）一个匿名类，它通过实例初始化实现构造(匿名类不可能有匿名构造器)<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">abstract class Base &#123;</span><br><span class="line">    public Base(int i) &#123;</span><br><span class="line">        System.out.println(&quot;Base Constructor. i=&quot; + i);</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract void f();</span><br><span class="line">&#125;</span><br><span class="line">public class AnonymousConstructor &#123;</span><br><span class="line">    public static Base getBase(int i) &#123;</span><br><span class="line">        return new Base(i) &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(&quot;Inside instance initializer&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            public void f() &#123;</span><br><span class="line">                System.out.println(&quot;In anonymous f()&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Base base = getBase(47);</span><br><span class="line">        base.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>匿名内部类实现工厂方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"> interface Service &#123;</span><br><span class="line">    void method1();</span><br><span class="line"></span><br><span class="line">    void method2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface ServiceFactory &#123;</span><br><span class="line">    Service getService();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Implementation1 implements Service &#123;</span><br><span class="line">    public void method1() &#123;</span><br><span class="line">        System.out.println(&quot;Implementation1 method1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void method2() &#123;</span><br><span class="line">        System.out.println(&quot;Implementation1 method2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static ServiceFactory factory = new ServiceFactory() &#123;</span><br><span class="line">        public Service getService() &#123;</span><br><span class="line">            return new Implementation1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">class Implementation2 implements Service &#123;</span><br><span class="line">    public void method1() &#123;</span><br><span class="line">        System.out.println(&quot;Implementation2 method1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void method2() &#123;</span><br><span class="line">        System.out.println(&quot;Implementation2 method2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static ServiceFactory factory = new ServiceFactory() &#123;</span><br><span class="line">        public Service getService() &#123;</span><br><span class="line">            return new Implementation2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">public class Factories &#123;</span><br><span class="line">    public static void serviceConsumer(ServiceFactory factory) &#123;</span><br><span class="line">        Service s = factory.getService();</span><br><span class="line">        s.method1();</span><br><span class="line">        s.method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        serviceConsumer(Implementation1.factory);</span><br><span class="line">        serviceConsumer(Implementation2.factory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>嵌套类</li></ul><blockquote><p>如果不需要内部类对象与其外围类对象之间有联系，那么可以将内部类声明为static.即为嵌套类<br>普通的内部类对象隐式地保存了一个引用，指向创建它的外围类对象。然而，当内部类是static时，就不是这样了。</p></blockquote><p>嵌套类意味着:<br>1) 要创建嵌套类的对象，并不需要其外围类的对象。<br>2）不能从嵌套类的对象中访问非静态的外围类对象。<br>3）普通的内部类不能有static数据和static字段，也不能包含嵌套类。但嵌套类可以。</p><p><strong>接口中的内部类</strong><br>放到接口中的任何类都是public和static的。嵌套类可以作为接口的一部分。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public interface ClassInInterface &#123;</span><br><span class="line">    void howdy();</span><br><span class="line"></span><br><span class="line">    class Test implements ClassInInterface &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void howdy() &#123;</span><br><span class="line">            System.out.println(&quot;howdy&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">            new Test().howdy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接口中的内部类，可以被所有实现共用。</p><ul><li>内部类存是多态性的体现，变向的实现了多重继承，外部类的继承或实现对内部类没有影响</li><li><p>闭包和回调<br><strong>闭包</strong><br>是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。内部类属于面向对象的闭包（隐式外部类对象引用）<br><strong>内部类闭包实现回调</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Callee1</span> <span class="keyword">implements</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIncrement</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"other operation"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(MyIncrement mi)</span> </span>&#123;</span><br><span class="line">        mi.increment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Callee2</span> <span class="keyword">extends</span> <span class="title">MyIncrement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.increment();</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure</span> <span class="keyword">implements</span> <span class="title">Incrementable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Callee2.<span class="keyword">this</span>.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Incrementable <span class="title">getCallbackReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Closure();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Caller</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Incrementable callbackReference;</span><br><span class="line"></span><br><span class="line">    Caller(Incrementable cbh) &#123;</span><br><span class="line">        callbackReference = cbh;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        callbackReference.increment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Callbacks</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Callee1 c1 = <span class="keyword">new</span> Callee1();</span><br><span class="line">        Callee2 c2 = <span class="keyword">new</span> Callee2();</span><br><span class="line">        MyIncrement.f(c2);</span><br><span class="line">        Caller caller1 = <span class="keyword">new</span> Caller(c1);</span><br><span class="line">        Caller caller2 = <span class="keyword">new</span> Caller(c2.getCallbackReference());</span><br><span class="line">        caller1.go();</span><br><span class="line">        caller1.go();</span><br><span class="line">        caller2.go();</span><br><span class="line">        caller2.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>内部类与控制框架</p></li></ul><p><strong>应用程序框架:</strong></p><blockquote><p>就是被设计用以解决某类特定问题的一个类或一组类。<br>要运用某个应用框架，通常是继承一个或多个类，并覆盖某些方法。在覆盖后的方法中，编写代码定制应用程序框架提供的通用解决方案，以解决特定问题—设计模式中模板方法的例子</p></blockquote><p><strong>控制框架:</strong></p><blockquote><p>一类特殊的应用程序框架，用来解决响应事件的需求。主要用来响应事件的系统被称作事件驱动系统。实例:java swing</p></blockquote><p><strong>内部类使用控制框架</strong></p><ul><li><p>内部类的继承<br>因为内部类的构造器必须连接到指向其外围类对象引用，所以在继承内部类的时候要有一些特殊处理。在导出类中不存在可连接的默认对象，而指向外围类对象的隐秘引用必须被初始化。具体处理继承类构造器中添加<br><code>enclosingClassReference.super()</code> enclosingClassReference是外围类对象如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithInner</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritInner</span> <span class="keyword">extends</span> <span class="title">WithInner</span>.<span class="title">Inner</span></span>&#123;</span><br><span class="line">    InheritInner(WithInner wi)&#123;</span><br><span class="line">        wi.<span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WithInner wi = <span class="keyword">new</span> WithInner();</span><br><span class="line">        InheritInner ii = <span class="keyword">new</span> InheritInner(wi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>内部类的覆盖并无卵用</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Egg</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Yolk y;</span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Egg.Yolk()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Egg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"New Egg()"</span>);</span><br><span class="line">        <span class="keyword">this</span>.y = <span class="keyword">new</span> Yolk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigEgg</span> <span class="keyword">extends</span> <span class="title">Egg</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"BigEgg.Yolk()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> BigEgg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出当继承了某个外围类的时候，内部类并没有发生什么变化。这两个内部类是完全独立的实体，各自在自己的命名空间里。</p><ul><li>局部内部类<br>局部内部类不能有访问修饰符，因为它不是外围类的一部分；但是它可以访问当前代码块内的常量，以及此外围类的所有成员。<br>下面对局部内部类和匿名内部类做比较:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalnnerClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function">Counter <span class="title">getCounter</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">LocalCounter</span> <span class="keyword">implements</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">LocalCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"LocalCounter()"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(name);</span><br><span class="line">                <span class="keyword">return</span> count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LocalCounter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Counter <span class="title">getCounter2</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Counter() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">"Counter()"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> count ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalnnerClass lic = <span class="keyword">new</span> LocalnnerClass();</span><br><span class="line">        Counter</span><br><span class="line">                c1 = lic.getCounter(<span class="string">"Local inner"</span>),</span><br><span class="line">                c2 = lic.getCounter2(<span class="string">"Anonymous inner"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(c1.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(c2.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>使用局部内部类而不使用匿名类的理由如下:<br>1）需要构造器，或需要重载构造器<br>2）需要不止一个该内部类对象</p><ul><li><p>内部类标示符<br><code>外围类的名字 + &quot;$&quot; + 内部类名字 + &quot;.class&quot;</code></p><h4 id="2-持有对象"><a href="#2-持有对象" class="headerlink" title="2.持有对象"></a>2.持有对象</h4></li><li><p>使用 <code>@SuppressWarnings(unchecked)</code>注解及其参数来抑制”不受检查的异常”的警告信息</p></li><li>容器使用泛型可以在编译期防止将错误的类型对象放入到容器中</li><li>Arrays.asList()可接受数组或逗号分隔的元素列表，转换为List对象</li><li>Collection.addAll()方法接受一个Collection对象，以及一个数组或逗号分隔的列表</li><li>Collection的构造器可以接受另一个Collection，用来将自身初始化，`Collection<integer> cellection = new ArrayList<integer>(Arrays.asList(1,2,3,4,5))，但Collection.addAll()速度快是首选;</integer></integer></li><li><p>List<br>1）基本的ArrayList，它长于随机访问元素，但在List中间插入和移除元素时较慢<br>2）LinkedList，执行插入和删除的速度比较快，提供优化的顺序访问，随机访问方面比较慢  </p><p><strong>subList:</strong> 从较大列表截取片断列表，对所返回的列表的修改会反映到初始列表中，反之亦然。<br><strong>retainAll():</strong> 是一种有效的交际操作，所产生的行为依赖于equals方法<br><strong>removeAll():</strong> 也是基于equals方法，移除List中所有元素<br><strong>set():</strong> 替换制定索引处的元素<br><strong>toArray():</strong> 可以将List或其他Collection转换为数组  </p></li><li><p>迭代器<br><strong>Iterator</strong></p><p>利用了迭代器设计模式，这个Iterator只能单向移动，如下操作:<br>1）使用方法iterator()要求容器返回一个Iterator。Iterator将准备好返回序列中的第一个元素<br>2）使用next()获取序列中的下一个元素<br>3）使用hasNext()检查序列中是否还有元素<br>4）使用remove将迭代器新近返回的元素删除<br>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleIteration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">int</span> in = iterator.next();</span><br><span class="line">            System.out.println(in);</span><br><span class="line">        &#125;</span><br><span class="line">        iterator = list.iterator();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">            iterator.remove();<span class="comment">//移除由next()产生的最后一个元素，调用romove()之前必须先调用next()</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>注意:这里有个坑这里用<code>new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3, 4, 5, 6));</code> 如果直接用<code>Arrays.asList(1, 2, 3, 4, 5, 6)</code>会报java.lang.UnsupportedOperationException的错误，原因是@return a list view of the specified array意思是<br>返回一个固定大小的数组。自然不支持add和remove操作。</p><p><strong>ListIterator</strong><br>ListIterator是一个更加强大的iterator的子类型，它只能用于各种List访问；可以双向移动；可以产生迭代器在列表中指向的当前位置的前一个和后一个元素的索引，并且可以使用set()方法替换它访问过的最后一个元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListIteration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line">        ListIterator&lt;Integer&gt; listIterator = list.listIterator();</span><br><span class="line">        <span class="keyword">while</span> (listIterator.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">int</span> in = listIterator.next();</span><br><span class="line">            System.out.println(in + <span class="string">","</span> + listIterator.nextIndex() + <span class="string">","</span> + listIterator.previousIndex());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// backwards</span></span><br><span class="line">        <span class="keyword">while</span> (listIterator.hasPrevious()) &#123;</span><br><span class="line">            System.out.println(listIterator.previous());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        listIterator = list.listIterator(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">while</span> (listIterator.hasNext()) &#123;</span><br><span class="line">            listIterator.next();</span><br><span class="line">            listIterator.set(<span class="keyword">new</span> Random().nextInt());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>LinkedList<br>LinkedList实现了List接口，但是它执行某些插入和删除操作的时候比ArrayList要高效，在随机访问方面要逊色一些；LinkedList添加了可以用作栈、队列或双端队列的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListFeatures</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        System.out.println(<span class="string">"list.getFirst():"</span> + list.getFirst());<span class="comment">//返回列表第一个元素,列表为空抛出异常</span></span><br><span class="line">        System.out.println(<span class="string">"list.element():"</span> + list.element());<span class="comment">//功能和getFirst()相同，返回列表第一个元素,列表为空抛出异常</span></span><br><span class="line">        System.out.println(<span class="string">"list.peek():"</span> + list.peek());<span class="comment">//返回列表第一个元素，与上面两个区别是列表为空返回null</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"list.remove():"</span> + list.remove()); <span class="comment">//删除并返回列表头，列表为空抛异常</span></span><br><span class="line">        System.out.println(<span class="string">"list.removeFirst():"</span> + list.removeFirst());<span class="comment">//功能通remove()，删除并返回列表头，列表为空抛异常</span></span><br><span class="line">        System.out.println(<span class="string">"list.poll():"</span> + list.poll());<span class="comment">//删除并返回列表头，与remove() 和 removeFirst()区别列表为空返回null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//addFirst() 在头部添加元素</span></span><br><span class="line">        <span class="comment">//offer() 和 add() 和 addLast()相同，它们都将某个元素插入到列表的尾部</span></span><br><span class="line">        <span class="comment">//removeLast() 删除并返回队尾的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Stack</p></li></ul><p>后进先出<br><strong>LinkedList实现的栈:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;T&gt; storage = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T v)</span> </span>&#123;</span><br><span class="line">        storage.addFirst(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> storage.getFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> storage.removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> storage.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> storage.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>原始的栈:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an empty Stack.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pushes an item onto the top of this stack. This has exactly</span></span><br><span class="line"><span class="comment">     * the same effect as:</span></span><br><span class="line"><span class="comment">     * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">     * addElement(item)&lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   item   the item to be pushed onto this stack.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  the &lt;code&gt;item&lt;/code&gt; argument.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.util.Vector#addElement</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">push</span><span class="params">(E item)</span> </span>&#123;</span><br><span class="line">        addElement(item);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the object at the top of this stack and returns that</span></span><br><span class="line"><span class="comment">     * object as the value of this function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  The object at the top of this stack (the last item</span></span><br><span class="line"><span class="comment">     *          of the &lt;tt&gt;Vector&lt;/tt&gt; object).</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  EmptyStackException  if this stack is empty.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        E       obj;</span><br><span class="line">        <span class="keyword">int</span>     len = size();</span><br><span class="line"></span><br><span class="line">        obj = peek();</span><br><span class="line">        removeElementAt(len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Looks at the object at the top of this stack without removing it</span></span><br><span class="line"><span class="comment">     * from the stack.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  the object at the top of this stack (the last item</span></span><br><span class="line"><span class="comment">     *          of the &lt;tt&gt;Vector&lt;/tt&gt; object).</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  EmptyStackException  if this stack is empty.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>     len = size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        <span class="keyword">return</span> elementAt(len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tests if this stack is empty.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  &lt;code&gt;true&lt;/code&gt; if and only if this stack contains</span></span><br><span class="line"><span class="comment">     *          no items; &lt;code&gt;false&lt;/code&gt; otherwise.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the 1-based position where an object is on this stack.</span></span><br><span class="line"><span class="comment">     * If the object &lt;tt&gt;o&lt;/tt&gt; occurs as an item in this stack, this</span></span><br><span class="line"><span class="comment">     * method returns the distance from the top of the stack of the</span></span><br><span class="line"><span class="comment">     * occurrence nearest the top of the stack; the topmost item on the</span></span><br><span class="line"><span class="comment">     * stack is considered to be at distance &lt;tt&gt;1&lt;/tt&gt;. The &lt;tt&gt;equals&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * method is used to compare &lt;tt&gt;o&lt;/tt&gt; to the</span></span><br><span class="line"><span class="comment">     * items in this stack.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   o   the desired object.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  the 1-based position from the top of the stack where</span></span><br><span class="line"><span class="comment">     *          the object is located; the return value &lt;code&gt;-1&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     *          indicates that the object is not on the stack.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = lastIndexOf(o);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> size() - i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** use serialVersionUID from JDK 1.0.2 for interoperability */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1224463164541339165L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>可以看出原始的栈是线程安全的</p></blockquote><ul><li>Set</li></ul><blockquote><p>Set是接口，不保存重复元素，通常选择一个HashSet的实现，它对快速查找进行了优化，发现jdk8版本HashSet可以实现自动排序</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetOfInteger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        Set&lt;Integer&gt; intset = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            intset.add(rand.nextInt(<span class="number">30</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(intset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>HashSet使用的是散列函数，没有顺序。LinkedHashSet因为查询速度的原因也使用了散列，但是它使用了链表来维护元素插入顺序。TreeSet将元素存储在红黑数据结构中</p></blockquote><p><strong>使用TreeSet代替HashSet实现对结果排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortedSetOfInteger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        SortedSet&lt;Integer&gt; intset = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            intset.add(rand.nextInt(<span class="number">30</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(intset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>TreeSet<br>set的contains()和containsAll()，前者是是否包含元素，后者是是否包含集合</p></blockquote><p>TreeSet主要构造方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//默认构造方法，根据其元素的自然顺序进行排序</span><br><span class="line">public TreeSet() &#123;</span><br><span class="line">    this(new TreeMap&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br><span class="line">//构造一个新的空 TreeSet，它根据指定比较器进行排序。</span><br><span class="line">public TreeSet(Comparator&lt;? super E&gt; comparator) &#123;</span><br><span class="line">        this(new TreeMap&lt;&gt;(comparator));</span><br><span class="line">&#125;</span><br><span class="line">//构造一个包含指定 collection 元素的新 TreeSet，它按照其元素的自然顺序进行排序。</span><br><span class="line">public TreeSet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    this();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line">//构造一个与指定有序 set 具有相同映射关系和相同排序的新 TreeSet。</span><br><span class="line">public TreeSet(SortedSet&lt;E&gt; s) &#123;</span><br><span class="line">    this(s.comparator());</span><br><span class="line">    addAll(s);</span><br><span class="line">&#125;</span><br><span class="line">TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;</span><br><span class="line">    this.m = m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>notice:Comparable和Comparator比较:<br>1) 若一个类实现了Comparable接口，就意味着”该类支持排序”。  即然实现Comparable接口的类支持排序，假设现在存在”实现Comparable接口的类的对象的List列表(或数组)”，则该List列表(或数组)可以通过 Collections.sort（或 Arrays.sort）进行排序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假设我们通过 x.compareTo(y) 来“比较x和y的大小”。若返回“负数”，意味着“x比y小”；返回“零”，意味着“x等于y”；返回“正数”，意味着“x大于y”。<br>2）我们若需要控制某个类的次序，而该类本身不支持排序(即没有实现Comparable接口)；那么，我们可以建立一个“该类的比较器”来进行排序。这个“比较器”只需要实现Comparator接口即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>int compare(T o1, T o2) 是“比较o1和o2的大小”。返回“负数”，意味着“o1比o2小”；返回“零”，意味着“o1等于o2”；返回“正数”，意味着“o1大于o2”。</p><p>TreeSet主要方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1、add：将指定的元素添加到此 set（如果该元素尚未存在于 set 中）。</span><br><span class="line">2、addAll：将指定 collection 中的所有元素添加到此 set 中。</span><br><span class="line">3、ceiling：返回此 set 中大于等于给定元素的最小元素；如果不存在这样的元素，则返回 null。</span><br><span class="line">4、clear：移除此 set 中的所有元素。</span><br><span class="line">5、clone：返回 TreeSet 实例的浅表副本。属于浅拷贝。</span><br><span class="line">6、comparator：返回对此 set 中的元素进行排序的比较器；如果此 set 使用其元素的自然顺序，则返回 null。</span><br><span class="line">7、contains：如果此 set 包含指定的元素，则返回 true。</span><br><span class="line">8、descendingIterator：返回在此 set 元素上按降序进行迭代的迭代器。</span><br><span class="line">9、descendingSet：返回此 set 中所包含元素的逆序视图。</span><br><span class="line">10、first：返回此 set 中当前第一个（最低）元素。</span><br><span class="line">11、floor：返回此 set 中小于等于给定元素的最大元素；如果不存在这样的元素，则返回 null。</span><br><span class="line">12、headSet：返回此 set 的部分视图，其元素严格小于 toElement。</span><br><span class="line">13、higher：返回此 set 中严格大于给定元素的最小元素；如果不存在这样的元素，则返回 null。</span><br><span class="line">14、isEmpty：如果此 set 不包含任何元素，则返回 true。</span><br><span class="line">15、iterator：返回在此 set 中的元素上按升序进行迭代的迭代器。</span><br><span class="line">16、last：返回此 set 中当前最后一个（最高）元素。</span><br><span class="line">17、lower：返回此 set 中严格小于给定元素的最大元素；如果不存在这样的元素，则返回 null。</span><br><span class="line">18、pollFirst：获取并移除第一个（最低）元素；如果此 set 为空，则返回 null。</span><br><span class="line">19、pollLast：获取并移除最后一个（最高）元素；如果此 set 为空，则返回 null。</span><br><span class="line">20、remove：将指定的元素从 set 中移除（如果该元素存在于此 set 中）。</span><br><span class="line">21、size：返回 set 中的元素数（set 的容量）。</span><br><span class="line">22、subSet：返回此 set 的部分视图</span><br><span class="line">23、tailSet：返回此 set 的部分视图</span><br></pre></td></tr></table></figure></p><ul><li>Map</li></ul><blockquote><p>Map通过keySet()可以返回它的键的Set，通过keyValues()它的值的Collection，或者它的键值对的Set。</p></blockquote><ul><li>Queue</li></ul><blockquote><p>队列是先进先出的容器。在并发编程中特别重要。</p></blockquote><p><strong>LinkedList实现的Queue:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printQ</span><span class="params">(Queue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.peek() != <span class="keyword">null</span>) &#123;<span class="comment">//判断队头元素是否为空</span></span><br><span class="line">            System.out.print(queue.remove() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"============================"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Random random = <span class="keyword">new</span> Random(<span class="number">37</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> randNum = random.nextInt(i + <span class="number">10</span>);</span><br><span class="line">            System.out.println(randNum);</span><br><span class="line">            queue.offer(randNum);<span class="comment">//加入队尾</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(queue);</span><br><span class="line">        Queue&lt;Character&gt; qc = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : <span class="string">"Brontosaurus"</span>.toCharArray()) &#123;</span><br><span class="line">            qc.offer(c);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(qc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>PriorityQueue优先级队列:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            priorityQueue.offer(rand.nextInt(i + <span class="number">20</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        QueueDemo.printQ(priorityQueue);<span class="comment">// 允许重复，最小值有最高优先级放队头</span></span><br><span class="line">        List&lt;Integer&gt; ints = Arrays.asList(<span class="number">25</span>, <span class="number">22</span>, <span class="number">18</span>, <span class="number">14</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">14</span>, <span class="number">18</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">25</span>);</span><br><span class="line">        priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(ints);</span><br><span class="line">        QueueDemo.printQ(priorityQueue);</span><br><span class="line">        priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(ints.size(), Collections.reverseOrder());<span class="comment">// Collections.reverseOrder() 为自带比较器，产生反序，可自定义实现</span></span><br><span class="line">        priorityQueue.addAll(ints);</span><br><span class="line">        QueueDemo.printQ(priorityQueue);</span><br><span class="line">        String fact = <span class="string">"EDUCcATION SHOULD ESCHEW OBFUSCATION"</span>;</span><br><span class="line">        List&lt;String&gt; strings = Arrays.asList(fact.split(<span class="string">""</span>));</span><br><span class="line">        PriorityQueue&lt;String&gt; stringPQ = <span class="keyword">new</span> PriorityQueue&lt;&gt;(strings);</span><br><span class="line">        QueueDemo.printQ(stringPQ);<span class="comment">//String类型，按照字母对应ascii从小到大，从队头到队尾</span></span><br><span class="line">        stringPQ = <span class="keyword">new</span> PriorityQueue&lt;&gt;(strings.size(), Collections.reverseOrder());</span><br><span class="line">        stringPQ.addAll(strings);</span><br><span class="line">        QueueDemo.printQ(stringPQ);</span><br><span class="line"></span><br><span class="line">        Set&lt;Character&gt; charset = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : fact.toCharArray()) &#123;</span><br><span class="line">            charset.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;Character&gt; characterPQ = <span class="keyword">new</span> PriorityQueue&lt;&gt;(charset);</span><br><span class="line">        QueueDemo.printQ(characterPQ);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Foreach和迭代器</li></ul><p>任何实现Iterable的类，都可以用于foreach语句中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IterableClass</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">String</span>&gt; </span>&#123;<span class="comment">//泛型使用</span></span><br><span class="line">   <span class="keyword">protected</span> String[] words = (<span class="string">"And that is how"</span> + <span class="string">"we know the Earth to be banana-shaped."</span>).split(<span class="string">" "</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;String&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> index &lt; words.length;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> words[index++];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String s : <span class="keyword">new</span> IterableClass()) &#123;</span><br><span class="line">            System.out.print(s + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你有一个接口并需要另外一个接口时，编写适配器就可以解决问题。例如添加一个能够产生Iterable对象的方法，该对象可以用于foreach语句。属于:适配器模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReversibleArrayList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReversibleArrayList</span><span class="params">(Collection&lt;? extends T&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;T&gt; <span class="title">reversed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterable&lt;T&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;T&gt;() &#123;</span><br><span class="line">                    <span class="keyword">int</span> current = size() -<span class="number">1</span>;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> current &gt; -<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> get(current--);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterMethodIdiom</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReversibleArrayList&lt;String&gt; ral = <span class="keyword">new</span> ReversibleArrayList(Arrays.asList(<span class="string">"To be or not to be"</span>.split(<span class="string">" "</span>)));</span><br><span class="line">        <span class="keyword">for</span> (String s : ral) &#123;</span><br><span class="line">            System.out.print(s + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span> (String s : ral.reversed()) &#123;</span><br><span class="line">            System.out.print(s + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-通过异常处理错误"><a href="#3-通过异常处理错误" class="headerlink" title="3.通过异常处理错误"></a>3.通过异常处理错误</h4><ul><li>异常类型的根类是Throwable</li><li>监控区域的概念<br>一段可能产生异常的代码，后面跟着处理这些异常的代码</li><li>异常处理程序，就是catch块</li><li>异常处理理论上有两种基本模型：终止模型(无法返回异常发生地方继续执行)和恢复模型(修正错误，并继续调用出错方法)</li><li>恢复模型包含依赖于抛出位置的非通用性代码，增加代码编写和维护的难度</li><li>创建自定义异常<blockquote><p>自定义异常必须从已有类中继承，最好选择意思相近。<br>对异常来说最重要的部分就是类名<br>最简单的方法就是让编译期为你产生默认构造器</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritingExceptions</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">throws</span> SimpleException </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"Throw SimpleException from f()"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SimpleException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InheritingExceptions sed = <span class="keyword">new</span> InheritingExceptions();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sed.f();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SimpleException e) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"Caught it!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>也可以为异常类定义一个接受字符串参数的构造器:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FullConstructors</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">throws</span> MyException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Throwing MyException form f()"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MyException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> <span class="keyword">throws</span> MyException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Throwing MyException from g()"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">"Originated in g()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            e.printStackTrace(System.out);<span class="comment">//信息发送到System.out，自动被捕获和显示在输出中；e.printStackTrace()会输出到标准错误流。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            g();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            e.printStackTrace(System.out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>异常记录日志:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = Logger.getLogger(<span class="string">"LoggingException"</span>);</span><br><span class="line">    <span class="comment">//SEVERE（最高值） 严重信息</span></span><br><span class="line">    <span class="comment">//WARNING 警示信息</span></span><br><span class="line">    <span class="comment">//INFO 一般信息</span></span><br><span class="line">    <span class="comment">//CONFIG 配置信息</span></span><br><span class="line">    <span class="comment">//FINE 细微信息</span></span><br><span class="line">    <span class="comment">//FINER 更细微的信息</span></span><br><span class="line">    <span class="comment">//FINEST（最低值） 最细微的信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoggingException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringWriter trace = <span class="keyword">new</span> StringWriter();<span class="comment">//</span></span><br><span class="line">        printStackTrace(<span class="keyword">new</span> PrintWriter(trace));<span class="comment">//重载的printStackTrace接收PrintWriter对象为参数，通过toString()可以将输出抽取为字符串</span></span><br><span class="line">        logger.severe(trace.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogginExceptions</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LoggingException();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LoggingException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"Caught "</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LoggingException();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LoggingException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"Caught "</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>更进一步自定义异常，加入额外的构造器和成员:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerException</span>  <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomerException</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomerException</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomerException</span><span class="params">(<span class="keyword">int</span> code, String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编译时被强制检查的异常称为被检查的异常</p></blockquote><p><strong>栈轨迹:</strong></p><p>printStackTrace()方法所提供的信息可以通过getStackTrace()直接访问，返回栈轨迹中的元素所构成的数组，每个元素代表栈中一帧。元素0是栈顶元素，是最后一个方法调用。</p><ul><li>重新抛出异常</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">catch(Exception)&#123;</span><br><span class="line"> System.out.println(&quot;An exception was thrown&quot;);</span><br><span class="line"> throw e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新抛出获取异常，printStackTrace()方法显示的是原异常抛出点的调用栈信息，要想更新抛出点的信息，可以调用fillInStackTrace()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    //异常</span><br><span class="line">&#125; catch(Exception e)&#123;</span><br><span class="line">    throw (Exception)e.fillInStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的行为也会更新抛出点的信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    //异常</span><br><span class="line">&#125; catch (OneException one) &#123;</span><br><span class="line">   throw new TwoException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>异常链</li></ul><p>捕获异常后，将原始信息一并打印出来，这就是异常链。<br>Throwable的子类在构造器中都可以接受一个cause对象作为参数，这个cause就是原始异常，通过cause实现把原始异常传递给新的异常。<br>在Throwable子类中，只有三种基本的异常类Error、Exception、及RuntimeException提供了带cause参数的构造器。如果要把其它类型链接起来应该使用initCause()方法而不是构造器实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  //异常</span><br><span class="line">&#125;catch(NoSuchFieldException e)&#123;</span><br><span class="line">  throw new RuntimeException(e);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  //异常</span><br><span class="line">&#125;catch(NoSuchFieldException e)&#123;</span><br><span class="line">  DynamicFieldsException dfe = new DynamicFieldsException();</span><br><span class="line">  dfe.initCause(e);</span><br><span class="line">  throw dfe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>java标准异常</li></ul><blockquote><p>Throwable可分为两种类型：Error-编译时和系统错误(一般不用关心)；Exception-基本异常类型(关心)<br>RuntimeException不会被编译器发现，其输出被报告给System.err;如果RuntimeException没有被捕获直达main（）</p></blockquote><ul><li>finally可用于释放内存之外的其他资源</li><li><p>finally总是会执行，即使方法有多个返回点，任可保证执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultipleReturns</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Initialization that requires cleanup"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Point 1"</span>);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Point 2"</span>);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Point 3"</span>);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"End"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Performing cleanup"</span>); <span class="comment">//都会执行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">            f(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>派生类构造器不能捕获基类构造器抛出的异常</p></li><li>一个派生类继承父类并实现接口，如果父类有接口的实现，且方法在接口和父类中抛出不一样的异常，基类复写方法时不能抛出异常。</li><li>一个派生类继承抽象父类，如果抽象父类中抽象父类抛出指定异常，则派生类复写方法时只能抛出父类部分或全部指定异常。</li><li>异常处理系统会按照catch异常顺序匹配异常，异常的派生类也可以被异常基类捕获</li></ul><h4 id="4-字符串"><a href="#4-字符串" class="headerlink" title="4.字符串"></a>4.字符串</h4><ul><li>String类中每一个看起来会修改String值的方法，实际上都是创建了一个全新的对象，以包含修改后的字符串内容。而最初的String对象则丝毫未动。</li><li>用于String的 “+” 与 “+=” 是java中仅有的两个重载过的操作符，而java并不允许程序员重载任何操作符</li><li><p>格式化输出： <code>printf()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintfTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">float</span> y =  <span class="number">1.01f</span>;</span><br><span class="line">        System.out.printf(<span class="string">"row 1:[%d %f]"</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>格式化输出： <code>format()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintfTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">float</span> y =  <span class="number">1.01f</span>;</span><br><span class="line">        System.out.format(<span class="string">"row 1:[%d %f]"</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Formatter转换器<br><strong>格式：</strong><br>d====&gt;整数型(十进制)  e====&gt;浮点数(科学计数)<br>c====&gt;Unicode字符    x====&gt;整数(十六进制)<br>b====&gt;Boolean值      h====&gt;散列码(十六进制)<br>s====&gt;String         %====&gt;字符%<br>f====&gt;浮点数(十进制)</p></li></ul><p>实战如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Formatter f = new Formatter(System.out);</span><br><span class="line">char u = &apos;a&apos;;</span><br><span class="line">System.out.println(&quot;u = &apos;a&apos;&quot;);</span><br><span class="line">f.format(&quot;s: %s\n&quot;, u);</span><br><span class="line">f.format(&quot;c: %c\n&quot;, u);</span><br><span class="line">f.format(&quot;b: %b\n&quot;, u);</span><br><span class="line">f.format(&quot;h: %h\n&quot;, u);</span><br><span class="line"></span><br><span class="line">int v =121;</span><br><span class="line">System.out.println(&quot;v = 121&quot;);</span><br><span class="line">f.format(&quot;d: %d\n&quot;, v);</span><br><span class="line">f.format(&quot;c: %c\n&quot;, v);</span><br><span class="line">f.format(&quot;b: %b\n&quot;, v);</span><br><span class="line">f.format(&quot;s: %s\n&quot;, v);</span><br><span class="line">f.format(&quot;x: %x\n&quot;, v);</span><br></pre></td></tr></table></figure></p><ul><li><p><code>String.format()</code>是static方法，接受与Formatter.format()方法一样的参数，但返回一个String对象，当只需用format()方法一次的时候使用比较方便</p></li><li><p>正则表达式<br>（1）匹配一个数字，可能有负号在前面：<code>-?</code><br>（2）正则表达式中，一位数字表示：<code>\d</code>，在java中是<code>\\d</code>，java中插入普通反斜线是<code>\\\\</code><br>（3）一个或多个之前的表达式：<code>+</code>，例如：可能有一个负号，后面跟着一位或多位数字，可以这样<code>-?\\d+</code><br>（4）通过String内置方法使用正则表达式：<code>&quot;-1234&quot;.matches(&quot;-?\\d+&quot;)</code><br>（5）可能以一个加号或减号开头<code>(-|\\+)?</code>，其中|为或者意思，因为+符号在正则有特殊意义，使用\转义变为普通符号<br>（6）String自带正则工具split()方法，将字符串从正则匹配的地方切开，<code>String.split(regex)</code>，例如：<code>split(\\W+)</code>从一个或多个非单词处切分，<code>\w</code>表示一个单词；<code>split(n\\W+)</code>从字母n后面跟着一个或多个单词的地方切分。<br>（7）String自带正则工具替换，<code>.replaceFirst(regex,str)</code>替换第一个匹配到的字符串，<code>.replaceAll(regex,str)</code></p></li><li>创建正则表达式</li></ul><p>——–字符——————<br>B==&gt;指定字符B<br>\xhh==&gt; 十六进制值为oxhh的字符串<br>\uhhhh==&gt; 十六进制值为oxhhhh字符<br>\t==&gt; 制表符tab<br>\n==&gt;换行符<br>\r==&gt;回车<br>\f==&gt;换页<br>\e==&gt;转义（Escape）  </p><p>——-字符类—————–<br>.==&gt;任意字符<br>[abc]==&gt;包含a、b和c的任何字符（和a|b|c作用相同）<br>[^abc]==&gt;除了a、b和c之外的任何字符<br>[a-zA-Z]==&gt;从a到z或从A到Z的任何字符<br>[abc[hij]]==&gt;任意a、b、c、h、i和j字符（同a|b|c|h|i|j）<br>[a-z&amp;&amp;[hij]]==&gt;从a到z和h、i、j取交集，结果为hij<br>\s==&gt;空白符（空格、tab、换行、换页和回车）<br>\S==&gt;非空白符（[^\s]）<br>\d==&gt;数字[0-9]<br>\D==&gt;非数字[^0-9]<br>\w==&gt;词字符[a-zA-Z0-9]<br>\W==&gt;非词字符[^\w]<br>——-逻辑操作符—————–<br>XY==&gt;Y跟在X后面<br>X|Y==&gt;X或Y<br>(X)==&gt;捕获组，可以在表达式中用\i引用第i个捕获组<br>——-边界匹配符—————–<br>^==&gt;一行的开始<br>$==&gt;一行的结束<br>\b==&gt;词的边界<br>\B==&gt;非词的边界<br>\G==&gt;前一个匹配的结束  </p><ul><li>量词<br>1.贪婪型<br>贪婪表达式会为所有可能的模式发现更多匹配<br>2.勉强型<br>用问号来指定，匹配满足模式所需的最少字符数<br>3.占有型</li></ul><table><thead><tr><th style="text-align:center">贪婪型</th><th style="text-align:center">勉强型</th><th style="text-align:center">占有型</th><th style="text-align:center">如何匹配</th></tr></thead><tbody><tr><td style="text-align:center">X?</td><td style="text-align:center">X??</td><td style="text-align:center">X?+</td><td style="text-align:center">一个或零个X</td></tr><tr><td style="text-align:center">X*</td><td style="text-align:center">X*?</td><td style="text-align:center">X*+</td><td style="text-align:center">零个或多个X</td></tr><tr><td style="text-align:center">X+</td><td style="text-align:center">X+?</td><td style="text-align:center">X++</td><td style="text-align:center">一个或多个X</td></tr><tr><td style="text-align:center">X{n}</td><td style="text-align:center">X{n}?</td><td style="text-align:center">X{n}+</td><td style="text-align:center">恰好n次</td></tr><tr><td style="text-align:center">X{n,}</td><td style="text-align:center">X{n,}?</td><td style="text-align:center">X{n,}+</td><td style="text-align:center">至少n次X</td></tr><tr><td style="text-align:center">X{n,m}</td><td style="text-align:center">X{n,m}?</td><td style="text-align:center">X{n,m}+</td><td style="text-align:center">至少n次，最多m次</td></tr></tbody></table><blockquote><p>note:    <code>abc+</code>代表匹配ab，后面跟1个或多个c；<code>(abc)+</code>代表匹配一个或多个abc</p></blockquote><ul><li>Pattern 和 Matcher</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//编译正则表达式字符串</span><br><span class="line">Pattern p = Pattern.compile(regx);</span><br><span class="line">//匹配目标字符串</span><br><span class="line">Matcher m = p.matcher(targetStr);</span><br><span class="line">//todo Matcher的方法</span><br></pre></td></tr></table></figure><blockquote><p>Matcher对象的方法reset()，带参数时可以替换目标匹配字符串，不带参数重新设置到当前字符串序列的起始位置。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续看java编程思想，这篇主要记录了书中第十章：内部类、第十一章：持有对象、第十二章：通过异常处理错误中的碎片知识。&lt;br&gt;
    
    </summary>
    
    
      <category term="编程思想" scheme="https://dongme.site/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>快捷键</title>
    <link href="https://dongme.site/2018/07/22/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://dongme.site/2018/07/22/快捷键/</id>
    <published>2018-07-22T05:23:00.000Z</published>
    <updated>2018-08-29T16:10:58.310Z</updated>
    
    <content type="html"><![CDATA[<p>mac、sublime 和 idea的一些快捷键可以大大加快我们的工作效率，特此mark一下，后续会不断更新完善。<br><a id="more"></a></p><p>——————- mac 快捷键———————<br>⌘ Command<br>⇧ Shift<br>⌥ Option<br>⌃ Control<br>↩︎ Return/Enter<br>⌫ Delete<br>⌦ 向前删除键（Fn+Delete）<br>↑ 上箭头<br>↓ 下箭头<br>← 左箭头<br>→ 右箭头<br>⇞ Page Up（Fn+↑）<br>⇟ Page Down（Fn+↓）<br>Home Fn + ←<br>End Fn + →<br>⇥ 右制表符（Tab键）<br>⇤ 左制表符（Shift+Tab）<br>⎋ Escape (Esc)<br>control + alt/option + space bar 切换下一个输入法<br>control + space bar 切换最近的一次输入法<br>command + ←/→  光标定位到行首或行尾部<br>option + ←/→ 光标定位到上一个或下一个单词  </p><p>———————sublime————————  </p><p>sublime多行<br>下面就来看下具体的五种方式吧：<br>1，鼠标选中多行，按下 Ctrl Shift L (Command Shift L) 即可同时编辑这些行；<br>2，鼠标选中文本，反复按 CTRL D (Command D) 即可继续向下同时选中下一个相同的文本进行同时编辑；<br>3，鼠标选中文本，按下 Alt F3 (Win) 或 Ctrl Command G(Mac) 即可一次性选择全部的相同文本进行同时编辑；<br>4，Shift 鼠标右键 (Win) 或 Option 鼠标左键 (Mac) 或使用鼠标中键可以用鼠标进行竖向多行选择；<br>5，Ctrl 鼠标左键(Win) 或 Command 鼠标左键(Mac) 可以手动选择同时要编辑。</p><p>———————-idea 常用但常忘记快捷键———————–<br>Command + Shift + Delete 跳转到最后一个编辑的地方<br>Option + Enter 显示意向动作和快速修复代码<br>Option + Command + o   自动删除无效包<br>Command + Shift + ↑/↓ 向上或向下移动代码<br>Option + Command + Enter 当前光标处代码下移并插入新行且光标定位新行<br>———————-idea快捷————————————<br>一、Editing（编辑）<br>Option/Alt + F7 查看方法在哪些地方被调用<br>Control + Space 基本的代码补全（补全任何类、方法、变量）<br>Control + Shift + Space 智能代码补全（过滤器方法列表和变量的预期类型）<br>Command + Option/Shift + 上下方向键 向上或向下移动代码<br>Command + Shift + Enter 自动结束代码，行末自动添加分号<br>Command + P 显示方法的参数信息<br>Control + J 快速查看文档<br>Shift + F1 查看外部文档（在某些代码上会触发打开浏览器显示相关文档）<br>Command + 鼠标放在代码上 显示代码简要信息<br>Command + F1 在错误或警告处显示具体描述信息<br>Command + N” Control + Enter” Control + N 生成代码（getter、setter、构造函数、hashCode/equals”toString）<br>Control + O 覆盖方法（重写父类方法）<br>Command/Control + I 实现方法（实现接口中的方法）<br>Command + Option + T 包围代码（使用if..else” try..catch” for” synchronized等包围选中的代码）<br>Command + / 注释/取消注释与行注释<br>Command + Option + / 注释/取消注释与块注释<br>Option/Shift + 方向键上 连续选中代码块<br>Option/Shift + 方向键下 减少当前选中的代码块<br>Control + Shift + Q 显示上下文信息<br>Option + Enter 显示意向动作和快速修复代码<br>Command + Option + L 格式化代码<br>Control + Option + O 优化import<br>Control + Option + I 自动缩进线<br>Tab / Shift + Tab 缩进代码 / 反缩进代码<br>Command + X 剪切当前行或选定的块到剪贴板<br>Command + C 复制当前行或选定的块到剪贴板<br>Command + V 从剪贴板粘贴<br>Command + Shift + V 从最近的缓冲区粘贴<br>Command + D 复制当前行或选定的块<br>Command + Y/Delete 删除当前行或选定的块的行<br>Control + Shift + J 智能的将代码拼接成一行<br>Command + Enter 智能的拆分拼接的行<br>Shift + Enter 开始新的一行<br>Command + Shift + U 大小写切换<br>Command + Shift + ] / Command + Shift + [ 选择直到代码块结束/开始<br>Option + Fn + Delete 删除到单词的末尾<br>Option + Delete 删除到单词的开头<br>Command + 加号 / Command + 减号 展开 / 折叠代码块<br>Command + Shift + 加号 展开所以代码块<br>Command + Shift + 减号 折叠所有代码块<br>Command + W 关闭活动的编辑器选项卡<br>二、Search/Replace（查询/替换）<br>Double Shift 查询任何东西<br>Command + F 文件内查找<br>Command + G 查找模式下，向下查找<br>Command + Shift + G 查找模式下，向上查找<br>Command + R 文件内替换<br>Command + Shift + F 全局查找（根据路径）<br>Command + Shift + R 全局替换（根据路径）<br>Command + Shift + S 查询结构（Ultimate Edition 版专用，需要在Keymap中设置）<br>Command + Shift + M 替换结构（Ultimate Edition 版专用，需要在Keymap中设置）<br>三、Usage Search（使用查询）<br>Option + F7 / Command + F7 在文件中查找用法 / 在类中查找用法<br>Command + Shift + F7 在文件中突出显示的用法<br>Command + Option + F7 显示用法<br>四、Compile and Run（编译和运行）<br>Command + F9 编译Project<br>Command + Shift + F9 编译选择的文件、包或模块<br>Control + Option + R 弹出 Run 的可选择菜单<br>Control + Option + D 弹出 Debug 的可选择菜单<br>Control + R 运行<br>Control + D 调试<br>Control + Shift + R” Control + Shift + D 从编辑器运行上下文环境配置<br>五、Debugging（调试）<br>F8 进入下一步，如果当前行断点是一个方法，则不进入当前方法体内<br>F7 进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中<br>Shift + F7 智能步入，断点所在行上有多个方法调用，会弹出进入哪个方法<br>Shift + F8 跳出<br>Option + F9 运行到光标处，如果光标前有其他断点会进入到该断点<br>Option + F8 计算表达式（可以更改变量值使其生效）<br>Command + Option + R 恢复程序运行，如果该断点下面代码还有断点则停在下一个断点上<br>Command + F8 切换断点（若光标当前行有断点则取消断点，没有则加上断点）<br>Command + Shift + F8 查看断点信息<br>六、Navigation（导航）<br>Command + O 查找类文件<br>Command + Shift + O 查找所有类型文件、打开文件、打开目录，打开目录需要在输入的内容前面或后面加一个反斜杠/<br>Command + Option + O 前往指定的变量 / 方法<br>Control + 方向键左 / Control + 方向键右 左右切换打开的编辑tab页<br>F12 返回到前一个工具窗口<br>Esc 从工具窗口进入代码文件窗口<br>Shift + Esc 隐藏当前或最后一个活动的窗口，且光标进入代码文件窗口<br>Command + Shift + F4 关闭活动run/messages/find/… tab<br>Command + L 在当前文件跳转到某一行的指定处<br>Command + E 显示最近打开的文件记录列表<br>Option + 方向键左 / Option + 方向键右 光标跳转到当前单词 / 中文句的左 / 右侧开头位置<br>Command + Option + 方向键左 / Command + Option + 方向键右 退回 / 前进到上一个操作的地方<br>Command + Shift + Delete 跳转到最后一个编辑的地方<br>Option + F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择(如在代码编辑窗口可以选择显示该文件的Finder)<br>Command + B / Command + 鼠标点击 进入光标所在的方法/变量的接口或是定义处<br>Command + Option + B 跳转到实现处，在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口<br>Option + Space” Command + Y 快速打开光标所在方法、类的定义<br>Control + Shift + B 跳转到类型声明处<br>Command + U 前往当前光标所在方法的父类的方法 / 接口定义<br>Control + 方向键下 / Control + 方向键上 当前光标跳转到当前文件的前一个/后一个方法名位置<br>Command + ] / Command + [ 移动光标到当前所在代码的花括号开始/结束位置<br>Command + F12 弹出当前文件结构层，可以在弹出的层上直接输入进行筛选（可用于搜索类中的方法）<br>Control + H 显示当前类的层次结构<br>Command + Shift + H 显示方法层次结构<br>Control + Option + H 显示调用层次结构<br>F2 / Shift + F2 跳转到下一个/上一个突出错误或警告的位置<br>F4 / Command + 方向键下 编辑/查看代码源<br>Option + Home 显示到当前文件的导航条<br>F3选中文件/文件夹/代码行，添加/取消书签<br>Option + F3 选中文件/文件夹/代码行，使用助记符添加/取消书签<br>Control + 0…Control + 9 定位到对应数值的书签位置<br>Command + F3 显示所有书签<br>七、Refactoring（重构）<br>F5 复制文件到指定目录<br>F6 移动文件到指定目录<br>Command + Delete 在文件上为安全删除文件，弹出确认框<br>Shift + F6 重命名文件<br>Command + F6 更改签名<br>Command + Option + N 一致性<br>Command + Option + M 将选中的代码提取为方法<br>Command + Option + V 提取变量<br>Command + Option + F 提取字段<br>Command + Option + C 提取常量<br>Command + Option + P 提取参数<br>八、VCS/Local History（版本控制/本地历史记录）<br>Command + K 提交代码到版本控制器<br>Command + T 从版本控制器更新代码<br>Option + Shift + C 查看最近的变更记录<br>Control + C 快速弹出版本控制器操作面板<br>九、Live Templates（动态代码模板）<br>Command + Option + J 弹出模板选择窗口，将选定的代码使用动态模板包住<br>Command + J 插入自定义动态代码模板<br>十、General（通用）<br>Command + 1…Command + 9 打开相应编号的工具窗口<br>Command + S 保存所有<br>Command + Option + Y 同步、刷新<br>Control + Command + F 切换全屏模式<br>Command + Shift + F12 切换最大化编辑器<br>Option + Shift + F 添加到收藏夹<br>Option + Shift + I 检查当前文件与当前的配置文件<br>Control + ` 快速切换当前的scheme（切换主题、代码样式等）<br>Command + “ 打开IDEA系统设置<br>Command + ; 打开项目结构对话框<br>Shift + Command + A 查找动作（可设置相关选项）<br>Control + Shift + Tab 编辑窗口标签和工具窗口之间切换（如果在切换的过程加按上delete，则是关闭对应选中的窗口）<br>十一、Other（一些官方文档上没有体现的快捷键）<br>Command + Shift +8 竖编辑模式</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mac、sublime 和 idea的一些快捷键可以大大加快我们的工作效率，特此mark一下，后续会不断更新完善。&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="https://dongme.site/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="快捷键" scheme="https://dongme.site/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>java编程思想[1-9]</title>
    <link href="https://dongme.site/2018/06/06/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-1/"/>
    <id>https://dongme.site/2018/06/06/java编程思想-1/</id>
    <published>2018-06-05T16:00:00.000Z</published>
    <updated>2018-08-29T16:10:58.308Z</updated>
    
    <content type="html"><![CDATA[<p>最近看java编程思想，对看过的前1-9章一些似懂非懂的知识点做个记录吧。<br><a id="more"></a></p><h4 id="1-”是一个”与”像是一个”的关系"><a href="#1-”是一个”与”像是一个”的关系" class="headerlink" title="1.”是一个”与”像是一个”的关系"></a>1.”是一个”与”像是一个”的关系</h4><ul><li>导出类只覆盖基类的方法，导出类和基类是完全相同的类型，基类和导出类的关系是一个关系。</li><li>导出类添加新的接口元素，基类无法访问导出类的新接口元素，基类和导出类之间的关系是”像是一个的关系”</li></ul><h4 id="2-伴随多态的可互换对象"><a href="#2-伴随多态的可互换对象" class="headerlink" title="2.伴随多态的可互换对象"></a>2.伴随多态的可互换对象</h4><ul><li>伴随多态的可互换对象基于面向对象程序设计语言采用了后期绑定的概念。当向对象发送消息时，被调用的代码在运行时才能确定。</li></ul><h4 id="3-为什么支持多种类型容器"><a href="#3-为什么支持多种类型容器" class="headerlink" title="3.为什么支持多种类型容器"></a>3.为什么支持多种类型容器</h4><p> 容器持有其它对象的引用，设计多种容器类型原因如下：</p><ul><li>不同容器提供不同的接口和行为</li><li>不同容器对某些操作的效率不同</li></ul><h4 id="4-对象和其它变量存储空间、生命周期"><a href="#4-对象和其它变量存储空间、生命周期" class="headerlink" title="4.对象和其它变量存储空间、生命周期"></a>4.对象和其它变量存储空间、生命周期</h4><ul><li>普通变量存在在堆栈，在编译阶段就会确定变量的存储空间地址和生命周期；对象存在堆（heap），在运行阶段动态分配存储空间，对象的生命周期取决是否被引用，且通过java垃圾回收机制回收。</li></ul><h4 id="5-异常处理不是面向对象的特征。"><a href="#5-异常处理不是面向对象的特征。" class="headerlink" title="5.异常处理不是面向对象的特征。"></a>5.异常处理不是面向对象的特征。</h4><h4 id="6-java基本类型"><a href="#6-java基本类型" class="headerlink" title="6.java基本类型"></a>6.java基本类型</h4><ul><li>boolean、char、byte、short、int、long、float、double、void</li><li>基本类型所占存储空间不随机器硬件架构的变化而变化</li><li>boolean类型没有明确指定存储空间大小，仅定义为能够取字面值true&amp;false</li></ul><h4 id="7-BigInteger-amp-BigDecimal"><a href="#7-BigInteger-amp-BigDecimal" class="headerlink" title="7. BigInteger&amp;BigDecimal"></a>7. BigInteger&amp;BigDecimal</h4><ul><li>高精度计算类，虽然属于包装类却没有对应的基本类型。高精度计算类操作复杂，运算速度相当较慢。</li></ul><h4 id="8-java数组对比C和C"><a href="#8-java数组对比C和C" class="headerlink" title="8.java数组对比C和C++"></a>8.java数组对比C和C++</h4><ul><li>java有范围检查，要求数组必须进行初始化且不超出范围，牺牲了少量内存开销换来安全性和效率的提升。</li></ul><h4 id="9-java类中基本类型成员会自动初始化，但局部变量并不会-非某个类的字段"><a href="#9-java类中基本类型成员会自动初始化，但局部变量并不会-非某个类的字段" class="headerlink" title="9. java类中基本类型成员会自动初始化，但局部变量并不会(非某个类的字段)"></a>9. java类中基本类型成员会自动初始化，但局部变量并不会(非某个类的字段)</h4><ul><li>boolean==&gt;false</li><li>char==&gt;null</li><li>byte==&gt;(byte)0</li><li>short==&gt;(short)0</li><li>int==&gt;0</li><li>long==&gt;oL</li><li>float==&gt;0.0L</li><li>double==&gt;0.0D</li></ul><h4 id="10-方法签名（方法名和参数列表）唯一标识某个方法"><a href="#10-方法签名（方法名和参数列表）唯一标识某个方法" class="headerlink" title="10.方法签名（方法名和参数列表）唯一标识某个方法"></a>10.方法签名（方法名和参数列表）唯一标识某个方法</h4><h4 id="11-static方法牧羊人角色-创建或使用同类型的被命名对象"><a href="#11-static方法牧羊人角色-创建或使用同类型的被命名对象" class="headerlink" title="11.static方法牧羊人角色-创建或使用同类型的被命名对象"></a>11.static方法牧羊人角色-创建或使用同类型的被命名对象</h4><h4 id="12-java-lang默认导入到每个java文件中"><a href="#12-java-lang默认导入到每个java文件中" class="headerlink" title="12.java.lang默认导入到每个java文件中"></a>12.java.lang默认导入到每个java文件中</h4><h4 id="13-文档注释"><a href="#13-文档注释" class="headerlink" title="13.文档注释"></a>13.文档注释</h4><ul><li><code>/*comment*/</code>  整段注释</li><li><code>//</code> 行注释</li></ul><h4 id="14-javadoc命令只能出现在-中，可嵌入html"><a href="#14-javadoc命令只能出现在-中，可嵌入html" class="headerlink" title="14.javadoc命令只能出现在/**中，可嵌入html"></a>14.javadoc命令只能出现在/**中，可嵌入html</h4><ul><li>@see: 引用其他类</li><li>@link: 与@see类似，但是属于行内引用，{@link package.class#member label}</li><li>@{@docRoot}</li><li>@{inheritDoc}</li><li>@version</li><li>@author</li><li>@since</li><li>@param</li><li>@return</li><li>@throws</li><li>@deprecated</li></ul><h4 id="15-几乎所有操作类型只能操作基本类型，例外的操作符是“-”，“-”，“-”可以操作所有对象"><a href="#15-几乎所有操作类型只能操作基本类型，例外的操作符是“-”，“-”，“-”可以操作所有对象" class="headerlink" title="15.几乎所有操作类型只能操作基本类型，例外的操作符是“=”，“!=”，“==”可以操作所有对象"></a>15.几乎所有操作类型只能操作基本类型，例外的操作符是“=”，“!=”，“==”可以操作所有对象</h4><h4 id="16-随机数的生成"><a href="#16-随机数的生成" class="headerlink" title="16.随机数的生成"></a>16.随机数的生成</h4><p><strong>Random rand = new Random():</strong><br>若创建时不输入构造参数，每一轮执行第n次rand.nextInt(100)的结果都不同；<br>若创建时输入构造参数，每一轮执行第n次rand.nextInt(100)的结构都相同。</p><h4 id="17-对象的等价性"><a href="#17-对象的等价性" class="headerlink" title="17.对象的等价性"></a>17.对象的等价性</h4><ul><li>基本类型判断等价性使用==和!=；比较其他对象的等价性使用每个对象都有的equals方法。</li></ul><h4 id="18-指数计数法"><a href="#18-指数计数法" class="headerlink" title="18.指数计数法"></a>18.指数计数法</h4><p><code>float flt = 1.36e-19f</code><br>等价于如下计算:<br><code>flt = 1.36*10^(-19)</code></p><h4 id="19-java位运算"><a href="#19-java位运算" class="headerlink" title="19.java位运算"></a>19.java位运算</h4><ul><li>在计算机中所有数据都是以二进制的形式储存的。位运算其实就是直接对在内存中的二进制数据进行操作，因此处理数据的速度非常快。</li><li>基本的位操作符有与、或、异或、取反、左移、右移这6种，它们的运算规则如下所示：<br>| 符号 | 描述 | 运算规则 |<br>| :-: | :-: | :-: |<br>| &amp; | 与 | 两个位都为1时结果才为1 |<br>| | | 或 | 两个位都为0时才为0 |<br>| ^ | 异或 | 两个位相同时为0，相异时为1 |<br>| ~ | 取反 | 1变0，0变1 |<br>| &lt;&lt; | 左移 | 各二进位全部左移若干位，高位丢弃，低位补 0；num &lt;&lt; 1”相当于num乘以2|<br>| &gt;&gt; | 有符号右移 | 各二进位全部右移若干位，对无符号数，高位补 0，有符号数，各编译器处理方法不一样，有的补符号位(算术右移，java采用)，有的补 0 (逻辑右移)；num &gt;&gt; 1”相当于num除以2|<br>| &gt;&gt;&gt; | 无符号右移 | 无论正负都在高位补0|</li><li>计算机中采用补码的形式进行二进制运算；正数的原码、反码和补码都一样；负数的反码，对应正数二进制表示所有位取反；负数的补码等于反码</li></ul><h4 id="20-java类型转换，扩展转换是自动的，窄化转换是强制的，而且数值窄化转换会强制截尾（Math-round-x-可实现四舍五入）"><a href="#20-java类型转换，扩展转换是自动的，窄化转换是强制的，而且数值窄化转换会强制截尾（Math-round-x-可实现四舍五入）" class="headerlink" title="20.java类型转换，扩展转换是自动的，窄化转换是强制的，而且数值窄化转换会强制截尾（Math.round(x)可实现四舍五入）"></a>20.java类型转换，扩展转换是自动的，窄化转换是强制的，而且数值窄化转换会强制截尾（Math.round(x)可实现四舍五入）</h4><h4 id="21-while-x-y-除非x和y都是boolean类型，否则编译报错"><a href="#21-while-x-y-除非x和y都是boolean类型，否则编译报错" class="headerlink" title="21. while(x=y)除非x和y都是boolean类型，否则编译报错"></a>21. while(x=y)除非x和y都是boolean类型，否则编译报错</h4><h4 id="22-void方法中有隐含的return，另外return会退出当前方法"><a href="#22-void方法中有隐含的return，另外return会退出当前方法" class="headerlink" title="22. void方法中有隐含的return，另外return会退出当前方法"></a>22. void方法中有隐含的return，另外return会退出当前方法</h4><h4 id="23-break-lable和continue-lable的区别"><a href="#23-break-lable和continue-lable的区别" class="headerlink" title="23. break lable和continue lable的区别"></a>23. break lable和continue lable的区别</h4><ul><li>嵌套循环，内循环内执行continue label会跳到外循环外label1并重新进入循环，break label则不会重新进入循环</li></ul><h4 id="24-多个构造器也是方法重载的使用"><a href="#24-多个构造器也是方法重载的使用" class="headerlink" title="24.多个构造器也是方法重载的使用"></a>24.多个构造器也是方法重载的使用</h4><h4 id="25-this代表调用方法的那个对象，会隐式的作为方法的第一个参数传过去，并通过this进行引用"><a href="#25-this代表调用方法的那个对象，会隐式的作为方法的第一个参数传过去，并通过this进行引用" class="headerlink" title="25. this代表调用方法的那个对象，会隐式的作为方法的第一个参数传过去，并通过this进行引用"></a>25. this代表调用方法的那个对象，会隐式的作为方法的第一个参数传过去，并通过this进行引用</h4><h4 id="26-构造器中调用构造器，可用this-参数列表-且必须放第一行且只能通过该形式调用一次"><a href="#26-构造器中调用构造器，可用this-参数列表-且必须放第一行且只能通过该形式调用一次" class="headerlink" title="26. 构造器中调用构造器，可用this(参数列表)且必须放第一行且只能通过该形式调用一次"></a>26. 构造器中调用构造器，可用this(参数列表)且必须放第一行且只能通过该形式调用一次</h4><h4 id="27-static的含义"><a href="#27-static的含义" class="headerlink" title="27. static的含义"></a>27. static的含义</h4><ul><li>static的方法没有隐含this参数</li><li>static的方法不能调用非static的方法，反之可以</li></ul><h4 id="28-finalize-用法"><a href="#28-finalize-用法" class="headerlink" title="28. finalize()用法"></a>28. finalize()用法</h4><ul><li>在类中定义一个finalize()，在垃圾回收器准备回收对象时会首先调用该函数</li><li>java中调用了非java的代码开辟了存储空间，需要finalize()中释放空间</li><li>通常不能指望finalize()，必须创建其它的清理方法</li></ul><h4 id="29-类的数据成员如果是基本类型会被自动初始化为默认值"><a href="#29-类的数据成员如果是基本类型会被自动初始化为默认值" class="headerlink" title="29. 类的数据成员如果是基本类型会被自动初始化为默认值"></a>29. 类的数据成员如果是基本类型会被自动初始化为默认值</h4><h4 id="30-类成员初始化顺序依次"><a href="#30-类成员初始化顺序依次" class="headerlink" title="30. 类成员初始化顺序依次"></a>30. 类成员初始化顺序依次</h4><ul><li>基类构造器 &gt;（静态变量、静态初始化块）&gt;（变量、初始化块）&gt; 导出类构造器</li></ul><h4 id="31-对象创建过程及成员初始化"><a href="#31-对象创建过程及成员初始化" class="headerlink" title="31. 对象创建过程及成员初始化"></a>31. 对象创建过程及成员初始化</h4><p><strong>假设有个名为Dog的类</strong></p><ol><li>即使没有显式地使用static关键字，构造器实际上也是静态方法。因此，当首次创建类型为Dog的对象时，<br>或者Dog类的静态方法/静态域首次被访问时，java解释器必须查找类路径，以定位Dog.class文件</li><li>然后载入Dog.class(会创建Class对象)，有关静态初始化的所有动作都会执行。因此，静态初始化只在Class<br>对象首次加载的时候执行一次。</li><li>当用new Dog()创建对象的时候，首先将在堆上为Dog对象分配足够的存储空间。</li><li>这块存储空间会被清零，这就自动地将Dog对象中所有基本类型设置成默认值。(数字、字符、布尔为0，引用为null)</li><li>执行所有出现于字段定义处的初始化动作。</li><li>执行构造器</li></ol><h4 id="32-数组初始化"><a href="#32-数组初始化" class="headerlink" title="32. 数组初始化"></a>32. 数组初始化</h4><ul><li><code>int[] a1 = {1&quot;2&quot;3&quot;4&quot;5}</code></li><li><code>int a2 [] = new int[]{20&quot;21&quot;22}</code></li><li><code>int a3 = new int[5]</code>，随后进行初始化</li></ul><h4 id="33-可变参数列表"><a href="#33-可变参数列表" class="headerlink" title="33. 可变参数列表"></a>33. 可变参数列表</h4><ul><li>void test(Object… objs)，objs会根据输入的参数创建数组。</li></ul><h4 id="34-enum枚举类型可以结合switch语句使用"><a href="#34-enum枚举类型可以结合switch语句使用" class="headerlink" title="34.enum枚举类型可以结合switch语句使用"></a>34.enum枚举类型可以结合switch语句使用</h4><h4 id="35-一个java源代码文件有且只能有一个public类"><a href="#35-一个java源代码文件有且只能有一个public类" class="headerlink" title="35.一个java源代码文件有且只能有一个public类"></a>35.一个java源代码文件有且只能有一个public类</h4><h4 id="36-package语言必须出现在除注释外的第一行"><a href="#36-package语言必须出现在除注释外的第一行" class="headerlink" title="36.package语言必须出现在除注释外的第一行"></a>36.package语言必须出现在除注释外的第一行</h4><h4 id="37-java类中不指定package，会使用默认包"><a href="#37-java类中不指定package，会使用默认包" class="headerlink" title="37.java类中不指定package，会使用默认包"></a>37.java类中不指定package，会使用默认包</h4><h4 id="38-运行java-类名会自动运行该类下的main方法"><a href="#38-运行java-类名会自动运行该类下的main方法" class="headerlink" title="38.运行java 类名会自动运行该类下的main方法"></a>38.运行java 类名会自动运行该类下的main方法</h4><h4 id="39-继承类的构造过程是从内向外，先调用基类构造器后调用导出类构造器"><a href="#39-继承类的构造过程是从内向外，先调用基类构造器后调用导出类构造器" class="headerlink" title="39.继承类的构造过程是从内向外，先调用基类构造器后调用导出类构造器"></a>39.继承类的构造过程是从内向外，先调用基类构造器后调用导出类构造器</h4><h4 id="40-子类调用父类带参构造器使用super"><a href="#40-子类调用父类带参构造器使用super" class="headerlink" title="40.子类调用父类带参构造器使用super"></a>40.子类调用父类带参构造器使用super</h4><h4 id="41-复用类之组合、继承、代理"><a href="#41-复用类之组合、继承、代理" class="headerlink" title="41.复用类之组合、继承、代理"></a>41.复用类之组合、继承、代理</h4><ul><li>代理的实质是通过创建一个代理类去，并将代理对象作为初始化成员属性通过自身方法调用目标对象的方法，是对目标方法的再次包装</li></ul><h4 id="42-导出类可以向上自动转型为基类类型"><a href="#42-导出类可以向上自动转型为基类类型" class="headerlink" title="42.导出类可以向上自动转型为基类类型"></a>42.导出类可以向上自动转型为基类类型</h4><h4 id="43-继承or组合"><a href="#43-继承or组合" class="headerlink" title="43.继承or组合"></a>43.继承or组合</h4><ul><li>继承当慎用，使用组合还是继承判断标准是:是否需要向上转型，若需要则使用继承</li></ul><h4 id="44-final相关"><a href="#44-final相关" class="headerlink" title="44.final相关"></a>44.final相关</h4><ul><li>final标注的类型必须初始化</li><li>分配固定的存储空间，基本类型值不变，引用类型引用地址不变</li><li>基本类型且不是随机数属于编译期常量</li><li>基本类型且属于随机数、对象等引用类型在运行时才能确定，运行时常量</li><li>对数组等引用类型使用final意义不大</li><li>final标注类型初始化可发生在使用之前，如在构造函数中进行初始化</li><li>final标注的方法，可以防止被重写，而是提高效率(编译时动态绑定)</li><li>final标注的类不能被继承，类的方法隐式的指定为final，显示的添加final无意义</li><li>java中除了static方法和final方法(private方法属于final方法)，其它所有方法都是后期绑定</li></ul><h4 id="45-域和静态方法"><a href="#45-域和静态方法" class="headerlink" title="45.域和静态方法"></a>45.域和静态方法</h4><ul><li>普通方法才具有多态性，直接访问的域则是在编译期进行解析，如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class FieldAccess &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Super sup = new Sub();</span><br><span class="line">        System.out.println(&quot;sup.field=&quot; + sup.field + &quot;;sup.getField()=&quot; + sup.getField());</span><br><span class="line">        Sub sub = new Sub();</span><br><span class="line">        System.out.println(&quot;sub.field=&quot; + sub.field + &quot;;sub.getField()=&quot; + sub.getField() + &quot;;sub.getSuperField()=&quot; + sub.getSuperField());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Super &#123;</span><br><span class="line">    public int field = 0;</span><br><span class="line"></span><br><span class="line">    public int getField() &#123;</span><br><span class="line">        return field;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Sub extends Super &#123;</span><br><span class="line">    public int field = 1;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getField() &#123;</span><br><span class="line">        return field;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getSuperField() &#123;</span><br><span class="line">        return super.field;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>基类中的域和导出类中的域尽量不要起相同的名字</li><li>静态方法是不具有多态性的，静态方法是和类而非对象进行关联的</li></ul><h4 id="46-构造器是隐式的static"><a href="#46-构造器是隐式的static" class="headerlink" title="46.构造器是隐式的static"></a>46.构造器是隐式的static</h4><h4 id="47-抽象类和抽象方法"><a href="#47-抽象类和抽象方法" class="headerlink" title="47.抽象类和抽象方法"></a>47.抽象类和抽象方法</h4><ul><li>包含抽象方法的类为抽象类</li><li>一个类中包含一个或多个抽象方法，必须被声明为抽象类</li><li>导出类继承抽象类，要么实现抽象类中的抽象方法，要么声明为抽象类</li></ul><h4 id="48-接口相关"><a href="#48-接口相关" class="headerlink" title="48.接口相关"></a>48.接口相关</h4><ul><li>接口中的任何域都是static和final的，初始化可以发生在编译阶段和运行阶段</li><li>接口只有public和默认(包访问权限)两种权限</li><li>接口中的元素的都是public的</li><li>接口实现工厂方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">interface Service &#123;</span><br><span class="line">    void method1();</span><br><span class="line"></span><br><span class="line">    void method2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface ServiceFactory &#123;</span><br><span class="line">    Service getService();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Implementation1 implements Service &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void method1() &#123;</span><br><span class="line">        System.out.println(&quot;Implementation1:method1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void method2() &#123;</span><br><span class="line">        System.out.println(&quot;Implementation1:method2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Implementation1Factory implements ServiceFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Service getService() &#123;</span><br><span class="line">        return new Implementation1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Implementation2 implements Service &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void method1() &#123;</span><br><span class="line">        System.out.println(&quot;Implemention2:method1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void method2() &#123;</span><br><span class="line">        System.out.println(&quot;Implemention2:method2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Implementation2Factory implements ServiceFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Service getService() &#123;</span><br><span class="line">        return new Implementation2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class FactoriesPrice &#123;</span><br><span class="line">    public static void serviceConsumer(ServiceFactory factory) &#123;</span><br><span class="line">        Service s = factory.getService();</span><br><span class="line">        s.method1();</span><br><span class="line">        s.method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        serviceConsumer(new Implementation1Factory());</span><br><span class="line">        serviceConsumer(new Implementation2Factory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看java编程思想，对看过的前1-9章一些似懂非懂的知识点做个记录吧。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://dongme.site/categories/java/"/>
    
    
      <category term="编程思想" scheme="https://dongme.site/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>博客添加订阅</title>
    <link href="https://dongme.site/2018/05/15/%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E8%AE%A2%E9%98%85/"/>
    <id>https://dongme.site/2018/05/15/博客添加订阅/</id>
    <published>2018-05-15T03:29:57.000Z</published>
    <updated>2018-08-29T16:10:58.310Z</updated>
    
    <content type="html"><![CDATA[<p>下载的主题中包含Rss订阅页签，但发现实际不可用，搜索资料动手完善了下订阅功能。<br><a id="more"></a><br><strong>步骤如下：</strong></p><ul><li>博客根目录下执行<code>npm install hexo-generator-feed --save</code></li><li><p>编辑博客根目录下<code>_config.yml</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">## RSS订阅添加</span><br><span class="line">plugin:</span><br><span class="line">- hexo-generator-feed</span><br><span class="line">#Feed Atom</span><br><span class="line">feed:</span><br><span class="line">  type: atom</span><br><span class="line">  path: atom.xml</span><br><span class="line">  limit: 20</span><br><span class="line">## RSS订阅添加</span><br></pre></td></tr></table></figure></li><li><p>编辑主题下的<code>_config.yml</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## RSS订阅</span><br><span class="line">subnav:</span><br><span class="line">  rss: &quot;/atom.xml&quot;</span><br><span class="line">## RSS订阅</span><br></pre></td></tr></table></figure></li><li><p>重用编译发布博客</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下载的主题中包含Rss订阅页签，但发现实际不可用，搜索资料动手完善了下订阅功能。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>P2P、P2C、O2O、B2C、B2B、C2C</title>
    <link href="https://dongme.site/2018/05/14/P2P%E3%80%81P2C%E3%80%81O2O%E3%80%81B2C%E3%80%81B2B%E3%80%81C2C/"/>
    <id>https://dongme.site/2018/05/14/P2P、P2C、O2O、B2C、B2B、C2C/</id>
    <published>2018-05-14T06:07:00.000Z</published>
    <updated>2018-08-29T16:10:58.307Z</updated>
    
    <content type="html"><![CDATA[<p>相信大家或多或少听说过P2P、P2C、O2O、B2C、B2B、C2C，但当人向你问起这些名词的含义时，你可能会欲言又止。下面会对这些常见的名词进行解释。<br><a id="more"></a></p><h4 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h4><p>P2P借贷是一种将非常小额度的资金聚集起来借贷给有资金需求人群的一种民间小额借贷模式。P2P是“Peer-to-Peer”的简写，个人对个人的意思，P2P借贷指个人通过第三方平台(P2P公司)在收取一定服务费用的前提下向其他个人提供小额借贷的金融模式。<br><strong>P2P模式</strong><br>第一种是纯线上模式，是纯粹的P2P，在这种平台模式上纯粹进行信息匹配，帮助资金借贷双方更好的进行资金匹配，但缺点明显，这种线上模式并不参与担保；<br>第二种是债权转让模式，平台本身先行放贷，再将债权放到平台进行转让，很明显能让企业提高融资端的工作效率，但容易出现资金池，不能让资金充分发挥效益；</p><p>个人理解：手里有些闲钱且想进行理财的人通过平台借给需要借钱的人，P2P公司在中间起的作用是资金兑付，信息匹配，风险控制。</p><h4 id="O2O"><a href="#O2O" class="headerlink" title="O2O"></a>O2O</h4><p>O2O是目前微信二维码营销的超火概念，即Online To Offline，也即将线下商务的机会与互联网结合在了一起，让互联网成为线下交易的前台。<br>这样线下服务就可以用线上来揽客，消费者可以用线上来筛选服务，还有成交可以在线上结算，很快达到规模。该模式最重要的特点是：推广效果可查，每笔交易可跟踪。<br>O2O的优势在于把网上和网下的优势完美结合。通过网购导购机，把互联网与地面店完美对接，实现互联网落地。让消费者在享受线上优惠价格的同时，又可享受线下贴身的服务。同时，O2O模式还可实现不同商家的联盟。<br>O2O营销模式的核心：<br>O2O营销模式的核心是在线预付，在线支付不仅是支付本身的完成，是某次消费得以最终形成的唯一标志，更是消费数据唯一可靠的考核标准。其是对提供online服务的互联网专业公司而言，只有用户在线上完成支付，自身才可能从中获得效益。</p><h4 id="B2C"><a href="#B2C" class="headerlink" title="B2C"></a>B2C</h4><p>B2C是Business-to-Customer的缩写，而其中文简称为“商对客”。“商对客”是电子商务的一种模式，也就是通常说的商业零售，直接面向消费者销售产品和服务。这种形式的电子商务一般以网络零售业为主，主要借助于互联网开展在线销售活动。B2C即企业通过互联网为消费者提供一个新型的购物环境——网上商店，消费者通过网络在网上购物、在网上支付。<br>网站组成<br>B2C电子商务网站由三个基本部分组成：<br>1、为顾客提供在线购物场所的商场网站；<br>2、负责为客户所购商品进行配送的配送系统；<br>3、负责顾客身份的确认及货款结算的银行及认证系统。<br>代表网站：<br>天猫——为人服务做平台<br>京东——自主经营卖产品<br>凡客——自产自销做品牌</p><h4 id="B2B"><a href="#B2B" class="headerlink" title="B2B"></a>B2B</h4><p>B2B（企业对企业的电子商务模式），也有写成BTB，是指企业对企业之间的营销关系，它将企业内部网，通过B2B网站与客户紧密结合起来，通过网络的快速反应，为客户提供更好的服务，从而促进企业的业务发展(Business Development)。近年来B2B发展势头迅猛，趋于成熟。<br>B2B是指进行电子商务交易的供需双方都是商家（或企业、公司），她（他）们使用了互联网的技术或各种商务网络平台，完成商务交易的过程。电子商务是现代B2Bmarketing的一种具体主要的表现形式。<br>含有三要素：<br>1、买卖：B2B网站平台为消费者提供质优价廉的商品，吸引消费者购买的同时促使更多商家的入驻。<br>2、合作：与物流公司建立合作关系，为消费者的购买行为提供最终保障，这是B2B平台硬性条件之一。<br>3、服务：物流主要是为消费者提供购买服务，从而实现再一次的交易。<br>代表网站<br>B2B网站排名阿里巴巴<br>慧聪网<br>中国供应商<br>世界工厂网</p><h4 id="C2C"><a href="#C2C" class="headerlink" title="C2C"></a>C2C</h4><p>c2c实际是电子商务的专业用语，是个人与个人之间的电子商务。c2c即消费者间 ，因为英文中的2的发音同to，所以c to c简写为c2c。c指的是消费者，因为消费者的英文单词是Customer（Consumer），所以简写为c，而C2C即 Customer（Consumer） to Customer（Consumer）。C2C的意思就是个人与个人之间的电子商务。比如一个消费者有一台电脑，通过网络进行交易，把它出售给另外一个消费者，此种交易类型就称为C2C电子商务。<br>代表网站： 淘宝网 易趣网 拍拍网<br>毫无疑问，淘宝在C2C领域的领先地位暂时还没有人能够撼动。然而，淘宝却也不得不承受这份领先带来的沉甸甸压力。在领先与压力之间，淘宝在奋力往前走。</p><h4 id="P2C"><a href="#P2C" class="headerlink" title="P2C"></a>P2C</h4><p>P2C即production to consumer简称为商品和顾客，产品从生产企业直接送到消费者手中，中间没有任何的交易环节。是继B2B、B2C、C2C之后的又一个电子商务新概念。在国内叫做：生活服务平台。<br>P2C具体表现为：如果哪天家乐福、沃尔玛、大中电器等这些零售业巨头也进军电子商务，通过互联网开展商务活动，这种商务活动的可能性一直是存在的，并且随着互联网技术的平台发展，还会向中小企业逐步渗透。<br>P2C把老百姓日常生活当中的一切密切相关的服务信息，如房产、餐饮、交友、家政服务、票务、健康、医疗、保健等聚合在平台上，实现服务业的电子商务化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信大家或多或少听说过P2P、P2C、O2O、B2C、B2B、C2C，但当人向你问起这些名词的含义时，你可能会欲言又止。下面会对这些常见的名词进行解释。&lt;br&gt;
    
    </summary>
    
      <category term="名词解释" scheme="https://dongme.site/categories/%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"/>
    
    
      <category term="B2C" scheme="https://dongme.site/tags/B2C/"/>
    
      <category term="B2B" scheme="https://dongme.site/tags/B2B/"/>
    
      <category term="P2P" scheme="https://dongme.site/tags/P2P/"/>
    
      <category term="C2C" scheme="https://dongme.site/tags/C2C/"/>
    
  </entry>
  
  <entry>
    <title>blog在coding和github同时部署</title>
    <link href="https://dongme.site/2018/05/12/blog%E5%9C%A8coding%E5%92%8Cgithub%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2/"/>
    <id>https://dongme.site/2018/05/12/blog在coding和github同时部署/</id>
    <published>2018-05-12T15:13:00.000Z</published>
    <updated>2018-08-29T16:10:58.308Z</updated>
    
    <content type="html"><![CDATA[<p>最早的之前的blog是在github上，但是github一方面是国外的（个人还是倾向在国内部署），另一方面github pages实现https比较麻烦。于是就将blog迁移到了coding，不过迁移之后我后悔了。coding的响应速度简直kd，而且非会员还要经过一个中间页，真是简直了，于是又将blog迁过来了。。。<br><a id="more"></a></p><h3 id="1-blog规划"><a href="#1-blog规划" class="headerlink" title="1.blog规划"></a>1.blog规划</h3><p>为了便于管理，静态博客分为两个项目管理，一个是博客源码（blogsource）另一个是博客生成码。突发奇想将博客源码和博客生成码在coding和github同时保存，而且能够同时部署。博客生成码可以部署在coding和github，但是博客源码不想暴漏出来，coding上将项目设置成私有项目可以实现，github是开放的（不投资RMB的情况）。于是将本该放到github的一份源码放到了gitee上。</p><h4 id="coding上的处理"><a href="#coding上的处理" class="headerlink" title="coding上的处理"></a>coding上的处理</h4><p>在coding上开blog项目（放博客生成码）和blogsource项目（放博客源码私有）。为了方便代码管理在coding上配置ssh。注意一点ssh可以配置用户下的和项目下的，用户下的拥有所有项目的读写权限，而项目下的仅可以对本项目进行pull操作。<br>ssh密钥添加步骤如下：</p><ul><li>生成ssh密钥：<code>ssh-keygen -t rsa -C &lt;your_email@example.com&gt;</code> 默认生成id_rsa（私钥）和id_rsa.pub（公钥）。系统默认读取id_rsa。为了区分在执行命令时指定生成的文件名为coding_rsa，会生成coding_rsa和coding_rsa.pub。为让系统能够读取到添加ssh agent，执行<code>ssh-add coding_rsa</code></li><li><code>open ~/.ssh</code>找到 coding_rsa.pub并复制其中的内容</li><li>登录coding在个人设置下找到ssh设置粘贴公钥信息，名字可以随便取</li><li>测试密钥是否可用，执行<code>ssh -T git@git.coding.net</code>，提示：<code>Hello alvin_me, You&#39;ve connected to Coding.net via SSH. This is a personal key.</code>代表成功。</li></ul><p>coding上博客域名采用阿里域名，绑定请参照<a href="https://coding.net/help/doc/pages/domain.html" target="_blank" rel="noopener">官方文档</a></p><h4 id="github上的处理"><a href="#github上的处理" class="headerlink" title="github上的处理"></a>github上的处理</h4><p>github pages的要求项目名为<code>&lt;github账户名&gt;.github.io</code>，按照项目名格式创建项目作为博客生成码部署地址。博客源码我们保存到gitee上。在gitee上创建blogsouce项目(放博客源码私有)存放一份博客源码。</p><p>github上ssh密钥的添加同在coding上的添加过程。</p><p>github上博客域名采用godaddy，由于godaddy的域名解析服务器被墙，可以参照文档<a href="https://www.jianshu.com/p/05289a4bc8b2" target="_blank" rel="noopener">如何搭建一个独立博客</a></p><h4 id="博客源码关键配置实现coding和gitee同时部署"><a href="#博客源码关键配置实现coding和gitee同时部署" class="headerlink" title="博客源码关键配置实现coding和gitee同时部署"></a>博客源码关键配置实现coding和gitee同时部署</h4><p>到博客源码顶级目录下（源码.git所在目录）执行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$git remote add both git@git.coding.net:user/blogsource.git</span><br><span class="line"># 添加一个名为 both 的远端</span><br><span class="line">$git remote set-url --add --push both git@git.coding.net:user/blogsource.git</span><br><span class="line"># 为其添加 push 到 Coding 的 SSH 地址</span><br><span class="line">$git remote set-url --add --push both git@gitee.com:user/blogsource.git</span><br><span class="line"># 为其添加 push 到 GitHub 的 SSH 地址</span><br><span class="line"></span><br><span class="line">$git remote -v #查看当前远端仓库</span><br><span class="line">origin  git@git.coding.net:user/blogsource.git (fetch)</span><br><span class="line">origin  git@git.coding.net:user/blogsource.git (push)</span><br><span class="line">github  git@gitee.com:user/blogsource.git (fetch)</span><br><span class="line">github  git@gitee.com:user/blogsource.git (push)</span><br></pre></td></tr></table></figure></p><p>之后执行<code>git push both</code>，可以将博客源码同时推送到coding和gitee。</p><h4 id="博客源码关键配置实现coding和github同时部署"><a href="#博客源码关键配置实现coding和github同时部署" class="headerlink" title="博客源码关键配置实现coding和github同时部署"></a>博客源码关键配置实现coding和github同时部署</h4><p>在博客源码目录下找到项目下的_config.yml，找到deploy部分，设置成如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: </span><br><span class="line">    coding: git@git.coding.net:user/blog.git</span><br><span class="line">    github: git@github.com:user/user.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line">  message: blog update</span><br></pre></td></tr></table></figure></p><p>最后我在mac下执行<code>hexo d</code>时报错<code>EACCES: permission denied, unlink... ...</code>，将.deploy_git目录改成非root用户即可：<code>sudo chown -R alvin:staff .deploy_git/</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最早的之前的blog是在github上，但是github一方面是国外的（个人还是倾向在国内部署），另一方面github pages实现https比较麻烦。于是就将blog迁移到了coding，不过迁移之后我后悔了。coding的响应速度简直kd，而且非会员还要经过一个中间页，真是简直了，于是又将blog迁过来了。。。&lt;br&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://dongme.site/categories/hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo 踩坑</title>
    <link href="https://dongme.site/2018/05/11/Hexo-%E8%B8%A9%E5%9D%91/"/>
    <id>https://dongme.site/2018/05/11/Hexo-踩坑/</id>
    <published>2018-05-11T09:55:00.000Z</published>
    <updated>2018-08-29T16:10:58.307Z</updated>
    
    <content type="html"><![CDATA[<p>本以为可以轻轻松松的把静态博客搭建起来，但还是踩到了不少坑，这里主要记录一下遇到的大坑。<br><a id="more"></a></p><h3 id="Hexo历险记"><a href="#Hexo历险记" class="headerlink" title="Hexo历险记"></a>Hexo历险记</h3><p>整体按照安装步骤。</p><h4 id="node安装"><a href="#node安装" class="headerlink" title="node安装"></a>node安装</h4><p>node安装过程倒没有遇到多少坑，<a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener">node官网</a>介绍的比较详细，其中mac有两种安装方式<code>.tar.gz</code>和<code>pkg</code>。本人比较懒直接下载pkg进行可视化安装。</p><h4 id="hexo安装"><a href="#hexo安装" class="headerlink" title="hexo安装"></a>hexo安装</h4><p>hexo安装同样参考<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">官网</a>。Hexo3.0以后执行<code>npm install -g hexo-cli</code>，涉及到到的指令有如下几个：</p><ul><li><code>hexo init &lt;folder&gt;</code> 初始化博客</li><li><code>hexo clean</code> 清除本地编译生成的静态文件</li><li><code>hexo g</code> 编译生成静态文件</li><li><code>hexo s</code> 本地运行博客，默认地址<code>http://localhost:4000</code></li></ul><h4 id="theme安装"><a href="#theme安装" class="headerlink" title="theme安装"></a>theme安装</h4><p>选好心仪的主题并找到对应git地址，进入博客主站目录下执行<code>git clone theme.git themes/maupassant</code>，个人比较喜欢简洁的风格就选择了maupassant主题。改主题需要两个插件支持，依次执行<code>npm install hexo-renderer-pug --save</code>和<code>npm install hexo-renderer-sass --save</code>，结果在执行的过程中出现如下错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR Local hexo not found in ~/IdeaProjects/blogsourcenew/blog</span><br><span class="line">ERROR Try running: &apos;npm install hexo --save&apos;</span><br></pre></td></tr></table></figure></p><p>中间曲折的尝试过程不多说，本人主要进行了如下操作。</p><ul><li>升级node为最新版本</li><li>升级npm 执行<code>sudo npm i npm@latest -g</code></li></ul><h3 id="hexo界面操作"><a href="#hexo界面操作" class="headerlink" title="hexo界面操作"></a>hexo界面操作</h3><p>在使用过程中，需要创建markdown文件，编辑内容后再发布上去。整个过程比较繁琐，后来发现了<code>hexo-admin-qiniu</code>插件，执行<code>hexo s -d</code>后直接访问<code>http://localhost:4000/admin</code>进行界面化操作，创建/编辑文章、创建分类、粘贴图片（可直接上传到七牛云）、一键发布都是可以的，可以愉快的玩耍啦~~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本以为可以轻轻松松的把静态博客搭建起来，但还是踩到了不少坑，这里主要记录一下遇到的大坑。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo Start Blog</title>
    <link href="https://dongme.site/2018/05/11/hello-world/"/>
    <id>https://dongme.site/2018/05/11/hello-world/</id>
    <published>2018-05-11T08:54:00.000Z</published>
    <updated>2018-08-29T16:10:58.308Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="hexo" scheme="https://dongme.site/categories/hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>linux 常用命令</title>
    <link href="https://dongme.site/2017/03/16/linuxexprt/"/>
    <id>https://dongme.site/2017/03/16/linuxexprt/</id>
    <published>2017-03-16T15:15:00.000Z</published>
    <updated>2018-08-29T16:10:58.309Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ombpxfki1.bkt.clouddn.com/14898214187343ye65vbk.png?imageslim" alt="paste image"><br>在开发运维当中，一些基本的 linux 命令还是要掌握一些的<br><a id="more"></a></p><h3 id="命令基本格式"><a href="#命令基本格式" class="headerlink" title="命令基本格式"></a>命令基本格式</h3><p>[root@localhost ~]#<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">其中：root   当前登录用户</span><br><span class="line"> localhost 主机名</span><br><span class="line">     ~ 当前所在目录（家目录）</span><br><span class="line">     # 超级用户的提示符</span><br><span class="line">   普通用户的提示符是 `$`</span><br><span class="line">命令 [选项] [参数]  注意：a.个别不遵循 b.多个选项可以写在一起  c.简化选项与完整选项 -a等于--all</span><br></pre></td></tr></table></figure></p><h3 id="查询目录中的内容ls"><a href="#查询目录中的内容ls" class="headerlink" title="查询目录中的内容ls"></a>查询目录中的内容ls</h3><pre><code>ls [选项] [文件或目录]选项：-a 显示所有文件，包括隐藏文件-l 显示详细信息-d 查看目录的属性-h 人性化显示文件大小-i 显示inode     每个文件都有id号  查找时根据id查找-rw-r--r--.  22 root root 4096 7月  27 22:12 var第一字符代表文件类型：-代表文件 d 代表目录 | 代表软连接文件  总共有七种文件类型主要掌握三种第一位除外，每三个一组    rw- :u所有者  r--:g所属组  r--:o其它人字母含义：r读  w写 x执行最后一个点：ACL权限22：引用计数root:用户root:组4096：代表文件大小为4096字节  可以规范化显示大小 ls -lh  h可以显示kb</code></pre><h3 id="文件处理命令"><a href="#文件处理命令" class="headerlink" title="文件处理命令"></a>文件处理命令</h3><h4 id="目录处理命令"><a href="#目录处理命令" class="headerlink" title="目录处理命令"></a>目录处理命令</h4><h5 id="建立目录"><a href="#建立目录" class="headerlink" title="建立目录"></a>建立目录</h5><pre><code>mkdir -p [目录名]-p 递归创建   递归创建意思是 一级一级往下创建目录 直到最底层</code></pre><h5 id="切换目录命令"><a href="#切换目录命令" class="headerlink" title="切换目录命令"></a>切换目录命令</h5><pre><code>cd [目录]简化操作：cd ~    进入当前用户的家目录cd      进入当前用户的家目录 cd -    进入上次目录cd ..    进入上一级目录cd .    进入当前目录</code></pre><h5 id="pwd-显示当前用户所在位置"><a href="#pwd-显示当前用户所在位置" class="headerlink" title="pwd     显示当前用户所在位置"></a>pwd     显示当前用户所在位置</h5><h5 id="tab键-命令或文件或目录补全"><a href="#tab键-命令或文件或目录补全" class="headerlink" title="tab键 命令或文件或目录补全"></a>tab键 命令或文件或目录补全</h5><h5 id="删除空目录"><a href="#删除空目录" class="headerlink" title="删除空目录"></a>删除空目录</h5><pre><code>rmdir [目录名]</code></pre><h5 id="删除文件或目录"><a href="#删除文件或目录" class="headerlink" title="删除文件或目录"></a>删除文件或目录</h5><pre><code>rm -rf [文件或目录]选项：-r 删除目录-f 强制   </code></pre><h4 id="文件处理命令-1"><a href="#文件处理命令-1" class="headerlink" title="文件处理命令"></a>文件处理命令</h4><h4 id="链接命令"><a href="#链接命令" class="headerlink" title="链接命令"></a>链接命令</h4><pre><code>a.硬链接创建命令：  ln 文件  文件硬连接名[.hard]拥有相同的i节点和存储block块，可以看作同一个文件可通过i节点识别  ls -i 文件1 文件2(硬链接)不能跨分区不能针对目录使用b.软连接创建命令：ln -s 文件 文件软连接名[.soft]类似windows快捷方式拥有自己的i节点和block块，但数据块中存储源文件的文件名和i节点lrwxrwxrwx  l软连接修改任意一个都改变</code></pre><h3 id="文件搜索命令"><a href="#文件搜索命令" class="headerlink" title="文件搜索命令"></a>文件搜索命令</h3><h4 id="locate搜索命令"><a href="#locate搜索命令" class="headerlink" title="locate搜索命令"></a>locate搜索命令</h4><pre><code>locate 文件名在后台数据库中搜索文件名，搜索速度较快，只能通过文件名搜索/var/lib/mlocatelocate命令搜索的后台数据库 一般一天一更新  可通过updatedb命令手动更新locate搜索按照 /etc/updatedb.conf 配置规则进行搜索</code></pre><h4 id="命令搜索命令whereis-和-which"><a href="#命令搜索命令whereis-和-which" class="headerlink" title="命令搜索命令whereis 和 which"></a>命令搜索命令whereis 和 which</h4><pre><code>shell中的内置命令不能使用(1) whereis 命令名#搜索命令所在路径及帮助文档所在位置选项：-b：只查找可执行文件-m:只查找帮助文件(2)which 命令名#搜索命令所在路径及显示命令的别名</code></pre><h4 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h4><pre><code>find [搜索范围] [搜索条件]#搜索指定范围的文件如：find / -name install.log#避免大范围搜索，会非常消耗系统资源#find 在系统中搜索指定文件名的文件，默认完整匹配；若模糊匹配，要使用通配符*匹配任意内容?匹配任意一个字符[]匹配中括号内的字符find /root -iname install.log #-iname不区分大小写find /root -user root#按照所有者搜索文件find /root -nouser#搜索没有所有者的文件 即垃圾文件find /var/log/ -mtime +10#查找10天前修改的文件-10 10天内10 10天当天+10 10天前actime 文件访问的时间ctime    文件创建的时间mtime    修改文件内容find . -size 25k#查找文件大小是25kb的文件-25k    小于25kb的文件25k     等于25kb的文件+25k    大于25kb的文件find . inum 262422 #查找i节点是262422的文件find /ect -size +20k -a -size  -50k#查找etc目录下 大于20kb并且小于50kb的文件-a and 逻辑与-o or   逻辑或find /ect -size +20k -a -size  -50k -exec ls -lh {}\;#查找etc目录下 大于20kb并且小于50kb的文件，并显示详细信息#exec/-ok 命令 ｛｝\;固定格式；对搜索结果执行操作；</code></pre><h4 id="搜索字符串命令"><a href="#搜索字符串命令" class="headerlink" title="搜索字符串命令"></a>搜索字符串命令</h4><pre><code>grep [选项] 字符串 文件名#在文件中匹配符合条件的字符串选项：-i 忽略大小写      -v 排除指定字符串</code></pre><h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><h4 id="man帮助命令"><a href="#man帮助命令" class="headerlink" title="man帮助命令"></a>man帮助命令</h4><pre><code> man 命令#获取指定命令的帮助执行man命令之后可输入 /content  查询contentman的级别1:查看命令的帮助2：查看可被内核调用的函数的帮助3：查看函数和函数库的帮助4：查看特殊文件的帮助(主要是/dev目录下的文件)5：查看配置文件的帮组6：查看游戏的帮助7：查看其它杂项的帮助8：查看系统管理员可用命令的帮助9：查看和内核相关文件的帮助man -f 命令名#查看某个命令有哪个级别的帮助该命令相当于：whatis 命令举例：man 5 passwdman 4 nullman -8 ifconfigman -k 命令相当于apropos 命令#查看和命令相关的所有帮助例如：apropos passwd</code></pre><h4 id="其它帮助"><a href="#其它帮助" class="headerlink" title="其它帮助"></a>其它帮助</h4><pre><code>命令 --help #获取命令选项的帮助例如：ls --helpshell内部帮助命令help shell内部命令#获取shell内部命令的帮助例如： whereis cd#确定是否是shell内部命令  --找不到执行路径的就是内部命令help cd#获取内部命令帮助</code></pre><h3 id="压缩命令"><a href="#压缩命令" class="headerlink" title="压缩命令"></a>压缩命令</h3><pre><code>linux常用压缩格式 .zip .gz  .bz2  .tar.gz  .tar.bz2</code></pre><h4 id="zip格式压缩"><a href="#zip格式压缩" class="headerlink" title=".zip格式压缩"></a>.zip格式压缩</h4><pre><code>zip  压缩文件名 源文件#压缩文件zip -r 压缩文件名 源目录#压缩目录unzip 压缩文件#解压缩.zip文件</code></pre><h4 id="gz格式压缩"><a href="#gz格式压缩" class="headerlink" title=".gz格式压缩"></a>.gz格式压缩</h4><pre><code>gzip 源文件#压缩为.gz格式的压缩文件，源文件会消失gzip -c 源文件 &gt; 压缩文件#压缩为.gz格式，源文件保留例如：gzip -c cangls &gt; cangls.gzgzip -r 目录#压缩目录下所有的子文件,单个，但是不能压缩目录gzip -d 压缩文件#解压缩文件或gunzip 压缩文件#解压缩文件</code></pre><h4 id="bz2格式压缩"><a href="#bz2格式压缩" class="headerlink" title=".bz2格式压缩"></a>.bz2格式压缩</h4><pre><code>bzip2 源文件#压缩为.bz2格式，不保留源文件bzip2 -k 源文件#压缩之后保留源文件注意：bzip2命令不能压缩目录bzip2 -d 压缩文件#解压缩，-k保留压缩文件或bunzip2 压缩文件，-k 保留压缩文件</code></pre><h4 id="打包命令tar"><a href="#打包命令tar" class="headerlink" title="打包命令tar"></a>打包命令tar</h4><pre><code>tar -cvf 打包文件名 源文件选项：-c:打包-v:显示过程-f:指定打包后的文件名例如：tar -cvf longzls.tar longzlstar -xvf 打包文件名选项：    -x:解打包例如：tar -xvf longzls.tar</code></pre><h4 id="tar-gz压缩格式"><a href="#tar-gz压缩格式" class="headerlink" title=".tar.gz压缩格式"></a>.tar.gz压缩格式</h4><pre><code>其实就是先打包为.tar格式，再压缩为.gz格式tar -zcvf 压缩包名.tar.gz 源文件 选项：    -z:压缩为.tar.gz格式tar -zxvf 压缩包名.tar.gz     选项：    -x:解压缩.tar.gz格式</code></pre><h4 id="tar-bz2压缩格式"><a href="#tar-bz2压缩格式" class="headerlink" title=".tar.bz2压缩格式"></a>.tar.bz2压缩格式</h4><pre><code>其实就是先打包为.tar格式，再压缩为.bz2格式tar -jcvf 压缩包名.tar.bz2 源文件 选项：    -z:压缩为.tar.bz2格式tar -jxvf 压缩包名.tar.bz2选项：    -x:解压缩.tar.bz2格式</code></pre><h4 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h4><pre><code>(1)指定解压缩位置tar -zxvf 压缩包名.tar.gz -c /tmp/选项：    -c:指定解压缩的具体位置(2)压缩多个文件,并指定压缩文件所在位置tar -zcvf /tmp/test.tar.gz  jp a.cfg#将jp文件夹及a.cfg文件压缩到/tmp/test.tar.gz(3)只查看不解压tar -ztvf  test.tar.gz#查看压缩文件test.tar.gz的内容 选项-t代表查看压缩文件的内容</code></pre><h3 id="关机与重启命令"><a href="#关机与重启命令" class="headerlink" title="关机与重启命令"></a>关机与重启命令</h3><h4 id="shutdown命令"><a href="#shutdown命令" class="headerlink" title="shutdown命令"></a>shutdown命令</h4><pre><code>shutdown [选项] 时间选项-c:取消前一个关机命令-h:关机-r:重启 时间可以是now就是立刻重启例如：shutdown -r 05:30 &amp;    #在凌晨五点半重启电脑，&amp;的意思是放后台执行，前台仍可以进行其它操作    shutdown -c    #取消上面的重启命令</code></pre><h4 id="其它关机命令"><a href="#其它关机命令" class="headerlink" title="其它关机命令"></a>其它关机命令</h4><pre><code>haltpoweroffinit 0这几个没有shutdown命令安全，shutdown是保存数据库再做操作，而这几个就不一定保存数据</code></pre><h4 id="其它重启命令"><a href="#其它重启命令" class="headerlink" title="其它重启命令"></a>其它重启命令</h4><pre><code>rebootinit 6reboot 重启也是比较安全的，但init 6就不安全</code></pre><h4 id="系统运行级别"><a href="#系统运行级别" class="headerlink" title="系统运行级别"></a>系统运行级别</h4><pre><code>0：关机1：单用户(类似windows中安全模式)2：不完全多用户，不含NFS服务(文件共享服务)3：完全多用户4：未分配5：图形界面6：重启查看系统运行级别runlevel显示：N 3        #N代表上一个运行级别为空，当前运行级别为3修改系统登录时默认运行级别：centos6以前：vi /ect/inittab中修改 id:3:initdefault:</code></pre><h4 id="退出登录命令"><a href="#退出登录命令" class="headerlink" title="退出登录命令"></a>退出登录命令</h4><pre><code>logout</code></pre><h3 id="其它常用命令"><a href="#其它常用命令" class="headerlink" title="其它常用命令"></a>其它常用命令</h3><h4 id="挂载命令"><a href="#挂载命令" class="headerlink" title="挂载命令"></a>挂载命令</h4><pre><code>(1)查询与自动挂载mount#查询系统中已经挂载的设备mount -a#依据配置文件/etc/fstab的内容，自动挂载(2)、挂载命令格式mount [-t 文件系统] [-o 特殊选项] 设备文件名  挂载点选项：-t 文件系统：加入文件系统类型来指定挂载待类型，可以ext3、ext4、iso9660(挂载光盘使用d文件系统)等-o 特殊选项：可以指定挂载待额外选项 自行百度mount -o remount,noexec /home/#remount重新挂载，noexec是挂载的系统没有执行权限，没写文件系统是因为/home/是默认挂载好的，已经知道文件系统类型(3)、挂载光盘mnt 一般是挂载u盘待目录 media 一般是挂载光盘待目录misc 一般是挂载磁带机的目录既然是一般，当然也可根据习惯挂载其它目录下面我们在mnt下创建cdrom挂载光盘 创建usb挂载U盘mkdir /mnt/cdrom#创建光盘挂载点mount [-t iso9660]  /dev/sr0/  /mnt/cdrom#挂载光盘 注意/dev/sr0 其中sr0是光盘的设备文件名 /dev/cdrom是/dev/sr0的软连接可以去/mnt/cdrom下挂载的内容(4)、卸载命令umount 设备文件名或挂载点umount /mnt/cdrom/或umount /dev/sr0/#卸载光盘注意：为了防止出错，用完后一定要卸载(5)、挂载U盘因为u盘设备文件名不固定，先查看设备文件名fdisk -l #查看U盘设备文件名mkdir /mnt/usb#创建U盘挂载点mount -t vfat /dev/sdb1 /mnt/usb# vfat 代表文件系统为fat32(单个文件最大4G) /dev/sdb1为U盘设备文件名(以查到的为准)注意：Linux 默认不支持NTFS系统</code></pre><h4 id="用户登录查看命令"><a href="#用户登录查看命令" class="headerlink" title="用户登录查看命令"></a>用户登录查看命令</h4><pre><code>(1)w  [用户名]#查看指定用户登录情况w#查看所有登录用户结果：08:48:09 up 16:51,  2 users,  load average: 0.00, 0.01, 0.05USER     TTY        LOGIN@   IDLE   JCPU   PCPU WHATroot     tty1       六17   15:07m  0.07s  0.07s -bashroot     pts/0     07:22    1.00s  0.24s  0.03s w#其中：    08:48:09 up 16:51 系统到08:48:09运行了16小时51分钟    2 users   总共两个用户登录    load average  系统在1分钟 5分钟 和15分钟占据的负载压力    USER:登录用户名    TTY:登录终端 tty1代表本机登陆 pts/0代表远程终端    FROM:从哪个ip地址登录；    LOGIN@:登录时间；    IDLE：用户闲置时间；    JCPU：指的是和该终端链接的所有进程占用的时间。这个时间里并不包括过去的        后台作业时间,但却包括当前正在运行的后台作业所占用的时间；    PCUP:是指当前进程所占用的时间    WHAT:当前正在运行的命令(2)who [用户名]功能与w命令相似who#命令输出：-用户名-登录终端-登录时间(登录来源ip地址)(3)last查询当前登录和过去登录的用户信息last命令默认读取/var/log/wtmp文件数据last#命令输出：-用户名-登录终端-登录ip-登录时间-退出时间(在线时间)(4)lastlog查看系统所有用户最后登录时间lastlog命令默认读取/var/log/lastlog文件数据lastlog#命令输出：-用户名-登录终端-登录ip-最后一次登录时间</code></pre><h3 id="shell基础"><a href="#shell基础" class="headerlink" title="shell基础"></a>shell基础</h3><h4 id="shell概述"><a href="#shell概述" class="headerlink" title="shell概述"></a>shell概述</h4><pre><code>(1)、shell概述*shell 是一个命令行解释器，它为用户提供了一个向linux内核发送请求以便    运行程序待界面系统程序，用户可以通过shell启动、挂起、停止甚至编写    一些程序*shell还是一个功能相当强大的编程语言，在shell中可以直接调用linux系统命令(2)、shell分类*Bourne Shell:1979开始使用，Bourne Shell的主文件名为sh  基本已淘汰*C Shell:主要在BSD版的Unix系统中使用，其语法和c语言相似*Shell 两种主要语法有Bourn和C，两种语法不兼容。    Bourn家族主要包括sh、ksh、Bash(linux标准shell)、psh、zsh;C家族主要有：csh、tcshecho $SHELL#查看系统使用的shell版本 echo 代表输出 $ 调用变量  SHELL为shell的变量名  (3)、查看系统支持shell    cat /etc/shells    #查看兼容的所有shell版本    切换shell输入相应shell版本名称即可    sh    #将shell版本切换为sh    exit退出子shell</code></pre><h4 id="脚本执行方式"><a href="#脚本执行方式" class="headerlink" title="脚本执行方式"></a>脚本执行方式</h4><pre><code>(1)echo 输出命令echo [选项] [输出内容]选项：-e:支持反斜线控制的字符转换echo &quot;Today is sunday.Where we go?&quot;#在屏幕输出 Today is sunday.Where we go?注意：有空格就要用引号echo -e &quot;Today is\b sunday.Where we go?&quot;#在屏幕输出 Today i sunday.Where we go?少了一个s支持的字符转换：\a 输出警告音\b 退格键，也就是向左删除键\n 换行键\r 回车键\t 制表符 tab键\v 垂直制表符\0nnn 按照八进制ASCII码表输出字符。其中0为数字零，nnn是三位八进制数\xhh 按照16进制ASCII码表输出字符。其中hh是两位十六进制数echo -e &quot;\e[1;31m 嫁人就要嫁凤姐\e[0m&quot;#以红色字体显示：嫁人就要嫁凤姐 \e[1; 是开启颜色 31m=红色 \e[0m是关闭颜色显示#输出颜色    30m=黑色 31=红色 32m=绿色 33m=黄色    34m=蓝色 35m=洋红 36m=青色 37m=白色  (2)第一个脚本vim hello.sh#创建文件hello.sh在hello.sh中输入下面内容：    #!/bin/bash    #The first program    echo  -e &quot;\e[1;31m天上掉下个林妹妹\e[0m&quot;注意：#!/bin/bash 这句比较特殊不是注释  声明该脚本为bash脚本 必须添加 不然复杂脚本可能报错(3)执行一个脚本    a.赋予执行权限，直接运行        chmod 755 hello.sh        ./hello.sh    b. 通过bash调用执行脚本        bash hello.sh</code></pre><h4 id="bash的基本功能"><a href="#bash的基本功能" class="headerlink" title="bash的基本功能"></a>bash的基本功能</h4><pre><code>(1)命令别名与快捷键alias#查看系统中所有命令的别名alias 别名=&apos;原命令&apos;#设定命令别名(重启失效)vi ~/.bashrc#修改家目录下的bashrc文件 使别名永久生效 默认重新登陆生效  也可使用 source .bashrc命令使立即生效unalias 别名#删除别名(重启失效) 若要永久生效 删除bashrc中定义的别名并使用source .bashrc命令使其不用重新登陆就可以立即生效命令生效顺序：*第一顺位 使用绝对路径或相对路径执行命令*第二顺位 执行别名*第三顺位 执行bash的内部命令*第四顺位 从$PATH中查找到的第一个命令快捷键：ctrl+c    强制终止当前命令ctrl+l  清屏ctrl+a  光标移动到命令的首行ctrl+e  光标移动到命令的行尾ctrl+u  从光标所在的位置删除到行首ctrl+z  把命令放入后台ctrl+r  在历史命令中搜索(2)历史命令 history [选项] [历史命令保存文件] 选项: -c ：清空历史命令 -w ：把缓存中的历史命令写入到历史命令保存文件~/.bash_history 历史命令的调用 *使用上下箭头调用以前的命令 *使用!n重复执行第n条历史命令 *使用!!重复执行上一条命令 *使用&quot;!字串&quot; 重复执行最后一条以该字串开头的命令 命令与文件补全*在bash中，按&quot;Tab&quot;键自动进行补全(3)输出重定向    &lt;1&gt;标准输入输出    设备            设备文件名            文件描述符            类型            键盘               /dev/stdin                0                标准输入    显示器            /dev/sdtout                1                标准输出    显示器            /dev/sdterr                2                标准错误输出     &lt;2&gt;输出重定向    类型                        符号                    作用    标准输出重定向                命令&gt;文件                以覆盖的方式，把命令的正确输出输出到指定的文件或设备当中    标准输出重定向                命令&gt;&gt;文件                以追加的方式，把命令的正确输出输出到指定的文件或设备当中    标准错误输出重定向            错误命令 2&gt;文件            以覆盖的方式，把命令的正确输出输出到指定的文件或设备当中    标准错误输出重定向            错误命令 2&gt;&gt;文件         以追加的方式，把命令的正确输出输出到指定的文件或设备当中    正确输出和错误输出同时保存    命令&gt;文件 2&gt;&amp;1             以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中    正确输出和错误输出同时保存    命令&gt;&gt;文件 2&gt;&amp;1         以追加的方式，把正确输出和错误输出都保存到同一个文件当中    正确输出和错误输出同时保存    命令 &amp;&gt;文件             以覆盖的方式，把正确输出和错误输出都保存到同一个文件当中    正确输出和错误输出同时保存    命令 &amp;&gt;&gt;文件             以追加的方式，把正确输出和错误输出都保存到同一个文件当中    正确输出和错误输出同时保存    命令&gt;&gt;文件1 2&gt;&gt;文件2    把正确的输出追加到文件1中，把错误的输出追加到文件2中    #上面的2代表文件描述符 意思是当出错时 把错误信息输出到文件  并且2后面不能有空格    ls &amp;&gt;/dev/null    #将执行结果直接丢弃 既不显示在屏幕上，也不保存到文件中  null相当于windows系统中垃圾回收站(4)输入重定向    wc [选项][文件名]    选项:    -c: 统计字节数    -w: 统计单词数    -l: 统计行数    输入wc    输入sdfds    按ctrl+d 统计行数 单词数 字符数     *命令&lt;文件     #把文件作为命令的输入    *命令&lt;&lt;标识符(5)管道符&lt;1&gt;多命令顺序执行 多名令执行符                    格式                        作用    ;                        命令1;命令2                多个命令顺序执行，命令之间没有任何逻辑关系    &amp;&amp;                        命令1&amp;&amp;命令2            逻辑与；当命令1正确执行，命令2才会执行；当命令1不正确，命令2不会执行    ||                        命令1||命令2            逻辑或；当命令1执行不正确，命令2才会执行；当命令1正确，命令2不会执行&lt;2&gt;管道符    命令格式：    命令1 | 命令2    #命令1的正确输出作为命令2的操作对象    netstat -an | grep ESTABLISHED    #从netstat -an执行结果中搜索ESTABLISHED(6)通配符&lt;1&gt; 通配符            通配符                                        作用              ？                                        匹配一个任意字符              *                                            匹配0个或任意多个字符，也就是可以匹配任意内容              []                                        匹配括号中任意一个字符。例如[abc]代表匹配a或b或c              [-]                                        匹配括号中任意一个字符，-代表范围。例：[a-z]代表匹配一个小写字母              [^]                                        逻辑非，表示匹配不是中括号内的一个字符。例如：[^0-9]代表匹配一个不是数字的字符&lt;2&gt;Bash中其它特殊符号</code></pre><h3 id="VIM文本编辑器"><a href="#VIM文本编辑器" class="headerlink" title="VIM文本编辑器"></a>VIM文本编辑器</h3><h4 id="VIM文本编辑器概述"><a href="#VIM文本编辑器概述" class="headerlink" title="VIM文本编辑器概述"></a>VIM文本编辑器概述</h4><pre><code>*vi---&gt;VIM VIM是VI升级版*VIM相对VI做了哪些提升    -VIM支持多级撤销(u)    -VIM可以跨平台运行 vi只能运行在以unix为内核的系统中 VIM可以运行在其它平台(如linux)    -VIM支持语法高亮    -VIM支持图形界面</code></pre><h4 id="VIM操作模式和命令模式"><a href="#VIM操作模式和命令模式" class="headerlink" title="VIM操作模式和命令模式"></a>VIM操作模式和命令模式</h4><pre><code>*command mode         -命令模式*insert mode          -插入模式*last line mode        -底行模式(尾行、末行)vim abc#打开abc，若没有创建abc并打开首先进入命令模式---&gt;i键进入插入模式---&gt;esc键进入底行模式 :wq 保存退出     :q或:q! 不保存退出命令模式下 dd表示删除一行vim +[i] abc#打开abc 并定位到最后一行(第i行)vim +/alvin abc#打开abc，并定位到alvin第一次出现的地方 n可以在多个alvin之间切换vim aa bb cc#若不存在创建多个文件，若存在打开多个文件  底行模式下输入n切换到下一个文件输入prev或N切换到上一个文件</code></pre><h4 id="底行模式和命令模式常用命令"><a href="#底行模式和命令模式常用命令" class="headerlink" title="底行模式和命令模式常用命令"></a>底行模式和命令模式常用命令</h4><pre><code>(1)底行模式常用命令(2)命令模式常用命令    -h 光标左移    -j 光标下移    -k 光标上移    -l 光标右移    -ctrl+f 向下翻页(front)    -ctrl+b 向上翻页(back)    -ctrl+d 向下翻半页(down)    -ctrl+u 向上翻半页(up)    -dd     删除光标所在一行    -o         在光标所在位置下方插入一行并切换到插入模式    -yy        复制光标所在的一行    -p        在光标所在行的下方粘贴</code></pre><h3 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h3><h4 id="磁盘管理基本命令"><a href="#磁盘管理基本命令" class="headerlink" title="磁盘管理基本命令"></a>磁盘管理基本命令</h4><pre><code>df 查看磁盘分区使用情况    -l 仅显示本地磁盘(默认)    -a 显示所有文件系统的磁盘使用情况，包含比如/proc/    -h 以1024进制计算最合适的单位显示磁盘容量    -H 以1000进制计算最合适的单位显示磁盘容量    -T 显示磁盘分区类型    -t 显示指定文件系统的磁盘分区    -x 不显示指定文件系统的磁盘分区du 统计磁盘上的文件大小    -b 以byte为单位统计文件    -k 以kb为单位统计文件    -m 以mb为单位统计    -h 以1024进制计算最合适的单位显示磁盘容量    -H 以1000进制计算最合适的单位显示磁盘容量    -s 指定统计目标 跟参数</code></pre><h4 id="硬盘分区和格式化概述"><a href="#硬盘分区和格式化概述" class="headerlink" title="硬盘分区和格式化概述"></a>硬盘分区和格式化概述</h4><pre><code>在服务器挂载新的硬盘</code></pre><h4 id="在VM虚拟机中添加硬盘"><a href="#在VM虚拟机中添加硬盘" class="headerlink" title="在VM虚拟机中添加硬盘"></a>在VM虚拟机中添加硬盘</h4><pre><code>场景:硬盘空间不够用 需添加新硬盘</code></pre><h4 id="MBR分区-已经过时"><a href="#MBR分区-已经过时" class="headerlink" title="MBR分区(已经过时)"></a>MBR分区(已经过时)</h4><pre><code>-主分区不超过4个-单个分区容量最大2TBfdisk -l #查看硬盘大小及分区情况        fdisk 未分区硬盘文件名#进入分区模式输入n 新增一个分区---&gt;选择主分区或者扩展分区---&gt;输入分区编号(1-4)---&gt;指定扇区开始位置----&gt;指定扇区结束位置或指定分区大小</code></pre><h4 id="GPT分区"><a href="#GPT分区" class="headerlink" title="GPT分区"></a>GPT分区</h4><pre><code>-主分区个数&quot;几乎&quot;没有限制(最多支持128个主分区)-单个分区容量&quot;几乎&quot;没有限制(最多支持18EB)1EB=1024PB,1PB=1024TBparted#启动分区工具select /dev/sdc#切换到待分区的硬盘mklable  gpt(或者msdos  msdos就是mbr)#指定要用的分区表print#查看当前硬盘分区详情print all#查看所有硬盘分区详情交互方式添加分区：mkpart#添加分区添加分区名称---&gt;指定分区文件系统类型默认为ext2---&gt;指定开始MB 一般从1MB开始 预留1M左右4k对齐--&gt;指定结束MB---&gt;print查看目前分区状况命令模式添加分区(不同于上面的方式)mkpart test 2000 3000#添加名称为test的分区  指定MB区间为2000-3000MBrm n#删除编号为n的分区unit GB#默认分区大小单位MB,使用unit命令指定分区单位为GB若添加的分区重叠：会给出警告，系统给出建议性提示分区大小</code></pre><h4 id="分区的格式化"><a href="#分区的格式化" class="headerlink" title="分区的格式化"></a>分区的格式化</h4><pre><code>mkfs.ext3 /dev/sdb1#格式化 sdb1硬盘 指定系统文件类型为ext3mkfs -t dext4 /dev/sdb2#为另一种格式化方式 将sdb2格式化为ext4</code></pre><h4 id="挂载分区"><a href="#挂载分区" class="headerlink" title="挂载分区"></a>挂载分区</h4><pre><code>分区--&gt;格式化--&gt;挂载  经过这个过程才能使用硬盘mkdir -p /mnt/alvin#创建挂载目录mount /dev/sdb1  /mnt/alvin#挂载sdb1硬盘 指定挂载点为alvinumount /mnt/alvin#卸载挂载  参数为挂载点mount挂载重启挂载失效解决方法如下：vim + /etc/fstab#在fstab末添加 ： /dev/sdb1     /mnt/alvin  ext3  defaults  0   0该方法挂载永久有效</code></pre><h4 id="swap-交换分区"><a href="#swap-交换分区" class="headerlink" title="swap 交换分区"></a>swap 交换分区</h4><pre><code>创建交换分区步骤：第一，建立一个普通的linux分区            第二，修改分区类型的16进制编码第三，格式化交换分区第四，启用交换分区fdisk /dev/sdb#查看硬盘大小及分区情况输入t--&gt;输入分区编号---&gt;指定交换分区hex code编号--&gt;输入w保存mkswap /dev/sdb6#格式化交换分区swapon /dev/sdb6#启用交换分区free#查看swap加载状况swapoff /dev/sdb6#停止交换分区</code></pre><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><h4 id="用户和用户组的概念"><a href="#用户和用户组的概念" class="headerlink" title="用户和用户组的概念"></a>用户和用户组的概念</h4><pre><code>用户：使用操作系统的人用户组：具体相同权限的一组用户* /etc/group 存储当前系统中所有用户组信息    -Group:            x            :  123  :abc,def,xyz    -组名称：    组密码占位符 ： 组编号  ：组中用户名列表说明：root组编号为0；1-499为系统预留编号；用户手动创建的组编号从500开始包括500* /etc/gshadow 存储当前系统中用户组的密码信息    -Group:            *            :  123  :abc,def,xyz    -组名称：    组密码 ： 组管理者  ：组中用户名列表    说明：组密码 为* 或 ！说明密码为空* /etc/passwd 存储当前系统中所有用户的信息    -user :            x        :    123  :   456    :  xxxxxxxxxx    :    /home/user    :  /bin/bash    -用户名：密码占位符        ：用户编号：用户组编号：用户注释信息  ：用户主目录        ：shell类型说明：root用户编号为0* /etc/shadow 存储当前系统中所有用户密码的信息    -user :            x        :::::      -用户名：密码(单向加密)        ：：：：：：</code></pre><h4 id="用户和用户组的基本命令"><a href="#用户和用户组的基本命令" class="headerlink" title="用户和用户组的基本命令"></a>用户和用户组的基本命令</h4><pre><code>groupadd group1#添加用户组group1groupmod -n group2 group1#将组名由group1修改为group2groupmod -g 668 group2#将用户组group2的编号修改为668groupadd -g 888 group3#创建用户组group3，并指定组编号为888groupdel group2#删除用户组group2，要先删除组内用户useradd -g group1 alvin#创建用户alvin，并分配用户组为group1useradd -g group1 alex#创建用户alex，并分配用户组为group1useradd -d /home/xxx mark#创建用户mark，并创建个人文件夹为home下的xxx alvin和alex没有指定，则默认在home下创建同名个人文件夹注意：若创建的用户没有手动分配用户组，则自动创建同名用户组 新建用户属于该组usermod -c thisisalvin alvin#修改用户alvin注释信息为thisisalvinusermod -l alvin alex#将用户名alex修改为alvinusermod -d /home/alvin alvin#修改用户alvin的个人文件夹路径为/home/alvinusermod -g group1 alvin#修改alvin所属用户组为group1userdel alex#删除用户alex 不会删除个人文件夹userdel -r alex#删除用户alex 同时删除个人文件夹touch /etc/nologin#创建空文件，禁止除root外的用户登录服务器</code></pre><h4 id="用户和用户组进阶命令"><a href="#用户和用户组进阶命令" class="headerlink" title="用户和用户组进阶命令"></a>用户和用户组进阶命令</h4><pre><code>passwd -l alex#锁定账户alexpasswd -u alex#解锁账户alexpasswd -d alex#清除alex的登录密码主要组和附属组：    用户可以同时属于多个组    -一个主要组    -多个附属组gpasswd -a alex group2#将alex添加到附属组group2newgrp group2#alex登录系统执行该命令，将当前组切换到附属组group2gpasswd -d alex group2#将alex用户从附属组group2中删除useradd -g group1 -G group2,group3......  temp#在创建用户temp的同时指定主要组为group1，附属组为group2,group3......gpasswd group1#指定用户组密码</code></pre><h4 id="其它命令"><a href="#其它命令" class="headerlink" title="其它命令"></a>其它命令</h4><pre><code>su username#切换用户whoami#显示登陆用户名id 用户名 #显示指定用户信息，包括用户编号、用户名、主要组编号，附属组列表groups 用户名 #显示用户所在的所有组chfn 用户名 #设置用户资料，依次输入用户资料finger 用户名 #显示用户详细资料</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ombpxfki1.bkt.clouddn.com/14898214187343ye65vbk.png?imageslim&quot; alt=&quot;paste image&quot;&gt;&lt;br&gt;在开发运维当中，一些基本的 linux 命令还是要掌握一些的&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="https://dongme.site/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>spring cloud eureka</title>
    <link href="https://dongme.site/2017/03/09/spring_cloud_eureka/"/>
    <id>https://dongme.site/2017/03/09/spring_cloud_eureka/</id>
    <published>2017-03-09T10:18:00.000Z</published>
    <updated>2018-08-29T16:10:58.310Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ombpxfki1.bkt.clouddn.com/14890644713327al2lpp0.png?imageslim" alt="paste image"><br>Eureka 是 Netflix 开发的服务发现组件，基于REST服务。Spring Cloud 将其集成在其子项目 spring-cloud-netflix 中，实现 Spring Cloud 服务发现功能。目前最新版本 1.6.1。Eureka2.0 还在开发中。</p><blockquote><p>Eureka Github:<a href="https://github.com/Netflix/eureka" target="_blank" rel="noopener">https://github.com/Netflix/eureka</a></p></blockquote><a id="more"></a><h3 id="Region-和-Zone-的理解"><a href="#Region-和-Zone-的理解" class="headerlink" title="Region 和 Zone 的理解"></a>Region 和 Zone 的理解</h3><p><img src="http://ombpxfki1.bkt.clouddn.com/14890562011082zwga18r.png?imageslim" alt="paste image"></p><p>Region 和 Zone 都是AWS中的概念。脱离AWS，我们可以简单的将Region理解为集群，Zone 理解为机房。这样就很清晰了，一个Eureka集群部署在 Zone1 和 Zone2 两个机房中。Spring Cloud Region 默认值是<code>us-east-1</code></p><h3 id="Eureka-架构"><a href="#Eureka-架构" class="headerlink" title="Eureka 架构"></a>Eureka 架构</h3><p><img src="https://github.com/Netflix/eureka/raw/master/images/eureka_architecture.png" alt=""></p><p>上图是官方给出的架构图，大致描述了Eureka集群工作模式。</p><blockquote><p>Application Service 是服务提供者，Application Client 是服务消费者。<br>Make Remote Call 简单的理解为 RESTFULL API 调用。<br>us-east-1 为 Region, us-east-1* 为 Zone。</p></blockquote><p>可以看出Eureka有两个组件， Eureka Server 和 Eureka Client。</p><blockquote><p>Eureka Client 是一个 java 客户端。简化与 Eureka Server 的交互。<br>Eureka Server 提供服务发现的能力，各个微服务启动的时候，通过 Eureka Client 向 Eureka Server 提交注册信息（网络信息），Eureka Server 存储客户端信息。<br>微服务启动后，会周期性（默认30s）的向 Eureka Server 发送心跳续约租期，如果一定时间(默认90s)未收到微服务节点的心跳，服务端注销该微服务。<br>每个 Eureka Server 同时也是 Eureka Client，多个Eureka Server之间通过复制的方式完成服务注册表的同步。<br>Eureka Client 会缓存 Eureka Server 中的信息。即使所有的Eureka Server 节点都宕掉，服务消费者依然可以使用缓存中的信息找到服务提供者。</p></blockquote><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>Region 命名为 region1，在 region1 下定义 zone1 和 zone2 两个 zone， zone1 内有 peer1 和 peer2 两个 eureka 服务器，zone2 内有 peer3 一台服务器。 </p><p>先来看服务器application.yml配置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">server:</span><br><span class="line">  port: 1111</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  profiles: peer1</span><br><span class="line">  application:</span><br><span class="line">    name: region-eureka</span><br><span class="line"></span><br><span class="line"># 安全认证的配置</span><br><span class="line">security:</span><br><span class="line">  basic:</span><br><span class="line">    enabled: true</span><br><span class="line">  user:</span><br><span class="line">    name: alvin  # 用户名</span><br><span class="line">    password: alvin   # 用户密码</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: peer1</span><br><span class="line">    preferIpAddress: false  #使用IP注册</span><br><span class="line">  client:</span><br><span class="line">    prefer-same-zone-eureka: true</span><br><span class="line">    use-dns-for-fetching-service-urls: false #关闭dns获取服务</span><br><span class="line">    region: region1</span><br><span class="line">    availability-zones:</span><br><span class="line">      region1: zone1,zone2</span><br><span class="line">#      region2: zone3</span><br><span class="line">    serviceUrl:</span><br><span class="line">      zone1: http://alvin:alvin@peer1:1111/eureka/,http://alvin:alvin@peer2:1112/eureka/</span><br><span class="line">      zone2: http://alvin:alvin@peer3:1113/eureka/</span><br><span class="line">    register-with-eureka: true #自身实例注册到eureka</span><br><span class="line">    fetch-registry: true  # 从eureka server 拉取最新服务列表</span><br><span class="line">  server:</span><br><span class="line">    waitTimeInMsWhenSyncEmpty: 0</span><br><span class="line">    enable-self-preservation: false #设为false，关闭自我保护</span><br><span class="line">#    eviction-interval-timer-in-ms: 清除无效节点的时间间隔 默认60*1000毫秒</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">server:</span><br><span class="line">  port: 1112</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  profiles: peer2</span><br><span class="line">  application:</span><br><span class="line">    name: region-eureka</span><br><span class="line"></span><br><span class="line"># 安全认证的配置</span><br><span class="line">security:</span><br><span class="line">  basic:</span><br><span class="line">    enabled: true</span><br><span class="line">  user:</span><br><span class="line">    name: alvin  # 用户名</span><br><span class="line">    password: alvin   # 用户密码</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: peer2</span><br><span class="line">    preferIpAddress: false  #使用IP注册</span><br><span class="line">  client:</span><br><span class="line">    prefer-same-zone-eureka: true</span><br><span class="line">    use-dns-for-fetching-service-urls: false</span><br><span class="line">    region: region1</span><br><span class="line">    availability-zones:</span><br><span class="line">      region1: zone1,zone2</span><br><span class="line">#      region2: zone3</span><br><span class="line">    serviceUrl:</span><br><span class="line">      zone1: http://alvin:alvin@peer1:1111/eureka/,http://alvin:alvin@peer2:1112/eureka/</span><br><span class="line">      zone2: http://alvin:alvin@peer3:1113/eureka/</span><br><span class="line">    register-with-eureka: true</span><br><span class="line">    fetch-registry: true</span><br><span class="line">  server:</span><br><span class="line">    waitTimeInMsWhenSyncEmpty: 0</span><br><span class="line">    enable-self-preservation: false</span><br><span class="line">---</span><br><span class="line">server:</span><br><span class="line">  port: 1113</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  profiles: peer3</span><br><span class="line">  application:</span><br><span class="line">    name: region-eureka</span><br><span class="line"></span><br><span class="line"># 安全认证的配置</span><br><span class="line">security:</span><br><span class="line">  basic:</span><br><span class="line">    enabled: true</span><br><span class="line">  user:</span><br><span class="line">    name: alvin  # 用户名</span><br><span class="line">    password: alvin   # 用户密码</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: peer3</span><br><span class="line">    preferIpAddress: false  #使用IP注册</span><br><span class="line">  client:</span><br><span class="line">    prefer-same-zone-eureka: true</span><br><span class="line">    use-dns-for-fetching-service-urls: false</span><br><span class="line">    region: region1</span><br><span class="line">    availability-zones:</span><br><span class="line">      region1: zone1,zone2</span><br><span class="line">#      region2: zone3</span><br><span class="line">    serviceUrl:</span><br><span class="line">      zone1: http://alvin:alvin@peer1:1111/eureka/,http://alvin:alvin@peer2:1112/eureka/</span><br><span class="line">      zone2: http://alvin:alvin@peer3:1113/eureka/</span><br><span class="line">    register-with-eureka: true</span><br><span class="line">    fetch-registry: true</span><br><span class="line">  server:</span><br><span class="line">    waitTimeInMsWhenSyncEmpty: 0</span><br><span class="line">    enable-self-preservation: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>顺序启动三台服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java -jar demo-eureka-peer1-1.0-SNAPSHOT.jar --spring.profiles.active=peer1 &amp;</span><br><span class="line"></span><br><span class="line">java -jar demo-eureka-peer1-1.0-SNAPSHOT.jar --spring.profiles.active=peer2 &amp;</span><br><span class="line"></span><br><span class="line">java -jar demo-eureka-peer1-1.0-SNAPSHOT.jar --spring.profiles.active=peer3 &amp;</span><br></pre></td></tr></table></figure></p><p>注意事项：三个服务 spring.application.name 要设置成一样的，同时 register-with-eureka 设置为 true 。否则 eureka 服务在 General Info 中显示 unavailable-replicas 。正确显示如下图：</p><p><img src="http://ombpxfki1.bkt.clouddn.com/14896761012801gdtl29t.png?imageslim" alt="paste image"></p><p>客户端application.properties 配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=user-service</span><br><span class="line">server.port=2221</span><br><span class="line">management.context-path=/alvin</span><br><span class="line">eureka.client.region=region1</span><br><span class="line">eureka.client.availability-zones.region1=zone2</span><br><span class="line">eureka.client.service-url.zone2=http://alvin:alvin@peer3:1113/eureka/</span><br><span class="line">#eureka.client.serviceUrl.defaultZone=http://localhost:1113/eureka/</span><br><span class="line">eureka.instance.statusPageUrlPath=$&#123;management.context-path&#125;/info</span><br><span class="line">eureka.instance.healthCheckUrlPath=$&#123;management.context-path&#125;/health</span><br></pre></td></tr></table></figure></p><p>看一下其中一台eureka server，访问<code>http://peer1:1111</code> ，由于设置了安全认证，需要输入账号(alvin)和密码(alvin)，显示如下：<br><img src="http://ombpxfki1.bkt.clouddn.com/14896765122775mu94lim.png?imageslim" alt="paste image"></p><p>注意到 <code>eureka.client.use-dns-for-fetching-service-urls</code>的设置为 false ，我没通过 service url 获取服务，其实还有更优雅的方式， 通过 eureka dns 域名获取服务。还没有时间研究，待研究过后再来补全，当然欢迎实践过的朋友指点一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ombpxfki1.bkt.clouddn.com/14890644713327al2lpp0.png?imageslim&quot; alt=&quot;paste image&quot;&gt;&lt;br&gt;Eureka 是 Netflix 开发的服务发现组件，基于REST服务。Spring Cloud 将其集成在其子项目 spring-cloud-netflix 中，实现 Spring Cloud 服务发现功能。目前最新版本 1.6.1。Eureka2.0 还在开发中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Eureka Github:&lt;a href=&quot;https://github.com/Netflix/eureka&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/Netflix/eureka&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="spring cloud" scheme="https://dongme.site/categories/spring-cloud/"/>
    
    
  </entry>
  
  <entry>
    <title>java 编程规范</title>
    <link href="https://dongme.site/2017/03/01/java-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    <id>https://dongme.site/2017/03/01/java-编程规范/</id>
    <published>2017-03-01T10:25:00.000Z</published>
    <updated>2018-08-29T16:10:58.308Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ombpxfki1.bkt.clouddn.com/14886976307472ywtu72p.png?imageslim" alt="paste image"><br>为什么要规范代码？代码规范不仅提高了代码的可读性，也避免了一些隐藏bug的出现。好的代码也会让人心情愉悦，提高编程的效率。<br><a id="more"></a></p><h3 id="编程规约"><a href="#编程规约" class="headerlink" title="编程规约"></a>编程规约</h3><h4 id="命名规约"><a href="#命名规约" class="headerlink" title="命名规约"></a>命名规约</h4><ol><li><p>常量命名全部大写,单词间用下划线隔开,力求语义表达完整清楚,不要嫌名字长。</p><p> 正例：MAX_APPLE_COUNT</p><p> 反例：MAX_COUNT</p></li><li><p>抽象类命名使用 Abstract 或 Base 开头;异常类命名使用 Exception 结尾;测试类 命名以它要测试的类的名称开始,以 Test 结尾。</p></li><li><p>中括号是数组类型的一部分,数组推荐定义如下:String[] args;</p></li><li><p>POJO 类中布尔类型的变量,都不要加 is,否则部分框架解析会引起序列化错误。</p><p> 反例：定义为基本数据类型boolean isSuccess;的属性,它的方法也是isSuccess(),RPC 框架在反向解析的时候,“以为”对应的属性名称是 success,导致属性获取不到,进而抛出异常。 </p></li><li><p>【推荐】接口类中的方法和属性不要加任何修饰符号(<code>public</code> 也不要加),保持代码的简洁 性,并加上有效的 <code>Javadoc</code> 注释。尽量不要在接口里定义变量,如果一定要定义变量,肯定是与接口方法相关,并且是整个应用的基础常量。</p><p> 正例:</p><p> 接口方法签名:void f();<br><br> 接口基础常量表示:String COMPANY = “alibaba”;</p><p> 反例:</p><p> 接口方法定义:public abstract void f();<br> 说明:JDK8 中接口允许有默认实现,那么这个 default 方法,是对所有实现类都有价值的默认实现。</p></li><li><p>对于 Service 和 DAO 类,基于 SOA 的理念,暴露出来的服务一定是    接口,内部的实现类用 Impl 的后缀与接口区别。</p><p> 正例:CacheServiceImpl 实现 CacheService 接口</p></li><li><p>【参考】各层命名规约:</p><p> Service/DAO层方法命名规约</p><blockquote><p>获取单个对象的方法用get做前缀。<br>获取多个对象的方法用list做前缀。<br>获取统计值的方法用count做前缀。<br>插入的方法用save(推荐)或insert做前缀。<br>删除的方法用remove(推荐)或delete做前缀。<br>修改的方法用update做前缀。</p></blockquote><p> 领域模型命名规约</p><blockquote><p>数据对象:xxxDO,xxx即为数据表名<br>数据传输对象:xxxDTO,xxx为业务领域相关的名称<br>展示对象:xxxVO,xxx一般为网页名称<br>POJO是DO/DTO/BO/VO的统称,禁止命名成xxxPOJO</p></blockquote></li></ol><h4 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h4><ol><li><p>不允许出现任何魔法值(即未经定义的常量)直接出现在代码中。</p><p> 反例:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String key=&quot;Id#taobao_&quot;+tradeId;&lt;br/&gt;</span><br><span class="line">cache.put(key, value);</span><br></pre></td></tr></table></figure></li><li><p>如果变量值仅在一个范围内变化用 <code>Enum</code> 类。如果还带有名称之外    的延伸属性,必须 使用 <code>Enum</code> 类,下面正例中的数字就是延伸信息,    表示星期几。</p><p> 正例:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Enum&#123; </span><br><span class="line">     MONDAY(1), TUESDAY(2),WEDNESDAY(3),THURSDAY(4),</span><br><span class="line">     FRIDAY(5),SATURDAY(6),SUNDAY(7);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="格式规约"><a href="#格式规约" class="headerlink" title="格式规约"></a>格式规约</h4><ol><li><p>大括号的使用约定。如果是大括号内为空,则简洁地写成{}即可,不需要    换行;如果 是非空代码块则:</p><blockquote><p>左大括号前不换行。<br>左大括号后换行。<br>右大括号前换行。<br>右大括号后还有else等代码则不换行;表示终止右大括号后必须换    行。</p></blockquote></li><li><p>左括号和后一个字符之间不出现空格;同样,右括号和前一个字符之间也    不出现空格。</p></li><li><p>if/for/while/switch/do 等保留字与左右括号之间都必须加空格。</p></li><li><p>任何运算符左右必须加一个空格。</p><p> 说明:运算符包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号、三目运行符等。</p></li><li><p>缩进采用 4 个空格,禁止使用 tab 字符。</p><p> 说明:如果使用 tab 缩进,必须设置 1 个 tab 为 4 个空格。IDEA 设置 tab 为 4 个空格时,请勿勾选 Use tab character；而     eclipse 中,必须勾选 insert spaces for tabs。</p><p> 正例：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String args[]) &#123;</span><br><span class="line">   // 缩进 4 个空格</span><br><span class="line">String say = &quot;hello&quot;;</span><br><span class="line">// 运算符的左右必须有一个空格</span><br><span class="line">int flag = 0;</span><br><span class="line">// 关键词 if 与括号之间必须有一个空格,括号内的 f 与左括号,0与右括号不需要空格 </span><br><span class="line">if (flag == 0) &#123;</span><br><span class="line">       System.out.println(say);</span><br><span class="line">&#125;</span><br><span class="line">// 左大括号前加空格且不换行;左大括号后换行 </span><br><span class="line">if (flag == 1) &#123;</span><br><span class="line">   System.out.println(&quot;world&quot;);</span><br><span class="line">// 右大括号前换行,右大括号后有 else,不用换行</span><br><span class="line">&#125; else &#123; </span><br><span class="line">System.out.println(&quot;ok&quot;);</span><br><span class="line">// 在右大括号后直接结束,则必须换行</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法参数在定义和传入时,多个参数逗号后边必须加空格。</p><p> 正例:<br> 下例中实参的”a”,后边必须要有一个空格。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br></pre></td></tr></table></figure></li></ol><h4 id="OOP-规约"><a href="#OOP-规约" class="headerlink" title="OOP 规约"></a>OOP 规约</h4><ol><li><p>避免通过一个类的对象引用访问此类的静态变量或静态方法,无谓增加编译器解析成本,直接用类名来访问即可。</p></li><li><p>所有的覆写方法,必须加<code>@Override</code> 注解。可以准确判断是否覆盖成功</p></li><li><p>Object 的 equals 方法容易抛空指针异常,应使用常量或确定有值的对象来调用 equals。</p><pre><code>正例: &quot;test&quot;.equals(object);反例: object.equals(&quot;test&quot;);说明:推荐使用java.util.Objects#equals (JDK7引入的工具类)</code></pre></li><li><p>关于基本数据类型与包装数据类型的使用标准如下:</p><blockquote><p>所有的POJO类属性必须使用包装数据类型。<br>RPC方法的返回值和参数必须使用包装数据类型。<br>所有的局部变量【推荐】使用基本数据类型。</p></blockquote></li><li><p>定义 DO/DTO/VO 等 POJO 类时,不要设定任何属性默认值。</p></li><li><p>构造方法里面禁止加入任何业务逻辑,如果有初始化逻辑,请放在 init 方法中。</p></li><li><p>POJO 类必须写 toString 方法。使用 IDE 的中工具:source&gt;generate toString 时,如果继承了另一个 POJO 类,注意在前面加一下 super.toString。</p><p> 说明:在方法执行抛出异常时,可以直接调用 POJO 的 toString()方法打印其属性值,便于排查问题。</p></li><li><p>使用索引访问用 String 的 split 方法得到的数组时,需做最后一个分隔符后有无内容的检查,否则会有抛 IndexOutOfBoundsException 的风险。</p><p> 说明:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;a,b,c,,&quot;;</span><br><span class="line">String[] ary = str.split(&quot;,&quot;); //预期大于 3,结果是 3</span><br><span class="line">millionSystem.out.println(ary.length);</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>类内方法定义顺序依次是:公有方法或保护方法 &gt; 私有方法 &gt; getter/setter<br>方法。</p></li><li><p>setter 方法中,参数名称与类成员变量名称一致,this.成员名=参数名。在<br>getter/setter 方法中,尽量不要增加业务逻辑,增加排查问题的难度。</p><p>反例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Integer getData()&#123; </span><br><span class="line">if (true) &#123;</span><br><span class="line">return data + 100; </span><br><span class="line">&#125; else &#123;</span><br><span class="line">return data - 100; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>循环体内,字符串的联接方式,使用 StringBuilder 的 append 方法进行扩展。</p><p>反例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;start&quot;; </span><br><span class="line">for (int i=0; i&lt;100; i++) &#123;</span><br><span class="line">str = str + &quot;hello&quot;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明:反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象,然后进行 append 操作,最后通过 toString 方法返回 String 对象,造成内存资源浪费。</p></li><li><p>final 可提高程序响应效率,声明成 final 的情况:</p><blockquote><p>不需要重新赋值的变量，包括类属性、局部变量<br>对象前加final，表示不允许修改引用的指向<br>类方法确定不允许被重载</p></blockquote></li><li><p>慎用 Object 的 clone 方法来拷贝对象。</p><p>说明:对象的 clone 方法默认是浅拷贝,若想实现深拷贝需要重写 clone 方法实现属性对象 的拷贝。</p></li></ol><h4 id="集合处理"><a href="#集合处理" class="headerlink" title="集合处理"></a>集合处理</h4><ol><li><p>关于 hashCode 和 equals 的处理,遵循如下规则:</p><ul><li>只要重写equals,就必须重写hashCode。</li><li>因为Set存储的是不重复的对象,依据hashCode和equals进行判断,所以Set存储的 对象必须重写这两个方法。</li><li>如果自定义对象做为Map的键,那么必须重写hashCode和equals。</li></ul></li><li><p>ArrayList的subList结果不可强转成ArrayList,否则会抛出ClassCastException 异常:java.util.RandomAccessSubList cannot be cast to java.util.ArrayList ; 说明:subList 返回的是 ArrayList 的内部类 SubList,并不是 ArrayList ,而是 ArrayList 的一个视图,对于SubList子列表的所有操作最终会反映到原列表上。</p></li><li><p>在 subList 场景中,高度注意对原集合元素个数的修改,会导致子列表的遍历、增 加、删除均产生ConcurrentModificationException 异常。</p></li><li><p>使用集合转数组的方法,必须使用集合的toArray(T[] array),传入的是类型完全 一样的数组,大小就是 list.size()。</p><p> 反例:直接使用 toArray 无参方法存在问题,此方法返回值只能是 Object[]类,若强转其它 类型数组将出现 ClassCastException 错误。</p><p> 正例：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;(2);</span><br><span class="line">list.add(&quot;guan&quot;);</span><br><span class="line">list.add(&quot;bao&quot;);</span><br><span class="line">String[] array = new String[list.size()];</span><br><span class="line">array = list.toArray(array);</span><br></pre></td></tr></table></figure><p> 说明:使用 toArray 带参方法,入参分配的数组空间不够大时,toArray 方法内部将重新分配 内存空间,并返回新数组地址;如果数组元素大于实际所需,下标为[ list.size() ]的数组 元素将被置为 null,其它数组元素保持原值,因此最好将方法入参数组大小定义与集合元素 个数一致。</p></li><li><p>使用工具类 Arrays.asList()把数组转换成集合时,不能使用其修改集合相关的方 法,它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。</p><p> 说明:asList 的返回对象是一个 Arrays 内部类,并没有实现集合的修改方法。Arrays.asList 体现的是适配器模式,只是转换接口,后台的数据仍是数组。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] str = new String[] &#123; &quot;a&quot;, &quot;b&quot; &#125;;</span><br><span class="line">List list = Arrays.asList(str);</span><br></pre></td></tr></table></figure><p> 第一种情况:list.add(“c”); 运行时异常。<br><br> 第二种情况:str[0]= “gujin”; 那么list.get(0)也会随之修改。</p></li><li><p>不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator<br>方式,如果并发操作,需要对 Iterator 对象加锁。</p><p> 反例:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; a = new ArrayList&lt;String&gt;(); </span><br><span class="line">a.add(&quot;1&quot;);</span><br><span class="line">a.add(&quot;2&quot;);</span><br><span class="line">for (String temp : a) &#123;</span><br><span class="line">if(&quot;1&quot;.equals(temp))&#123;</span><br><span class="line">a.remove(temp);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 正例:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = a.iterator(); </span><br><span class="line">while(it.hasNext())&#123;</span><br><span class="line">    String temp = it.next(); </span><br><span class="line">    if(删除元素的条件)&#123;</span><br><span class="line">    it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 JDK7 版本以上,Comparator 要满足自反性,传递性,对称性,不然 Arrays.sort, Collections.sort 会报 IllegalArgumentException 异常。</p><p> 说明:</p><blockquote><p>自反性:x,y的比较结果和y,x的比较结果相反。<br>传递性:x&gt;y,y&gt;z,则x&gt;z。<br>对称性:x=y,则x,z比较结果和y,z比较结果相同。</p></blockquote><p> 反例:下例中没有处理相等的情况,实际使用中可能会出现异常:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Comparator&lt;Student&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Student o1, Student o2) &#123;</span><br><span class="line">        return o1.getId() &gt; o2.getId() ? 1 : -1; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>集合初始化时,尽量指定集合初始值大小。</p><p> 说明:ArrayList尽量使用ArrayList(int initialCapacity) 初始化。    </p></li><li><p>使用 entrySet 遍历 Map 类集合 KV,而不是 keySet 方式进行遍历。 说明:keySet 其实是遍历了 2 次,一次是转为 Iterator 对象,另一次是从 hashMap 中取出 key 所对应的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中,效 率更高。如果是 JDK8,使用 Map.foreach 方法。</p><p> keySet()返回的是 K 值集合,是 一个 Set 集合对象;entrySet()返回的是 K-V 值组合集合。</p><pre><code>第一种: Map map = new HashMap(); Iterator iter = map.entrySet().iterator(); while (iter.hasNext()) { Map.Entry entry = (Map.Entry) iter.next(); Object key = entry.getKey(); Object val = entry.getValue(); }效率高,以后一定要使用此种方式！ 第二种: Map map = new HashMap(); Iterator iter = map.keySet().iterator(); while (iter.hasNext()) {     Object key = iter.next();     Object val = map.get(key); } </code></pre></li><li><p>合理利用好集合的有序性(sort)和稳定性(order),避免集合的无序性(unsort)和 不稳定性(unorder)带来的负面影响。</p><p>说明:稳定性指集合每次遍历的元素次序是一定的。有序性是指遍历的结果是按某种比较规则 依次排列的。如:ArrayList 是 order/unsort;HashMap 是 unorder/unsort;TreeSet 是 order/sort。</p></li><li><p>利用 Set 元素唯一的特性,可以快速对一个集合进行去重操作,避免使用 List 的 contains 方法进行遍历、对比、去重操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 删除ArrayList中重复元素，保持顺序</span><br><span class="line">public static void removeDuplicateWithOrder(List list)&#123;</span><br><span class="line">    Set set = new HashSet();</span><br><span class="line">    List newList = new ArrayList();</span><br><span class="line">    for (Iterator iter = list.iterator(); iter.hasNext();) &#123;    </span><br><span class="line">    Object element = iter.next();    </span><br><span class="line">    if (set.add(element))    </span><br><span class="line">   newList.add(element);    </span><br><span class="line">   &#125;</span><br><span class="line">    list.clear();</span><br><span class="line">    list.addAll(newList);</span><br><span class="line">    System.out.println( &quot; remove duplicate &quot; + list); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>高度注意 Map 类集合 K/V 能不能存储 null 值的情况,如下表格:<br>|集合类|Key|Value|Super|说明|<br>| —- | :–: | :–:  | :–: | :–:|<br>|Hashtable|不允许为null|不允许为null|Dictionary|线程安全|<br>|ConcurrentHashMap|不允许为 null|不允许为 null|AbstractMap|分段锁技术|<br>|TreeMap|不允许为 null|允许为 null|AbstractMap|线程不安全|<br>|HashMap|允许为 null|允许为 null|AbstractMap|线程不安全|  </p></li></ol><h4 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h4><ol><li><p>获取单例对象需要保证线程安全,其中的方法也要保证线程安全。</p><p> 说明:资源驱动类、工具类、单例工厂类都需要注意。</p></li><li><p>创建线程或线程池时请指定有意义的线程名称,方便出错时回溯。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">正例:</span><br><span class="line">public class TimerTaskThread extends Thread &#123; </span><br><span class="line">public TimerTaskThread()&#123;</span><br><span class="line">super.setName(&quot;TimerTaskThread&quot;); ... </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>线程资源必须通过线程池提供,不允许在应用中自行显式创建线程。</p><p> 说明:使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销,解决资 源不足的问题。如果不使用线程池,有可能造成系统创建大量同类线程而导致消耗完内存或者 “过度切换”的问题。</p></li><li><p>线程池不允许使用 Executors 去创建,而是通过 ThreadPoolExecutor 的方式,这样 的处理方式让写的同学更加明确线程池的运行规则,规避资源耗尽的风险。</p><p> 说明:Executors 返回的线程池对象的弊端如下:</p><p> 1)FixedThreadPool 和 SingleThreadPool:</p><p> 允许的请求队列长度为 Integer.MAX_VALUE,可能会堆积大量的请求,从而导致 OOM。</p><p> 2)CachedThreadPool 和 ScheduledThreadPool:</p><p> 允许的创建线程数量为 Integer.MAX_VALUE,可能会创建大量的线程,从而导致 OOM。</p></li><li><p>SimpleDateFormat 是线程不安全的类,一般不要定义为static变量,如果定义为static,必须加锁,或者使用 DateUtils 工具类。</p><pre><code>正例:注意线程安全,使用 DateUtils。亦推荐如下处理:private static final ThreadLocal&lt;DateFormat&gt; df = new         ThreadLocal&lt;DateFormat&gt;() {@Overrideprotected DateFormat initialValue() {    return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);    } };</code></pre><p> 说明:如果是 JDK8 的应用,可以使用 Instant 代替 Date,LocalDateTime 代替Calendar, DateTimeFormatter 代替 Simpledateformatter,官方给出的解释:simple beautiful strong immutable thread-safe。</p></li></ol><ol><li><p>高并发时,同步调用应该去考量锁的性能损耗。能用无锁数据结构,就不要用锁;能 锁区块,就不要锁整个方法体;能用对象锁,就不要用类锁。</p></li><li><p>对多个资源、数据库表、对象同时加锁时,需要保持一致的加锁顺序,否则可能会造 成死锁。</p><p> 说明:线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作,那么线程二的加锁顺序 也必须是 A、B、C,否则可能出现死锁。        </p></li><li><p>并发修改同一记录时,避免更新丢失,要么在应用层加锁,要么在缓存加锁,要么在 数据库层使用乐观锁,使用 version 作为更新依据。</p><p> 说明:如果每次访问冲突概率小于 20%,推荐使用乐观锁,否则使用悲观锁。乐观锁的重试次 数不得小于 3 次。<a href="http://www.javaweb1024.com/java/JavaWebzhongji/2015/09/06/847.html" target="_blank" rel="noopener">乐观锁和悲观锁</a></p></li><li><p>多线程并行处理定时任务时,Timer 运行多个 TimeTask 时,只要其中之一没有捕获 抛出的异常,其它任务便会自动终止运行,使用 ScheduledExecutorService 则没有这个问题。<a href="http://blog.csdn.net/lmj623565791/article/details/27109467" target="_blank" rel="noopener">详解</a></p></li><li><p>使用 CountDownLatch 进行异步转同步操作,每个线程退出前必须调用 countDown<br>方法,线程执行代码注意 catch 异常,确保 countDown 方法可以执行,避免主线程无法执行 至 countDown 方法,直到超时才返回结果。</p><p>说明:注意,子线程抛出异常堆栈,不能在主线程 try-catch 到。</p></li><li><p>避免 Random 实例被多线程使用,虽然共享该实例是线程安全的,但会因竞争同一 seed 导致的性能下降。</p><p>说明:Random 实例包括 java.util.Random 的实例或者 Math.random()实例。</p><p>正例:在 JDK7 之后,可以直接使用 API ThreadLocalRandom,在 JDK7 之前,可以做到每个 线程一个实例。</p></li><li><p>通过双重检查锁(double-checked locking)(在并发场景)实现延迟初始化的优 化问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration),推荐问题 解决方案中较为简单一种(适用于 JDK5 及以上版本),将目标属性声明为 volatile 型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">反例:</span><br><span class="line">class Foo &#123;</span><br><span class="line">private Helper helper = null; public Helper getHelper() &#123;</span><br><span class="line">if(helper==null) synchronized(this)&#123; </span><br><span class="line">if (helper == null)</span><br><span class="line"> helper = new Helper();</span><br><span class="line">&#125;</span><br><span class="line">return helper; </span><br><span class="line">&#125;</span><br><span class="line">// other functions and members...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>volatile 解决多线程内存不可见问题。对于一写多读,是可以解决变量同步问题, 但是如果多写,同样无法解决线程安全问题。如果是 count++操作,使用如下类实现: AtomicInteger count = new AtomicInteger(); count.addAndGet(1); 如果是 JDK8,推 荐使用 LongAdder 对象,比 AtomicLong 性能更好(减少乐观锁的重试次数)</p></li><li><p>HashMap 在容量不够进行 resize 时由于高并发可能出现死链,导致 CPU 飙升,在 开发过程中注意规避此风险。</p></li><li><p>ThreadLocal 无法解决共享对象的更新问题,ThreadLocal 对象建议使用 static 修饰。这个变量是针对一个线程内所有操作共有的,所以设置为静态变量,所有此类实例共享 此静态变量 ,也就是说在类第一次被使用时装载,只分配一块存储空间,所有此类的对象(只 要是这个线程内定义的)都可以操控这个变量。</p></li></ol><h4 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h4><ol><li><p>在一个 switch 块内,每个 case 要么通过 break/return 等来终止,要么注释说明程 序将继续执行到哪一个 case 为止;在一个 switch 块内,都必须包含一个 default 语句并且 放在最后,即使它什么代码也没有。</p></li><li><p>在 if/else/for/while/do 语句中必须使用大括号,即使只有一行代码,避免使用 下面的形式:if (condition) statements;</p></li><li><p>推荐尽量少用 else, if-else 的方式可以改写成:</p><pre><code>if(condition){    ...    return obj; }// 接着写 else 的业务逻辑代码;</code></pre><p> 说明:如果非得使用 if()…else if()…else…方式表达逻辑,【强制】请勿超过 3 层,<br>超过请使用状态设计模式。</p><p> 正例:逻辑上超过 3 层的 if-else 代码可以使用卫语句,或者状态模式来实现。</p></li><li><p>除常用方法(如 getXxx/isXxx)等外,不要在条件判断中执行其它复杂的语句,将复 杂逻辑判断的结果赋值给一个有意义的布尔变量名,以 高可读性。<br>说明:很多 if 语句内的逻辑相当复杂,阅读者需要分析条件表达式的最终结果,才能明确什么 样的条件执行什么样的语句,那么,如果阅读者分析逻辑表达式错误呢?</p><pre><code>正例://伪代码如下boolean existed = (file.open(fileName, &quot;w&quot;) != null) &amp;&amp; (...) || (...); if     (existed) {... }反例:if ((file.open(fileName, &quot;w&quot;) != null) &amp;&amp; (...) || (...)) { ...}</code></pre></li><li><p>循环体中的语句要考量性能,以下操作尽量移至循环体外处理,如定义对象、变量、<br>获取数据库连接,进行不必要的 try-catch 操作(这个 try-catch 是否可以移至循环体外)。</p></li><li><p>接口入参保护,这种场景常见的是用于做批量操作的接口。</p></li><li><p>方法中需要进行参数校验的场景:</p><p> 1) 调用频次低的方法。</p><p> 2) 执行时间开销很大的方法,参数校验时间几乎可以忽略不计,但如果因为参数错误导致中间执行回退,或者错误,那得不偿失。</p><p> 3) 需要极高稳定性和可用性的方法。</p><p> 4) 对外 供的开放接口,不管是RPC/API/HTTP接口。 5) 敏感权限入口。</p></li><li><p>方法中不需要参数校验的场景:</p><p> 1) 极有可能被循环调用的方法,不建议对参数进行校验。但在方法说明里必须注明外部参<br>数检查。</p><p> 2) 底层的方法调用频度都比较高,一般不校验。毕竟是像纯净水过滤的最后一道,参数错<br>误不太可能到底层才会暴露问题。一般 DAO 层与 Service 层都在同一个应用中,部署在同一 台服务器中,所以 DAO 的参数校验,可以省略。</p><p> 3) 被声明成private只会被自己代码所调用的方法,如果能够确定调用方法的代码传入参 数已经做过检查或者肯定不会有问题,此时可以不校验参数。</p></li></ol><h4 id="注释规约"><a href="#注释规约" class="headerlink" title="注释规约"></a>注释规约</h4><ol><li><p>类、类属性、类方法的注释必须使用 Javadoc 规范,使用/<em>*内容</em>/格式,不得使用 //xxx 方式。</p></li><li><p>方法内部单行注释,在被注释语句上方另起一行,使用//注释。方法内部多行注释使用/<em> </em>/注释,注意与代码对齐。</p></li><li><p>代码修改的同时,注释也要进行相应的修改,尤其是参数、返回值、异常、核心逻辑 等的修改。</p></li></ol><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ol><li><p>在使用正则表达式时,利用好其预编译功能,可以有效加快正则匹配速度。</p><p> 说明:不要在方法体内定义:Pattern pattern = Pattern.compile(规则);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A typical invocation sequence is thus:</span><br><span class="line">Pattern p = Pattern.compile(&quot;a*b&quot;);</span><br><span class="line">Matcher m = p.matcher(&quot;aaaaab&quot;);</span><br><span class="line">boolean b = m.matches();</span><br><span class="line">is equivalent to :</span><br><span class="line">boolean b = Pattern.matches(&quot;a*b&quot;, &quot;aaaaab&quot;);</span><br></pre></td></tr></table></figure></li><li><p>注意 Math.random() 这个方法返回是 double 类型,注意取值的范围 0≤x&lt;1(能够取到零值,注意除零异常),如果想获取整数类型的随机数,不要将 x 放大 10 的若干倍然后取整,直接使用 Random 对象的 nextInt 或者 nextLong 方法。</p></li><li><p>获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime();<br>说明:如果想获取更加精确的纳秒级时间值,用 System.nanoTime()。在 JDK8 中,针对统计时间等场景,推荐使用 Instant 类。</p></li><li><p>任何数据结构的构造或初始化,都应指定大小,避免数据结构无限增长吃光内存。</p></li></ol><h3 id="异常日志"><a href="#异常日志" class="headerlink" title="异常日志"></a>异常日志</h3><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><ol><li><p>不要捕获 Java 类库中定义的继承自 RuntimeException 的运行时异常类,如: IndexOutOfBoundsException / NullPointerException,这类异常由程序员预检查 来规避,保证程序健壮性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">正例:if(obj != null) &#123;...&#125;</span><br><span class="line">反例:try &#123; obj.method() &#125; catch(NullPointerException e)&#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p>异常不要用来做流程控制,条件控制,因为异常的处理效率比条件分支低。</p></li><li><p>对大段代码进行 try-catch,这是不负责任的表现。catch 时请分清稳定代码和非稳定代码,稳定代码指的是无论如何不会出错的代码。对于非稳定代码的catch尽可能进行区分 异常类型,再做对应的异常处理。</p></li><li><p>捕获异常是为了处理它,不要捕获了却什么都不处理而抛弃之,如果不想处理它,请将该异常抛给它的调用者。最外层的业务使用者,必须处理异常,将其转化为用户可以理解的内容。</p></li><li><p>finally 块必须对资源对象、流对象进行关闭,有异常也要做 try-catch。 说明:如果 JDK7,可以使用 try-with-resources 方式。</p></li><li><p>不能在 finally 块中使用 return,finally 块中的 return 返回后方法结束执行,不会再执行 try 块中的 return 语句。</p></li><li><p>定义时区分unchecked/checked 异常,避免直接使用RuntimeException抛出, 更不允许抛出 Exception 或者 Throwable,应使用有业务含义的自定义异常。推荐业界已定义 过的自定义异常,如:DAOException / ServiceException 等。</p></li></ol><h4 id="日志规约"><a href="#日志规约" class="headerlink" title="日志规约"></a>日志规约</h4><ol><li><p>应用中不可直接使用日志系统(Log4j、Logback)中的 API,而应依赖使用日志框架<br>SLF4J 中的 API,使用门面模式的日志框架,有利于维护和各个类的日志处理方式统一。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">private static final Logger logger = LoggerFactory.getLogger(Abc.class);</span><br></pre></td></tr></table></figure></li><li><p>日志文件推荐至少保存 15 天,因为有些异常具备以“周”为频次发生的特点。</p></li><li><p>对 trace/debug/info 级别的日志输出,必须使用条件输出形式或者使用占位符的方<br>式。</p><p> 说明:logger.debug(“Processing trade with id: “ + id + “ symbol: “ + symbol); 如果日志级别是 warn,上述日志不会打印,但是会执行字符串拼接操作,如果 symbol 是对象, 会执行 toString()方法,浪费了系统资源,执行了上述操作,最终日志却没有打印。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">正例:(条件)</span><br><span class="line">if (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(&quot;Processing trade with id: &quot; + id + &quot; symbol: &quot; + symbol);</span><br><span class="line">&#125;</span><br><span class="line">正例:(占位符)</span><br><span class="line">logger.debug(&quot;Processing trade with id: &#123;&#125; symbol : &#123;&#125; &quot;, id, symbol);</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>避免重复打印日志,浪费磁盘空间,务必在 log4j.xml 中设置 additivity=false。</p><pre><code>正例:&lt;logger name=&quot;com.taobao.dubbo.config&quot; additivity=&quot;false&quot;&gt;</code></pre></li><li><p>异常信息应该包括两类信息:案发现场信息和异常堆栈信息。如果不处理,那么往上抛。</p><pre><code>正例:logger.error(各类参数或者对象 toString + &quot;_&quot; + e.getMessage(), e);</code></pre></li><li><p>可以使用 warn 日志级别来记录用户输入参数错误的情况,避免用户投诉时,无所适从。</p></li></ol><h3 id="MySQL-规约"><a href="#MySQL-规约" class="headerlink" title="MySQL 规约"></a>MySQL 规约</h3><h4 id="待续。。。"><a href="#待续。。。" class="headerlink" title="待续。。。"></a>待续。。。</h4><p>源引自：阿里巴巴Java开发手册</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ombpxfki1.bkt.clouddn.com/14886976307472ywtu72p.png?imageslim&quot; alt=&quot;paste image&quot;&gt;&lt;br&gt;为什么要规范代码？代码规范不仅提高了代码的可读性，也避免了一些隐藏bug的出现。好的代码也会让人心情愉悦，提高编程的效率。&lt;br&gt;
    
    </summary>
    
      <category term="schedule" scheme="https://dongme.site/categories/schedule/"/>
    
    
      <category term="java" scheme="https://dongme.site/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>[music]-[a little story]</title>
    <link href="https://dongme.site/2017/02/24/a_little_story/"/>
    <id>https://dongme.site/2017/02/24/a_little_story/</id>
    <published>2017-02-24T08:17:00.000Z</published>
    <updated>2018-08-29T16:10:58.307Z</updated>
    
    <content type="html"><![CDATA[<p>listen<br><a id="more"></a></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" style="width:330px,height:86px" src="//music.163.com/outchain/player?type=2&id=857896&auto=0&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;listen&lt;br&gt;
    
    </summary>
    
      <category term="music" scheme="https://dongme.site/categories/music/"/>
    
    
  </entry>
  
</feed>
