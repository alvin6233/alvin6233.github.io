<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>alvin&#39;s blog</title>
  
  <subtitle>Good memory is worse than bad writing</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dongz.me/"/>
  <updated>2018-12-21T13:38:09.162Z</updated>
  <id>https://dongz.me/</id>
  
  <author>
    <name>alvin dong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>函数式编程</title>
    <link href="https://dongz.me/2018/12/21/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://dongz.me/2018/12/21/函数式编程/</id>
    <published>2018-12-20T16:27:00.000Z</published>
    <updated>2018-12-21T13:38:09.162Z</updated>
    
    <content type="html"><![CDATA[<p>最早是从一些博客上看到过函数式编程，但是没有太在意。js支持将函数作为传出/传入参数，可以存储在变量中。java8中Lambda表达式 、Stream流处理等功能等闪亮登场，除此之外还支持函数接口。越来越多语言中引入函数式编程的特性，种种苗头都预示着函数式编程越来越得到重视。这里主要对函数式编程思想做一些理解和认识。<br><a id="more"></a></p><h2 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h2><h3 id="形式系统"><a href="#形式系统" class="headerlink" title="形式系统"></a>形式系统</h3><blockquote><p>概念：先是确立一些互不冲突的基础原理，以及一些操作这些原理的规则，然后就可以把这些原理以及规则拼凑起来形成新的更加复杂的规则或是定理了。数学家把这种方法称为“形式系统”或是“演算”。    </p><p>理解：<br>示例1-没有人见过这样的一个圆，但是我们知道怎样的圆是完美的圆，而且可以用公式把它描述出来。<br>示例2-自然数，很难说所有的自然数都与客观世界有关，随便举一个超级大的数，这个数可能就和世界上任何事物无关，因为这个世界可能不是无穷大的。</p></blockquote><p><strong>notice:</strong> 形式系统是客观存在的，虽然不同文明不同智慧生物对它们的存在和理解方式有差异，与客观世界有关的更容易被发现和理解，而与客观世界无关的不容易被发现和理解。</p><h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><blockquote><p>阿隆佐设计了一个名为<a href="https://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97" target="_blank" rel="noopener">lambda演算</a>的形式系统。这个系统实质上是为其中一个超级机器设计的编程语言。在这种语言里面，函数的参数是函数，返回值也是函数。  </p><p>艾伦·图灵设计了一种完全不同的系统（后来被称为图灵机），并用这种系统得出了和阿隆佐相似的答案。到了后来人们证明了图灵机和lambda演算的能力是一样的。  </p><p>二战时期IBM制造了第一台机器Mark一号用来计算各种火炮发射数据表。Mark一号重5吨，由75万个零部件构成，每一秒可以完成3次运算。</p><p>1949年第一台电子离散变量自动计算机诞生并取得了巨大的成功。它是冯·诺伊曼设计架构的第一个实例，也是一台现实世界中实现的图灵机。</p><p>1958年John McCarthy的MIT教授发明了一种列表处理语言（Lisp），这种语言是一种阿隆佐lambda演算在现实世界的实现，而且它能在冯·诺伊曼计算机上运行！很多计算机科学家都认识到了Lisp强大的能力。</p><p>1973年在MIT人工智能实验室的一些程序员研发出一种机器，并把它叫做Lisp机。于是阿隆佐的lambda演算也有自己的硬件实现了！</p></blockquote><h2 id="函数式编程-FP"><a href="#函数式编程-FP" class="headerlink" title="函数式编程(FP)"></a>函数式编程(FP)</h2><blockquote><p>函数式编程是阿隆佐思想的在现实世界中的实现。不过不是全部的lambda演算思想都可以运用到实际中，因lambda演算在设计的时候就不是为了在各种现实世界中的限制下工作的。函数式编程只是一系列想法，而不是一套严苛的规定。</p><p>Lambda演算在最初设计的时候就是为了研究计算相关的问题，所以函数式编程主要解决的也是计算问题。</p><p>函数就是函数式编程中的基础元素，可以完成几乎所有的操作，哪怕最简单的计算，也是用函数完成的。</p><p>FP中变量称为符号，且都是final的。</p><p>函数式程序可以通过函数参数保存状态。</p></blockquote><h3 id="FP的优点"><a href="#FP的优点" class="headerlink" title="FP的优点"></a>FP的优点</h3><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><blockquote><p>因为FP中的每个符号都是final的，所以没有什么函数会有副作用。函数不会修改外部状态值，测试不需要关心外部状态值，也不需要关心函数调用顺序，唯一需要关心的仅仅是函数参数。  </p></blockquote><h4 id="调试查错"><a href="#调试查错" class="headerlink" title="调试查错"></a>调试查错</h4><blockquote><p>只要传递参数一致，错误百分百可以重现。<br>返回值异常时，检查栈上的数据，查看哪些参数传给了哪些函数，函数返回值是什么。跳进对应函数步进调试定位问题即可。</p></blockquote><h4 id="并发执行"><a href="#并发执行" class="headerlink" title="并发执行"></a>并发执行</h4><blockquote><p>不需要任何改动，所有FP程序都是可以并发执行的。<br>由于根本不需要采用锁机制，因此完全不需要担心死锁或是并发竞争的发生。<br>编译器可以对函数式代码进行分析，对耗时的函数并行调用。</p></blockquote><h4 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h4><blockquote><p>FP的程序中所有状态就是传给函数的参数，而参数都是储存在栈上的，这一特性让实现热部署变的简单。<br>只要比较一下正在运行的代码以及新的代码获得一个diff，然后用这个diff更新现有的代码，新代码的热部署就完成了。</p></blockquote><h4 id="机器辅助优化及证明"><a href="#机器辅助优化及证明" class="headerlink" title="机器辅助优化及证明"></a>机器辅助优化及证明</h4><blockquote><p>FP语言是可以用数学方法来分析的。只要是能在纸上写出来的数学运算就可以用这种语言表述出来。<br>可以用这种方法来证明代码的正确性，甚至可以设计出能够自动分析代码并为单元测试自动生成边缘测试用例的工具出来。</p></blockquote><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><blockquote><p>所谓的高阶函数就是对其他函数进行操作（比如说把这些函数当成参数）的函数。</p></blockquote><p>如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class MessageHandler &#123;</span><br><span class="line">    void handleMessage(Message msg, Function getClientCode) &#123;</span><br><span class="line">        // ...</span><br><span class="line">        Message msg1 = msg.setClientCode(getClientCode());</span><br><span class="line">        // ...</span><br><span class="line"></span><br><span class="line">        sendMessage(msg1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String getClientCodeOne() &#123;</span><br><span class="line">    return &quot;ABCD_123&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String getClientCodeTwo() &#123;</span><br><span class="line">    return &quot;123_ABCD&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MessageHandler handler = new MessageHandler();</span><br><span class="line">handler.handleMessage(someMsg, getClientCodeOne);</span><br></pre></td></tr></table></figure><blockquote><p>好处：一是不再受限于多层类的结构。这样做可以在运行时传递新的函数，可以在任何时候改变这些函数，而且这些改变不仅更加精准而且触碰的代码更少。</p></blockquote><h3 id="柯里化-Currying"><a href="#柯里化-Currying" class="headerlink" title="柯里化(Currying)"></a>柯里化(Currying)</h3><blockquote><p>是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。<br>使用匿名单参数函数来实现多参数函数的方法，如下：  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var foo = function(a) &#123;</span><br><span class="line">  return function(b) &#123;</span><br><span class="line">    return a * a + b * b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>好处：可以快速且简单的实现函数封装，让我们更专注于自己的设计；可以实现概念编程，从而完全不需要设计模式。<br><a href="https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96" target="_blank" rel="noopener">了解更多</a></p></blockquote><h3 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h3><p>如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = somewhatLongOperation1();</span><br><span class="line">String s2 = somewhatLongOperation2();</span><br><span class="line">String s3 = concatenate(s1, s2);</span><br></pre></td></tr></table></figure></p><p>其中s1和s2函数作为函数concatenate的参数，执行concatenate需要用到s1和s2的时候才去执行s1和s2函数。  </p><blockquote><p>支持惰性求值的编译器可以抵消相同项从而避免执行无谓的代码，安排代码执行顺序从而实现更高的执行效率甚至是减少错误。<br>惰性求值技术允许定义无穷数据结构，把很多问题抽象化，然后在更高的层面上解决它们。如定义一个Fibonacci数列的无穷列表结构，列表中只有真正会被用到的数才会被计算出来。<br>不足：因为不支持顺序执行，不能处理IO等必须顺序执行的操作。解决方案-continuations，monads以及uniqueness typing。</p></blockquote><h3 id="链式风格-continuation"><a href="#链式风格-continuation" class="headerlink" title="链式风格(continuation)"></a>链式风格(continuation)</h3><blockquote><p>continuation又称CPS（Continuation Programming Style）就是一种特别的参数，把这种参数传到函数中，函数就能够根据continuation将返回值传递到程序中的某段代码中。</p></blockquote><p>如下示例：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i = add(5, 10);</span><br><span class="line">int j = square(i);</span><br></pre></td></tr></table></figure><p>add这个函数将返回15然后这个值会赋给i，这也是add被调用的地方。接下来i的值又会被用于调用square。用Continuation Pass Style（CPS）技术重写如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int j = add(5, 10, square);</span><br></pre></td></tr></table></figure><p>add多了一个参数：一个函数，add必须在完成自己的计算后，调用这个函数并把结果传给它。这时square就是add的一个continuation。</p><blockquote><p>用CPS风格写出来的程序不需要栈，但是每次调用函数的时候都会要多加一个参数。<br>continuation和栈上指示函数返回地址的指针其实是同一样东西，只是continuation是显式的传递该地址并且因此代码就不局限于只能返回到函数被调用的地方了。  </p></blockquote><h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><blockquote><p>模式匹配并不是什么新功能。而事实上它和函数式编程也没有什么太大的关系。<br>有点类似重载，几个同名函数会根据具体参数选择最佳的执行函数。</p></blockquote><p>普通Fibonacci函数：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int fib(int n) &#123;</span><br><span class="line">    if(n == 0) return 1;</span><br><span class="line">    if(n == 1) return 1;</span><br><span class="line"></span><br><span class="line">    return fib(n - 2) + fib(n - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用模式匹配重写过的Fibonacci函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int fib(0) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">int fib(1) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">int fib(int n) &#123;</span><br><span class="line">    return fib(n - 2) + fib(n - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当n为0时，可以用函数int fib(int n)，不过真正调用的是int fib(0)因为这个函数更具体更接近调用者的要求。</p><h3 id="闭包-Closure"><a href="#闭包-Closure" class="headerlink" title="闭包(Closure)"></a>闭包(Closure)</h3><blockquote><p>在指令式语言中变量不是final，可以读写外部的状态的情况下，又想使用FP的高阶函数等特性，需要通过lexical closure支持。<br>返回类型为函数的函数，closure保存了指向其外部变量的引用。如下示例：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Function makeIncrementer() &#123;</span><br><span class="line">   int n = 0;</span><br><span class="line"></span><br><span class="line">   int increment() &#123;</span><br><span class="line">       return ++n;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Function inc1 = makeIncrementer();</span><br><span class="line">Function inc2 = makeIncrementer();</span><br><span class="line"></span><br><span class="line">inc1(); // returns 1;</span><br><span class="line">inc1(); // returns 2;</span><br><span class="line">inc1(); // returns 3;</span><br><span class="line">inc2(); // returns 1;</span><br><span class="line">inc2(); // returns 2;</span><br><span class="line">inc2(); // returns 3;</span><br></pre></td></tr></table></figure><p>参考：<br><a href="https://github.com/justinyhuang/Functional-Programming-For-The-Rest-of-Us-Cn" target="_blank" rel="noopener">傻瓜函数编程(https://github.com/justinyhuang/Functional-Programming-For-The-Rest-of-Us-Cn)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最早是从一些博客上看到过函数式编程，但是没有太在意。js支持将函数作为传出/传入参数，可以存储在变量中。java8中Lambda表达式 、Stream流处理等功能等闪亮登场，除此之外还支持函数接口。越来越多语言中引入函数式编程的特性，种种苗头都预示着函数式编程越来越得到重视。这里主要对函数式编程思想做一些理解和认识。&lt;br&gt;
    
    </summary>
    
      <category term="名词解释" scheme="https://dongz.me/categories/%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"/>
    
    
  </entry>
  
  <entry>
    <title>oracle递归查询</title>
    <link href="https://dongz.me/2018/12/18/oracle%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2/"/>
    <id>https://dongz.me/2018/12/18/oracle递归查询/</id>
    <published>2018-12-18T15:05:00.000Z</published>
    <updated>2018-12-18T16:03:25.248Z</updated>
    
    <content type="html"><![CDATA[<p>工作中遇到了递归查询部门树的需求，之前虽然用过，但隔的时间久了记不清具体用法。在这里mark一下，重新熟悉下<br><a id="more"></a></p><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span>  <span class="keyword">table</span> dept_tree(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> ,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">parent</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">comment</span> <span class="keyword">on</span> <span class="keyword">column</span> dept_tree.id <span class="keyword">is</span> <span class="string">'主键'</span>;</span><br><span class="line"><span class="keyword">comment</span> <span class="keyword">on</span> <span class="keyword">column</span> dept_tree.name <span class="keyword">is</span> <span class="string">'部门名称'</span>;</span><br><span class="line"><span class="keyword">comment</span> <span class="keyword">on</span> <span class="keyword">column</span> dept_tree.parent <span class="keyword">is</span> <span class="string">'父部门主键'</span>;</span><br></pre></td></tr></table></figure><h2 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h2><p>执行 <code>desc dept_tree;</code>  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">名称     空值       类型           </span><br><span class="line"><span class="comment">------ -------- ------------ </span></span><br><span class="line">ID     NOT NULL NUMBER(38)   </span><br><span class="line">NAME   NOT NULL VARCHAR2(20) </span><br><span class="line">PARENT NOT NULL NUMBER(38)</span><br></pre></td></tr></table></figure><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">1</span> , <span class="string">'部门1'</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">2</span> , <span class="string">'部门2'</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">3</span> , <span class="string">'部门3'</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">4</span> , <span class="string">'部门1-1'</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">5</span> , <span class="string">'部门1-2'</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">6</span> , <span class="string">'部门1-3'</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">7</span> , <span class="string">'部门2-1'</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">8</span> , <span class="string">'部门2-2'</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">9</span> , <span class="string">'部门3-1'</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">10</span> , <span class="string">'部门3-2'</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">11</span> , <span class="string">'部门3-3'</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">12</span> , <span class="string">'部门3-4'</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">13</span> , <span class="string">'部门3-5'</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">14</span> , <span class="string">'部门3-6'</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">15</span> , <span class="string">'部门3-6'</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">16</span> , <span class="string">'部门2-2-1'</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept_tree <span class="keyword">values</span>(<span class="number">17</span> , <span class="string">'部门2-2-2'</span>, <span class="number">8</span>);</span><br></pre></td></tr></table></figure><h2 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h2><h3 id="递归语法"><a href="#递归语法" class="headerlink" title="递归语法"></a>递归语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> [<span class="keyword">column</span>, ...] <span class="keyword">from</span> tablename</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> [condition1]</span><br><span class="line"><span class="keyword">connect</span> <span class="keyword">by</span> [condition2]</span><br><span class="line"><span class="keyword">where</span> [condition3];</span><br></pre></td></tr></table></figure><p><strong>condition1:</strong><br>根结点的限定语句，可以放宽限定条件，以取得多个根结点，实际就是多棵树；省略该条件或设置为1=1则是每个节点作为根节点遍历一遍。  </p><p><strong>condition2:</strong><br>连接条件，其中用PRIOR表示上一条记录。比如 CONNECT BY PRIOR id = parent，就是说上一条记录的id 是本条记录的parent，即本记录的父亲是上一条记录，递归方式为自顶向下顺序遍历；CONNECT BY id =  PRIOR parent，就是说上一条记录的parent是本条记录的id，即上一条记录的父亲是本记录，递归方式为自底向上顺序遍历。  </p><p><strong>condition3:</strong><br>是过滤条件，用于对返回的所有记录进行过滤。</p><h3 id="递归实例"><a href="#递归实例" class="headerlink" title="递归实例"></a>递归实例</h3><h4 id="根部门为17，向上遍历所有节点"><a href="#根部门为17，向上遍历所有节点" class="headerlink" title="根部门为17，向上遍历所有节点"></a>根部门为17，向上遍历所有节点</h4><blockquote><p>执行sql: </p></blockquote>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span>,sys_connect_by_path(<span class="keyword">name</span>, <span class="string">'=&gt;'</span>) namejoins, <span class="keyword">level</span></span><br><span class="line"><span class="keyword">from</span> dept_tree</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> dept_tree.id=<span class="number">17</span></span><br><span class="line"><span class="keyword">connect</span> <span class="keyword">by</span>  <span class="keyword">id</span> = <span class="keyword">prior</span> <span class="keyword">parent</span></span><br></pre></td></tr></table></figure><blockquote><p>执行结果:  </p></blockquote><table><thead><tr><th style="text-align:center">ID</th><th style="text-align:center">NAME</th><th style="text-align:center">NAMEJOINS</th><th style="text-align:center">LEVEL</th></tr></thead><tbody><tr><td style="text-align:center">17</td><td style="text-align:center">部门2-2-2</td><td style="text-align:center">=&gt;部门2-2-2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">部门2-2</td><td style="text-align:center">=&gt;部门2-2-2=&gt;部门2-2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">部门2</td><td style="text-align:center">=&gt;部门2-2-2=&gt;部门2-2=&gt;部门2</td><td style="text-align:center">3</td></tr></tbody></table><h4 id="根部门为17，向下遍历所有节点"><a href="#根部门为17，向下遍历所有节点" class="headerlink" title="根部门为17，向下遍历所有节点"></a>根部门为17，向下遍历所有节点</h4><blockquote><p>执行sql:  </p></blockquote>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span>,sys_connect_by_path(<span class="keyword">name</span>, <span class="string">'=&gt;'</span>) namejoins, <span class="keyword">level</span></span><br><span class="line"><span class="keyword">from</span> dept_tree</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> dept_tree.id=<span class="number">17</span></span><br><span class="line"><span class="keyword">connect</span> <span class="keyword">by</span>  <span class="keyword">prior</span> <span class="keyword">id</span> = <span class="keyword">parent</span></span><br></pre></td></tr></table></figure><blockquote><p>执行结果:  </p></blockquote><table><thead><tr><th style="text-align:center">ID</th><th style="text-align:center">NAME</th><th style="text-align:center">NAMEJOINS</th><th style="text-align:center">LEVEL</th></tr></thead><tbody><tr><td style="text-align:center">17</td><td style="text-align:center">部门2-2-2</td><td style="text-align:center">=&gt;部门2-2-2</td><td style="text-align:center">1</td></tr></tbody></table><h4 id="根部门不设置过滤条件，以所有节点作为根节点遍历"><a href="#根部门不设置过滤条件，以所有节点作为根节点遍历" class="headerlink" title="根部门不设置过滤条件，以所有节点作为根节点遍历"></a>根部门不设置过滤条件，以所有节点作为根节点遍历</h4><blockquote><p>执行sql:  </p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span>,sys_connect_by_path(<span class="keyword">name</span>, <span class="string">'=&gt;'</span>) namejoins, <span class="keyword">level</span></span><br><span class="line"><span class="keyword">from</span> dept_tree</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> <span class="number">1</span>=<span class="number">1</span></span><br><span class="line"><span class="keyword">connect</span> <span class="keyword">by</span>  <span class="keyword">prior</span> <span class="keyword">id</span> = <span class="keyword">parent</span></span><br></pre></td></tr></table></figure><blockquote><p>执行结果:</p></blockquote><table><thead><tr><th style="text-align:center">ID</th><th style="text-align:center">NAME</th><th style="text-align:center">NAMEJOINS</th><th style="text-align:center">LEVEL</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">部门1</td><td style="text-align:center">=&gt;部门1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">部门1-1</td><td style="text-align:center">=&gt;部门1=&gt;部门1-1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">部门1-2</td><td style="text-align:center">=&gt;部门1=&gt;部门1-2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">部门1-3</td><td style="text-align:center">=&gt;部门1=&gt;部门1-3</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">部门2</td><td style="text-align:center">=&gt;部门2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">部门2-1</td><td style="text-align:center">=&gt;部门2=&gt;部门2-1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">部门2-2</td><td style="text-align:center">=&gt;部门2=&gt;部门2-2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">部门2-2-1</td><td style="text-align:center">=&gt;部门2=&gt;部门2-2=&gt;部门2-2-1</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">17</td><td style="text-align:center">部门2-2-2</td><td style="text-align:center">=&gt;部门2=&gt;部门2-2=&gt;部门2-2-2</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">部门3</td><td style="text-align:center">=&gt;部门3</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">部门3-1</td><td style="text-align:center">=&gt;部门3=&gt;部门3-1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">部门3-2</td><td style="text-align:center">=&gt;部门3=&gt;部门3-2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">部门3-3</td><td style="text-align:center">=&gt;部门3=&gt;部门3-3</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">部门3-4</td><td style="text-align:center">=&gt;部门3=&gt;部门3-4</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">部门3-5</td><td style="text-align:center">=&gt;部门3=&gt;部门3-5</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">部门3-6</td><td style="text-align:center">=&gt;部门3=&gt;部门3-6</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">部门3-6</td><td style="text-align:center">=&gt;部门3=&gt;部门3-6</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">部门1-1</td><td style="text-align:center">=&gt;部门1-1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">部门1-2</td><td style="text-align:center">=&gt;部门1-2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">部门1-3</td><td style="text-align:center">=&gt;部门1-3</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">部门2-1</td><td style="text-align:center">=&gt;部门2-1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">部门2-2</td><td style="text-align:center">=&gt;部门2-2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">部门2-2-1</td><td style="text-align:center">=&gt;部门2-2=&gt;部门2-2-1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">17</td><td style="text-align:center">部门2-2-2</td><td style="text-align:center">=&gt;部门2-2=&gt;部门2-2-2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">部门3-1</td><td style="text-align:center">=&gt;部门3-1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">部门3-2</td><td style="text-align:center">=&gt;部门3-2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">部门3-3</td><td style="text-align:center">=&gt;部门3-3</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">部门3-4</td><td style="text-align:center">=&gt;部门3-4</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">部门3-5</td><td style="text-align:center">=&gt;部门3-5</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">部门3-6</td><td style="text-align:center">=&gt;部门3-6</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">部门3-6</td><td style="text-align:center">=&gt;部门3-6</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">部门2-2-1</td><td style="text-align:center">=&gt;部门2-2-1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">17</td><td style="text-align:center">部门2-2-2</td><td style="text-align:center">=&gt;部门2-2-2</td><td style="text-align:center">1</td></tr></tbody></table><blockquote><p>这时自底向上执行如下sql输出结果同上:     </p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span>,sys_connect_by_path(<span class="keyword">name</span>, <span class="string">'=&gt;'</span>) namejoins, <span class="keyword">level</span></span><br><span class="line"><span class="keyword">from</span> dept_tree</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> <span class="number">1</span>=<span class="number">1</span></span><br><span class="line"><span class="keyword">connect</span> <span class="keyword">by</span> <span class="keyword">id</span> = <span class="keyword">prior</span> <span class="keyword">parent</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作中遇到了递归查询部门树的需求，之前虽然用过，但隔的时间久了记不清具体用法。在这里mark一下，重新熟悉下&lt;br&gt;
    
    </summary>
    
      <category term="积累" scheme="https://dongz.me/categories/%E7%A7%AF%E7%B4%AF/"/>
    
      <category term="数据存储" scheme="https://dongz.me/categories/%E7%A7%AF%E7%B4%AF/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>HTTP常见状态码</title>
    <link href="https://dongz.me/2018/12/16/HTTP%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <id>https://dongz.me/2018/12/16/HTTP常见状态码/</id>
    <published>2018-12-16T15:12:00.000Z</published>
    <updated>2018-12-16T15:14:09.557Z</updated>
    
    <content type="html"><![CDATA[<p>当浏览器向服务器发送请求后，服务端会返回一个状态码用以表示服务器当响应状态，可以根据具体的返回码分析请求状态及问题出现的可能原因。<a id="more"></a></p><h2 id="1xx临时响应"><a href="#1xx临时响应" class="headerlink" title="1xx临时响应"></a>1xx临时响应</h2><blockquote><p>表示临时响应并需要请求者继续执行操作的状态码  </p></blockquote><ul><li>100 (继续) 服务器仅接收到部分请求，客户端应该继续发送其余的请求</li><li>101 (切换协议) 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</li></ul><h2 id="2xx成功"><a href="#2xx成功" class="headerlink" title="2xx成功"></a>2xx成功</h2><blockquote><p>表示成功处理了请求的状态码</p></blockquote><ul><li>200 (成功) 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页</li><li>201 (已创建) 成功请求并创建了新的资源</li><li>202 (已接受) 请求已被服务器接受，但是处理未完成</li><li>203 (非授权信息) 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</li><li>204 (无内容) 服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</li><li>205 (重置内容) 服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</li><li>206 (部分内容) 客户发送了一个带有Range头的GET请求，服务器完成了它</li></ul><h2 id="3xx重定向"><a href="#3xx重定向" class="headerlink" title="3xx重定向"></a>3xx重定向</h2><blockquote><p>表示要完成请求，需要进一步操作。 通常，这些状态码用来重定向</p></blockquote><ul><li>300 (多种选择) 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</li><li>301 (永久移动) 所请求的页面已经转移至新的URI，并将请求转到新URI</li><li>302 (临时移动) 与301类似。但资源只是临时被移动。客户端应继续使用原有URI</li><li>303 (查看其他地址) 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码</li><li>304 (未修改) 所请求的资源未修改（一般是提供If-Modified-Since头表示客户只想比指定日期更新的资源），服务器返回此状态码时，不会返回任何资源</li><li>305 (使用代理) 客户请求的资源应该通过Location头所指明的代理服务器提取</li><li>307 (临时重定向) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</li></ul><h2 id="4xx客户端错误"><a href="#4xx客户端错误" class="headerlink" title="4xx客户端错误"></a>4xx客户端错误</h2><blockquote><p>这些状态码表示请求可能出错，妨碍了服务器的处理。</p></blockquote><ul><li>400 (错误请求) 服务器未能理解请求</li><li>401 (未授权) 请求要求用户的身份认证</li><li>403 (禁止) 服务器端拒绝执行客户端请求</li><li>404 (未找到) 服务器找不到请求的网页</li><li>405 (方法禁用) 请求中指定的方法不被允许</li><li>406 (不接受) 服务器无法根据客户端请求的内容特性完成请求</li><li>407 (需要代理授权) 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</li><li>408 (请求超时) 请求超出了服务器的等待时间</li><li>409 (冲突) 服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息</li><li>410 (已删除) 如果请求的资源已永久删除，服务器就会返回此响应</li><li>411 (需要有效长度) 服务器无法处理客户端发送的不带Content-Length的请求信息</li><li>412 (未满足前提条件) 请求中的前提条件被服务器判定为失败</li><li>413 (请求实体过大) 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</li><li>414 (请求的 URI 过长) 请求的URI过长（URI通常为网址），服务器无法处理</li><li>415 (不支持的媒体类型) 服务器无法处理请求附带的媒体格式</li><li>416 (请求范围不符合要求) 服务器不能满足客户在请求中指定的Range头</li><li>417 (未满足期望值) 服务器无法满足Expect的请求头信息</li></ul><h2 id="5xx服务器端错误"><a href="#5xx服务器端错误" class="headerlink" title="5xx服务器端错误"></a>5xx服务器端错误</h2><blockquote><p>表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</p></blockquote><ul><li>500 (服务器内部错误) 服务器遇到错误，无法完成请求</li><li>501 (尚未实施) 服务器不具备完成请求的功能 例如，服务器无法识别请求方法时可能会返回此代码</li><li>502 (错误网关) 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</li><li>503 (服务不可用) 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</li><li>504 (网关超时) 服务器作为网关或代理，但是没有及时从上游服务器收到请求</li><li>505 (HTTP 版本不受支持) 服务器不支持请求中所用的 HTTP 协议版本</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当浏览器向服务器发送请求后，服务端会返回一个状态码用以表示服务器当响应状态，可以根据具体的返回码分析请求状态及问题出现的可能原因。
    
    </summary>
    
      <category term="网络" scheme="https://dongz.me/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>[music]-[ツナ覚醒]</title>
    <link href="https://dongz.me/2018/12/13/music-%E3%83%84%E3%83%8A%E8%A6%9A%E9%86%92/"/>
    <id>https://dongz.me/2018/12/13/music-ツナ覚醒/</id>
    <published>2018-12-12T16:28:00.000Z</published>
    <updated>2018-12-12T16:35:21.363Z</updated>
    
    <content type="html"><![CDATA[<p>一步超然动画片《家庭教师》中的插曲，特别喜欢这种燃炸天的节奏♡♡♡♡♡<br><a id="more"></a></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=29023858&auto=1&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一步超然动画片《家庭教师》中的插曲，特别喜欢这种燃炸天的节奏♡♡♡♡♡&lt;br&gt;
    
    </summary>
    
      <category term="音乐" scheme="https://dongz.me/categories/%E9%9F%B3%E4%B9%90/"/>
    
    
  </entry>
  
  <entry>
    <title>风暴之集合</title>
    <link href="https://dongz.me/2018/12/12/%E9%A3%8E%E6%9A%B4%E4%B9%8B%E9%9B%86%E5%90%88/"/>
    <id>https://dongz.me/2018/12/12/风暴之集合/</id>
    <published>2018-12-11T16:51:00.000Z</published>
    <updated>2018-12-11T16:57:41.497Z</updated>
    
    <content type="html"><![CDATA[<p>java中容器，也称集合可以容纳其它类型数据。在平时也接触类不少比如ArrayList、HashSet、LinkedList、HashMap、TreeMap等等，但真要细说还真一知半解，大体风暴类一下，有不当的地方欢迎评论中指出～～<br><a id="more"></a>  </p><h1 id="风暴之集合"><a href="#风暴之集合" class="headerlink" title="风暴之集合"></a>风暴之集合</h1><p><img src="https://coding.net/u/alvin_me/p/blogpics/git/raw/master/rongqiorjihe.jpg" alt=""></p><p><a href="http://www.edrawsoft.cn/viewer/public/s/ec6e5017846566" target="_blank" rel="noopener">看大图</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java中容器，也称集合可以容纳其它类型数据。在平时也接触类不少比如ArrayList、HashSet、LinkedList、HashMap、TreeMap等等，但真要细说还真一知半解，大体风暴类一下，有不当的地方欢迎评论中指出～～&lt;br&gt;
    
    </summary>
    
      <category term="集合" scheme="https://dongz.me/categories/%E9%9B%86%E5%90%88/"/>
    
    
      <category term="集合" scheme="https://dongz.me/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>风暴之mysql</title>
    <link href="https://dongz.me/2018/12/11/%E9%A3%8E%E6%9A%B4%E4%B9%8Bmysql/"/>
    <id>https://dongz.me/2018/12/11/风暴之mysql/</id>
    <published>2018-12-10T16:40:00.000Z</published>
    <updated>2018-12-10T17:01:35.394Z</updated>
    
    <content type="html"><![CDATA[<p>本篇以mysql常见维度展开头脑风暴。维度包括数据的存储结构、数据库事务、mysql中常见的锁、mysql使用优化、mysql中常见日志。图中有不当的地方请留言指出～～<br><a id="more"></a>  </p><h1 id="风暴之mysql"><a href="#风暴之mysql" class="headerlink" title="风暴之mysql"></a>风暴之mysql</h1><p><img src="https://coding.net/u/alvin_me/p/blogpics/git/raw/master/mysql.jpg" alt=""></p><p><a href="http://www.edrawsoft.cn/viewer/public/s/b8368745248662" target="_blank" rel="noopener">看大图</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇以mysql常见维度展开头脑风暴。维度包括数据的存储结构、数据库事务、mysql中常见的锁、mysql使用优化、mysql中常见日志。图中有不当的地方请留言指出～～&lt;br&gt;
    
    </summary>
    
      <category term="数据存储" scheme="https://dongz.me/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="mysql" scheme="https://dongz.me/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>风暴之线上问题排查</title>
    <link href="https://dongz.me/2018/11/29/%E9%A3%8E%E6%9A%B4%E4%B9%8B%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    <id>https://dongz.me/2018/11/29/风暴之线上问题排查/</id>
    <published>2018-11-28T16:23:00.000Z</published>
    <updated>2018-12-10T17:02:37.966Z</updated>
    
    <content type="html"><![CDATA[<p>实际生产环境下，应用不可避免的会遇到各种各样的问题，要熟练掌握一些命令和工具，以快速排查定位线上问题。<br><a id="more"></a>  </p><h1 id="风暴之线上问题排查"><a href="#风暴之线上问题排查" class="headerlink" title="风暴之线上问题排查"></a>风暴之线上问题排查</h1><p><img src="https://coding.net/u/alvin_me/p/blogpics/git/raw/master/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5.png" alt=""></p><p><a href="http://www.edrawsoft.cn/viewer/public/s/72167602893328" target="_blank" rel="noopener">看大图</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实际生产环境下，应用不可避免的会遇到各种各样的问题，要熟练掌握一些命令和工具，以快速排查定位线上问题。&lt;br&gt;
    
    </summary>
    
      <category term="积累" scheme="https://dongz.me/categories/%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="问题排查" scheme="https://dongz.me/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>风暴之并发和多线程</title>
    <link href="https://dongz.me/2018/11/29/%E9%A3%8E%E6%9A%B4%E4%B9%8B%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://dongz.me/2018/11/29/风暴之并发和多线程/</id>
    <published>2018-11-28T16:18:00.000Z</published>
    <updated>2018-12-10T17:03:00.135Z</updated>
    
    <content type="html"><![CDATA[<p>并发和多线程是Java编程中避不开的话题，今天主要对并发和多线程相关知识进行下头脑风暴。<br><a id="more"></a></p><h1 id="风暴之并发和多线程"><a href="#风暴之并发和多线程" class="headerlink" title="风暴之并发和多线程"></a>风暴之并发和多线程</h1><p><img src="https://coding.net/u/alvin_me/p/blogpics/git/raw/master/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" alt=""></p><p><a href="http://www.edrawsoft.cn/viewer/public/s/7e9bd056155369" target="_blank" rel="noopener">看大图</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并发和多线程是Java编程中避不开的话题，今天主要对并发和多线程相关知识进行下头脑风暴。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://dongz.me/categories/java/"/>
    
    
      <category term="并发" scheme="https://dongz.me/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="多线程" scheme="https://dongz.me/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>风暴之Redis</title>
    <link href="https://dongz.me/2018/11/29/%E9%A3%8E%E6%9A%B4%E4%B9%8BRedis/"/>
    <id>https://dongz.me/2018/11/29/风暴之Redis/</id>
    <published>2018-11-28T16:01:00.000Z</published>
    <updated>2018-12-10T17:03:26.961Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。<br><a id="more"></a></p><h1 id="风暴之Redis"><a href="#风暴之Redis" class="headerlink" title="风暴之Redis"></a>风暴之Redis</h1><p><img src="https://coding.net/u/alvin_me/p/blogpics/git/raw/master/redis%E7%9F%A5%E8%AF%86.png" alt=""></p><p><a href="http://www.edrawsoft.cn/viewer/public/s/0be97318174746" target="_blank" rel="noopener">看大图</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。&lt;br&gt;
    
    </summary>
    
      <category term="数据存储" scheme="https://dongz.me/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="redis" scheme="https://dongz.me/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>风暴之JVM</title>
    <link href="https://dongz.me/2018/11/28/%E9%A3%8E%E6%9A%B4%E4%B9%8BJVM/"/>
    <id>https://dongz.me/2018/11/28/风暴之JVM/</id>
    <published>2018-11-28T15:51:00.000Z</published>
    <updated>2018-12-10T17:03:39.290Z</updated>
    
    <content type="html"><![CDATA[<p>Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够”一次编译，到处运行“的原因。了解JVM底层有助于理解Java工作原理，更好的编程。<br><a id="more"></a></p><h1 id="风暴之JVM"><a href="#风暴之JVM" class="headerlink" title="风暴之JVM"></a>风暴之JVM</h1><p><img src="https://coding.net/u/alvin_me/p/blogpics/git/raw/master/jvm%E7%9B%B8%E5%85%B3.jpg" alt="">  </p><p><a href="http://www.edrawsoft.cn/viewer/public/s/41a60748487374" target="_blank" rel="noopener">看大图</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够”一次编译，到处运行“的原因。了解JVM底层有助于理解Java工作原理，更好的编程。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://dongz.me/categories/java/"/>
    
    
      <category term="jvm" scheme="https://dongz.me/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>风暴之Spring事务</title>
    <link href="https://dongz.me/2018/10/27/%E9%A3%8E%E6%9A%B4%E4%B9%8BSpring%E4%BA%8B%E5%8A%A1/"/>
    <id>https://dongz.me/2018/10/27/风暴之Spring事务/</id>
    <published>2018-10-27T02:14:00.000Z</published>
    <updated>2018-12-10T17:04:18.020Z</updated>
    
    <content type="html"><![CDATA[<p>Spring 简单而强大的事务管理功能，包括编程式事务和声明式事务。通过对相关知识梳理，能够理解 Spring 事务管理的本质，并灵活运用之。<br><a id="more"></a></p><h1 id="风暴之Spring事务"><a href="#风暴之Spring事务" class="headerlink" title="风暴之Spring事务"></a>风暴之Spring事务</h1><p><img src="https://coding.net/u/alvin_me/p/blogpics/git/raw/master/spring%E4%BA%8B%E5%8A%A1.jpg" alt="Spring事务"></p><p><a href="http://www.edrawsoft.cn/viewer/public/s/4cbc1230271951" target="_blank" rel="noopener">看大图</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="https://www.ibm.com/developerworks/cn/education/opensource/os-cn-spring-trans/index.html" target="_blank" rel="noopener">全面分析 Spring 的编程式事务管理及声明式事务管理</a><br>[2] <a href="https://juejin.im/post/5b00c52ef265da0b95276091" target="_blank" rel="noopener">可能是最漂亮的Spring事务管理详解</a><br>[3] <a href="https://juejin.im/post/5a5c631e6fb9a01cb508cd3d" target="_blank" rel="noopener">Spring核心系列之Spring中的事务</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring 简单而强大的事务管理功能，包括编程式事务和声明式事务。通过对相关知识梳理，能够理解 Spring 事务管理的本质，并灵活运用之。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://dongz.me/categories/java/"/>
    
    
      <category term="spring" scheme="https://dongz.me/tags/spring/"/>
    
      <category term="事务" scheme="https://dongz.me/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>风暴之Aop</title>
    <link href="https://dongz.me/2018/10/25/%E9%A3%8E%E6%9A%B4%E4%B9%8BAop/"/>
    <id>https://dongz.me/2018/10/25/风暴之Aop/</id>
    <published>2018-10-24T16:34:00.000Z</published>
    <updated>2018-12-02T14:25:44.654Z</updated>
    
    <content type="html"><![CDATA[<p>面向切面编程<br><a id="more"></a></p><h1 id="风暴之Aop"><a href="#风暴之Aop" class="headerlink" title="风暴之Aop"></a>风暴之Aop</h1><p><img src="https://coding.net/u/alvin_me/p/blogpics/git/raw/master/spring%20aop.jpg" alt=""></p><p><a href="http://www.edrawsoft.cn/viewer/public/s/032fa832508900" target="_blank" rel="noopener">看大图</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/index.html" target="_blank" rel="noopener">Spring AOP 实现原理与 CGLIB 应用</a><br>[2] <a href="http://www.importnew.com/24305.html" target="_blank" rel="noopener">Spring AOP的实现原理</a><br>[3] <a href="https://juejin.im/post/5af3bd6f518825673954bf22" target="_blank" rel="noopener">Spring AOP实现原理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面向切面编程&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://dongz.me/categories/java/"/>
    
    
      <category term="aop" scheme="https://dongz.me/tags/aop/"/>
    
  </entry>
  
  <entry>
    <title>风暴之Rocketmq消息有序</title>
    <link href="https://dongz.me/2018/10/25/%E9%A3%8E%E6%9A%B4%E4%B9%8BRocketmq%E6%B6%88%E6%81%AF%E6%9C%89%E5%BA%8F/"/>
    <id>https://dongz.me/2018/10/25/风暴之Rocketmq消息有序/</id>
    <published>2018-10-24T16:17:00.000Z</published>
    <updated>2018-12-02T14:25:57.171Z</updated>
    
    <content type="html"><![CDATA[<p>Rocketmq消息有序知识梳理<br><a id="more"></a></p><h1 id="风暴之Rocketmq消息有序"><a href="#风暴之Rocketmq消息有序" class="headerlink" title="风暴之Rocketmq消息有序"></a>风暴之Rocketmq消息有序</h1><p><img src="https://coding.net/u/alvin_me/p/blogpics/git/raw/master/rocketmq%E6%9C%89%E5%BA%8F.jpg" alt="">  </p><p><a href="http://www.edrawsoft.cn/viewer/public/s/44af6152338359" target="_blank" rel="noopener">看大图</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="https://www.zhihu.com/question/30195969" target="_blank" rel="noopener">rocketmq怎么保证队列完全顺序消费？</a><br>[2] <a href="https://www.jianshu.com/p/453c6e7ff81c" target="_blank" rel="noopener">分布式开放消息系统(RocketMQ)的原理与实践</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Rocketmq消息有序知识梳理&lt;br&gt;
    
    </summary>
    
      <category term="消息" scheme="https://dongz.me/categories/%E6%B6%88%E6%81%AF/"/>
    
    
      <category term="rocketmq" scheme="https://dongz.me/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>风暴之分布式事务</title>
    <link href="https://dongz.me/2018/10/24/%E9%A3%8E%E6%9A%B4%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <id>https://dongz.me/2018/10/24/风暴之分布式事务/</id>
    <published>2018-10-23T16:23:00.000Z</published>
    <updated>2018-12-10T17:06:23.075Z</updated>
    
    <content type="html"><![CDATA[<p>分布式事务是企业集成中的一个技术难点，也是每一个分布式系统架构中都会涉及到的一个东西，特别是在微服务架构中，几乎可以说是无法避免，本文通过思维导图做一个简单的知识梳理。<br><a id="more"></a></p><h1 id="风暴之分布式事务"><a href="#风暴之分布式事务" class="headerlink" title="风暴之分布式事务"></a>风暴之分布式事务</h1><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="800" height="800" src="http://edrawcloudpubliccn.oss-cn-shenzhen.aliyuncs.com/viewer/self/220828/share/2018-10-31/1540946315/main.svg"></iframe><p><a href="http://www.edrawsoft.cn/viewer/public/s/4c0fe347331170" target="_blank" rel="noopener">看大图</a></p><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p>[1] <a href="https://draveness.me/distributed-transaction-principle" target="_blank" rel="noopener">分布式事务的实现原理</a><br>[2] <a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" target="_blank" rel="noopener">聊聊分布式事务，再说说解决方案</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分布式事务是企业集成中的一个技术难点，也是每一个分布式系统架构中都会涉及到的一个东西，特别是在微服务架构中，几乎可以说是无法避免，本文通过思维导图做一个简单的知识梳理。&lt;br&gt;
    
    </summary>
    
      <category term="分布式" scheme="https://dongz.me/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式事务" scheme="https://dongz.me/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之传输对象模式</title>
    <link href="https://dongz.me/2018/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BC%A0%E8%BE%93%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongz.me/2018/10/21/设计模式之传输对象模式/</id>
    <published>2018-10-21T04:46:00.000Z</published>
    <updated>2018-10-21T04:47:51.901Z</updated>
    
    <content type="html"><![CDATA[<p>传输对象模式（Transfer Object Pattern）用于从客户端向服务器一次性传递带有多个属性的数据。传输对象也被称为数值对象。传输对象是一个具有 getter/setter 方法的简单的 POJO 类，它是可序列化的，所以它可以通过网络传输。它没有任何的行为。服务器端的业务类通常从数据库读取数据，然后填充 POJO，并把它发送到客户端或按值传递它。对于客户端，传输对象是只读的。客户端可以创建自己的传输对象，并把它传递给服务器，以便一次性更新数据库中的数值。以下是这种设计模式的实体。</p><ul><li><strong>业务对象（Business Object）</strong> - 为传输对象填充数据的业务服务。</li><li><strong>传输对象（Transfer Object）</strong> - 简单的 POJO，只有设置/获取属性的方法。</li><li><strong>客户端（Client）</strong> - 客户端可以发送请求或者发送传输对象到业务对象。<a id="more"></a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;传输对象模式（Transfer Object Pattern）用于从客户端向服务器一次性传递带有多个属性的数据。传输对象也被称为数值对象。传输对象是一个具有 getter/setter 方法的简单的 POJO 类，它是可序列化的，所以它可以通过网络传输。它没有任何的行为。服务器端的业务类通常从数据库读取数据，然后填充 POJO，并把它发送到客户端或按值传递它。对于客户端，传输对象是只读的。客户端可以创建自己的传输对象，并把它传递给服务器，以便一次性更新数据库中的数值。以下是这种设计模式的实体。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;业务对象（Business Object）&lt;/strong&gt; - 为传输对象填充数据的业务服务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;传输对象（Transfer Object）&lt;/strong&gt; - 简单的 POJO，只有设置/获取属性的方法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;客户端（Client）&lt;/strong&gt; - 客户端可以发送请求或者发送传输对象到业务对象。
    
    </summary>
    
      <category term="设计模式" scheme="https://dongz.me/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="传输对象模式" scheme="https://dongz.me/tags/%E4%BC%A0%E8%BE%93%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之服务定位器模式</title>
    <link href="https://dongz.me/2018/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%AE%9A%E4%BD%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongz.me/2018/10/21/设计模式之服务定位器模式/</id>
    <published>2018-10-21T04:44:00.000Z</published>
    <updated>2018-10-21T04:45:29.984Z</updated>
    
    <content type="html"><![CDATA[<p>服务定位器模式（Service Locator Pattern）用在我们想使用 JNDI 查询定位各种服务的时候。考虑到为某个服务查找 JNDI 的代价很高，服务定位器模式充分利用了缓存技术。在首次请求某个服务时，服务定位器在 JNDI 中查找服务，并缓存该服务对象。当再次请求相同的服务时，服务定位器会在它的缓存中查找，这样可以在很大程度上提高应用程序的性能。以下是这种设计模式的实体。</p><ul><li><strong>服务（Service）</strong> - 实际处理请求的服务。对这种服务的引用可以在 JNDI 服务器中查找到。</li><li><strong>Context / 初始的 Context</strong> - JNDI Context 带有对要查找的服务的引用。</li><li><strong>服务定位器（Service Locator）</strong> - 服务定位器是通过 JNDI 查找和缓存服务来获取服务的单点接触。</li><li><strong>缓存（Cache）</strong> - 缓存存储服务的引用，以便复用它们。</li><li><strong>客户端（Client）</strong> - Client 是通过 ServiceLocator 调用服务的对象。<a id="more"></a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;服务定位器模式（Service Locator Pattern）用在我们想使用 JNDI 查询定位各种服务的时候。考虑到为某个服务查找 JNDI 的代价很高，服务定位器模式充分利用了缓存技术。在首次请求某个服务时，服务定位器在 JNDI 中查找服务，并缓存该服务对象。当再次请求相同的服务时，服务定位器会在它的缓存中查找，这样可以在很大程度上提高应用程序的性能。以下是这种设计模式的实体。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;服务（Service）&lt;/strong&gt; - 实际处理请求的服务。对这种服务的引用可以在 JNDI 服务器中查找到。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Context / 初始的 Context&lt;/strong&gt; - JNDI Context 带有对要查找的服务的引用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务定位器（Service Locator）&lt;/strong&gt; - 服务定位器是通过 JNDI 查找和缓存服务来获取服务的单点接触。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓存（Cache）&lt;/strong&gt; - 缓存存储服务的引用，以便复用它们。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;客户端（Client）&lt;/strong&gt; - Client 是通过 ServiceLocator 调用服务的对象。
    
    </summary>
    
      <category term="设计模式" scheme="https://dongz.me/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="服务器定位模式" scheme="https://dongz.me/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9A%E4%BD%8D%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之拦截过滤器模式</title>
    <link href="https://dongz.me/2018/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%8B%A6%E6%88%AA%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongz.me/2018/10/21/设计模式之拦截过滤器模式/</id>
    <published>2018-10-21T04:41:00.000Z</published>
    <updated>2018-10-21T04:45:50.414Z</updated>
    
    <content type="html"><![CDATA[<p>拦截过滤器模式（Intercepting Filter Pattern）用于对应用程序的请求或响应做一些预处理/后处理。定义过滤器，并在把请求传给实际目标应用程序之前应用在请求上。过滤器可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。</p><ul><li><strong>过滤器（Filter）</strong> - 过滤器在请求处理程序执行请求之前或之后，执行某些任务。</li><li><strong>过滤器链（Filter Chain）</strong> - 过滤器链带有多个过滤器，并在 Target 上按照定义的顺序执行这些过滤器。</li><li><strong>Target</strong> - Target 对象是请求处理程序。</li><li><strong>过滤管理器（Filter Manager）</strong> - 过滤管理器管理过滤器和过滤器链。</li><li><strong>客户端（Client）</strong> - Client 是向 Target 对象发送请求的对象。<a id="more"></a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;拦截过滤器模式（Intercepting Filter Pattern）用于对应用程序的请求或响应做一些预处理/后处理。定义过滤器，并在把请求传给实际目标应用程序之前应用在请求上。过滤器可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;过滤器（Filter）&lt;/strong&gt; - 过滤器在请求处理程序执行请求之前或之后，执行某些任务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;过滤器链（Filter Chain）&lt;/strong&gt; - 过滤器链带有多个过滤器，并在 Target 上按照定义的顺序执行这些过滤器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Target&lt;/strong&gt; - Target 对象是请求处理程序。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;过滤管理器（Filter Manager）&lt;/strong&gt; - 过滤管理器管理过滤器和过滤器链。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;客户端（Client）&lt;/strong&gt; - Client 是向 Target 对象发送请求的对象。
    
    </summary>
    
      <category term="设计模式" scheme="https://dongz.me/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="拦截过滤器模式" scheme="https://dongz.me/tags/%E6%8B%A6%E6%88%AA%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之前端控制器模式</title>
    <link href="https://dongz.me/2018/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%89%8D%E7%AB%AF%E6%8E%A7%E5%88%B6%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongz.me/2018/10/21/设计模式之前端控制器模式/</id>
    <published>2018-10-21T04:40:00.000Z</published>
    <updated>2018-10-21T04:46:19.094Z</updated>
    
    <content type="html"><![CDATA[<p>前端控制器模式（Front Controller Pattern）是用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。</p><ul><li><strong>前端控制器（Front Controller）</strong> - 处理应用程序所有类型请求的单个处理程序，应用程序可以是基于 web 的应用程序，也可以是基于桌面的应用程序。</li><li><strong>调度器（Dispatcher）</strong> - 前端控制器可能使用一个调度器对象来调度请求到相应的具体处理程序。</li><li><strong>视图（View）</strong> - 视图是为请求而创建的对象。<a id="more"></a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端控制器模式（Front Controller Pattern）是用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;前端控制器（Front Controller）&lt;/strong&gt; - 处理应用程序所有类型请求的单个处理程序，应用程序可以是基于 web 的应用程序，也可以是基于桌面的应用程序。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;调度器（Dispatcher）&lt;/strong&gt; - 前端控制器可能使用一个调度器对象来调度请求到相应的具体处理程序。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;视图（View）&lt;/strong&gt; - 视图是为请求而创建的对象。
    
    </summary>
    
      <category term="设计模式" scheme="https://dongz.me/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="前端控制器模式" scheme="https://dongz.me/tags/%E5%89%8D%E7%AB%AF%E6%8E%A7%E5%88%B6%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之数据访问对象模式</title>
    <link href="https://dongz.me/2018/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongz.me/2018/10/21/设计模式之数据访问对象模式/</id>
    <published>2018-10-21T04:38:00.000Z</published>
    <updated>2018-10-21T04:39:48.091Z</updated>
    
    <content type="html"><![CDATA[<p>数据访问对象模式（Data Access Object Pattern）或 DAO 模式用于把低级的数据访问 API 或操作从高级的业务服务中分离出来。以下是数据访问对象模式的参与者。</p><ul><li><strong>数据访问对象接口（Data Access Object Interface）</strong> - 该接口定义了在一个模型对象上要执行的标准操作。</li><li><strong>数据访问对象实体类（Data Access Object concrete class）</strong> - 该类实现了上述的接口。该类负责从数据源获取数据，数据源可以是数据库，也可以是 xml，或者是其他的存储机制。</li><li><strong>模型对象/数值对象（Model Object/Value Object）</strong> - 该对象是简单的 POJO，包含了 get/set 方法来存储通过使用 DAO 类检索到的数据。<a id="more"></a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据访问对象模式（Data Access Object Pattern）或 DAO 模式用于把低级的数据访问 API 或操作从高级的业务服务中分离出来。以下是数据访问对象模式的参与者。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数据访问对象接口（Data Access Object Interface）&lt;/strong&gt; - 该接口定义了在一个模型对象上要执行的标准操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据访问对象实体类（Data Access Object concrete class）&lt;/strong&gt; - 该类实现了上述的接口。该类负责从数据源获取数据，数据源可以是数据库，也可以是 xml，或者是其他的存储机制。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;模型对象/数值对象（Model Object/Value Object）&lt;/strong&gt; - 该对象是简单的 POJO，包含了 get/set 方法来存储通过使用 DAO 类检索到的数据。
    
    </summary>
    
      <category term="设计模式" scheme="https://dongz.me/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="数据访问对象模式" scheme="https://dongz.me/tags/%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之组合实体模式</title>
    <link href="https://dongz.me/2018/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%84%E5%90%88%E5%AE%9E%E4%BD%93%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dongz.me/2018/10/21/设计模式之组合实体模式/</id>
    <published>2018-10-21T04:34:04.000Z</published>
    <updated>2018-10-21T04:35:59.932Z</updated>
    
    <content type="html"><![CDATA[<p>组合实体模式（Composite Entity Pattern）用在 EJB 持久化机制中。一个组合实体是一个 EJB 实体 bean，代表了对象的图解。当更新一个组合实体时，内部依赖对象 beans 会自动更新，因为它们是由 EJB 实体 bean 管理的。以下是组合实体 bean 的参与者。</p><ul><li><strong>组合实体（Composite Entity）</strong> - 它是主要的实体 bean。它可以是粗粒的，或者可以包含一个粗粒度对象，用于持续生命周期。</li><li><strong>粗粒度对象（Coarse-Grained Object）</strong> - 该对象包含依赖对象。它有自己的生命周期，也能管理依赖对象的生命周期。</li><li><strong>依赖对象（Dependent Object）</strong> - 依赖对象是一个持续生命周期依赖于粗粒度对象的对象。</li><li><strong>策略（Strategies）</strong> - 策略表示如何实现组合实体。<a id="more"></a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;组合实体模式（Composite Entity Pattern）用在 EJB 持久化机制中。一个组合实体是一个 EJB 实体 bean，代表了对象的图解。当更新一个组合实体时，内部依赖对象 beans 会自动更新，因为它们是由 EJB 实体 bean 管理的。以下是组合实体 bean 的参与者。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;组合实体（Composite Entity）&lt;/strong&gt; - 它是主要的实体 bean。它可以是粗粒的，或者可以包含一个粗粒度对象，用于持续生命周期。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;粗粒度对象（Coarse-Grained Object）&lt;/strong&gt; - 该对象包含依赖对象。它有自己的生命周期，也能管理依赖对象的生命周期。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;依赖对象（Dependent Object）&lt;/strong&gt; - 依赖对象是一个持续生命周期依赖于粗粒度对象的对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;策略（Strategies）&lt;/strong&gt; - 策略表示如何实现组合实体。
    
    </summary>
    
    
  </entry>
  
</feed>
