<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Maybe is Maybe"><title>jdk新特性之jdk6 | alvin's blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">jdk新特性之jdk6</h1><a id="logo" href="/.">alvin's blog</a><p class="description">Good memory is worse than bad writing</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">jdk新特性之jdk6</h1><div class="post-meta">Sep 26, 2018<span> | </span><span class="category"><a href="/categories/java/">java</a></span></div><div class="post-content"><p>jdk6新特性主要体现在如下模块：Desktop类和SystemTray类、使用JAXB2来实现对象与XML之间的映射、StAX、使用Compiler API、轻量级Http Server API、插入式注解处理API(Pluggable Annotation Processing API)、用Console开发控制台程序、对脚本语言的支持、Common Annotations及其它一些小改动。<br><a id="more"></a>  </p>
<h4 id="jdk6新特性"><a href="#jdk6新特性" class="headerlink" title="jdk6新特性"></a>jdk6新特性</h4><hr>
<h5 id="Desktop类和SystemTray类"><a href="#Desktop类和SystemTray类" class="headerlink" title="Desktop类和SystemTray类"></a>Desktop类和SystemTray类</h5><p>AWT新增加了两个类：Desktop和SystemTray<br>Desktop可以用来打开系统默认浏览器浏览指定的URL，打开系统默认邮件客户端给指定的邮箱发邮件，用默认应用程序打开或编辑文件，<br>用系统默认的打印机打印文档。<br>SystemTray可以在系统托盘区创建一个托盘程序。  </p>
<h5 id="使用JAXB2来实现对象与XML之间的映射"><a href="#使用JAXB2来实现对象与XML之间的映射" class="headerlink" title="使用JAXB2来实现对象与XML之间的映射"></a>使用JAXB2来实现对象与XML之间的映射</h5><p>JAXB是Java Architecture for XML Binding的缩写，可以将一个Java对象转变成为XML格式，反之亦然。<br>我们把对象与关系数据库之间的映射称为ORM，其实也可以把对象与XML之间的映射称为OXM（Object XML Mapping）。原来JAXB是Java EE<br>的一部分，在JDK1.6中，SUN将其放到了Java SE中，这也是SUN的一贯做法。JDK1.6中自带的这个JAXB版本是2.0，比起1.0来，JAXB2用JDK5<br>的新特性Annotation来标识要作绑定的类和属性，这就极大简化了开发的工作量。<br>实际上，在Java EE 5.0中，EJB和Web Services也通过Annotation来简化开发工作。另外，JAXB2在底层是用StAX(JSR 173)来处理XML文档。<br>除了JAXB之外，我们还可以通过XMLBeans和Castor等来实现同样的功能。  </p>
<h5 id="StAX"><a href="#StAX" class="headerlink" title="StAX"></a>StAX</h5><p>StAX(JSR 173)是JDK1.6.0中除了DOM和SAX之外的又一种处理XML文档的API。<br>StAX 的来历：在JAXP1.3(JSR 206)有两种处理XML文档的方法：DOM(Document Object Model)和SAX(Simple API for XML)。<br>由于JDK1.6.0中的JAXB2(JSR 222)和JAX-WS 2.0(JSR 224)都会用到StAX所以Sun决定把StAX加入到JAXP家族当中来，并将JAXP的版本升级到1.4(JAXP1.4是JAXP1.3的维护版本)。JDK1.6里面JAXP的版本就是1.4。<br>StAX是The Streaming API for XML的缩写，一种利用拉模式解析(pull-parsing)XML文档的API。StAX通过提供一种基于事件迭代器(Iterator)的API让程序员去控制xml文档解析过程，程序遍历这个事件迭代器去处理每一个解析事件，解析事件可以看做是程序拉出来的，也就是程序促使解析器产生一个解析事件然后处理该事件，之后又促使解析器产生下一个解析事件，如此循环直到碰到文档结束符；<br>SAX也是基于事件处理xml文档，但却是用推模式解析，解析器解析完整个xml文档后，才产生解析事件，然后推给程序去处理这些事件；DOM采用的方式是将整个xml文档映射到一颗内存树，这样就可以很容易地得到父节点和子结点以及兄弟节点的数据，但如果文档很大，将会严重影响性能。  </p>
<h5 id="使用Compiler-API"><a href="#使用Compiler-API" class="headerlink" title="使用Compiler API"></a>使用Compiler API</h5><p>现在我 们可以用JDK1.6 的Compiler API(JSR 199)去动态编译Java源文件，Compiler API结合反射功能就可以实现动态的产生Java代码并编译执行这些代码，有点动态语言的特征。<br>这个特性对于某些需要用到动态编译的应用程序相当有用，比如JSP Web Server，当我们手动修改JSP后，是不希望需要重启Web Server才可以看到效果的，这时候我们就可以用Compiler API来实现动态编译JSP文件，当然，现在的JSP Web Server也是支持JSP热部署的，现在的JSP Web Server通过在运行期间通过Runtime.exec或ProcessBuilder来调用javac来编译代码，这种方式需要我们产生另一个进程去做编译工作，不够优雅而且容易使代码依赖与特定的操作系统；Compiler API通过一套易用的标准的API提供了更加丰富的方式去做动态编译，而且是跨平台的。  </p>
<h5 id="轻量级Http-Server-API"><a href="#轻量级Http-Server-API" class="headerlink" title="轻量级Http Server API"></a>轻量级Http Server API</h5><p>JDK1.6 提供了一个简单的Http Server API，据此我们可以构建自己的嵌入式Http Server，它支持Http和Https协议，提供了HTTP1.1的部分实现，没有被实现的那部分可以通过扩展已有的Http Server API来实现，程序员必须自己实现HttpHandler接口，HttpServer会调用HttpHandler实现类的回调方法来处理客户端请求，在这里，我们把一个Http请求和它的响应称为一个交换，包装成HttpExchange类，HttpServer负责将HttpExchange传给HttpHandler实现类的回调方法。  </p>
<h5 id="插入式注解处理API-Pluggable-Annotation-Processing-API"><a href="#插入式注解处理API-Pluggable-Annotation-Processing-API" class="headerlink" title="插入式注解处理API(Pluggable Annotation Processing API)"></a>插入式注解处理API(Pluggable Annotation Processing API)</h5><p>插入式注解处理API(JSR 269)提供一套标准API来处理Annotations(JSR 175)。<br>实际上JSR 269不仅仅用来处理Annotation，我觉得更强大的功能是它建立了Java语言本身的一个模型，它把method，package，constructor，type，variable， enum，annotation等Java语言元素映射为Types和Elements(两者有什么区别?)，从而将Java语言的语义映射成为对象，我们可以在javax.lang.model包下面可以看到这些类。 所以我们可以利用JSR 269提供的API来构建一个功能丰富的元编程(metaprogramming)环境。<br>JSR 269用Annotation Processor在编译期间而不是运行期间处理Annotation，Annotation Processor相当于编译器的一个插件，所以称为插入式注解处理.如果Annotation Processor处理Annotation时(执行process方法)产生了新的Java代码，编译器会再调用一次Annotation Processor，如果第二次处理还有新代码产生，就会接着调用Annotation Processor，直到没有新代码产生为止.每执行一次process()方法被称为一个”round”，这样整个Annotation processing过程可以看作是一个round的序列。<br>JSR 269主要被设计成为针对Tools或者容器的API. 举个例子，我们想建立一套基于Annotation的单元测试框架(如TestNG)，在测试类里面用Annotation来标识测试期间需要执行的测试方法。  </p>
<h5 id="用Console开发控制台程序"><a href="#用Console开发控制台程序" class="headerlink" title="用Console开发控制台程序"></a>用Console开发控制台程序</h5><p>JDK1.6中提供了java.io.Console 类专用来访问基于字符的控制台设备。你的程序如果要与Windows下的cmd或者Linux下的Terminal交互，就可以用Console类代劳。但我们不总是能得到可用的Console，一个JVM是否有可用的Console依赖于底层平台和JVM如何被调用。如果JVM是在交互式命令行(比如Windows的cmd)中启动的，并且输入输出没有重定向到另外的地方，那么就可以得到一个可用的Console实例。  </p>
<h5 id="对脚本语言的支持"><a href="#对脚本语言的支持" class="headerlink" title="对脚本语言的支持"></a>对脚本语言的支持</h5><p>如：ruby，groovy，javascript。  </p>
<h5 id="Common-Annotations"><a href="#Common-Annotations" class="headerlink" title="Common Annotations"></a>Common Annotations</h5><p>Common annotations原本是Java EE 5.0(JSR 244)规范的一部分，现在SUN把它的一部分放到了Java SE 6.0中。<br>随着Annotation元数据功能(JSR 175)加入到Java SE 5.0里面，很多Java 技术(比如EJB，Web Services)都会用Annotation部分代替XML文件来配置运行参数（或者说是支持声明式编程,如EJB的声明式事务），如果这些技术为通用目的都单独定义了自己的Annotations,显然有点重复建设, 所以,为其他相关的Java技术定义一套公共的Annotation是有价值的，可以避免重复建设的同时，也保证Java SE和Java EE 各种技术的一致性。  </p>
<h5 id="有一些小的改动"><a href="#有一些小的改动" class="headerlink" title="有一些小的改动"></a>有一些小的改动</h5><p><strong>如下方法获取磁盘使用信息：</strong><br>getTotalSpace() - 返回此抽象路径名指定的分区大小。以字节为单位。  getFreeSpace() - 返回此抽象路径名指定的分区中未分配的字节数。<br>getUsableSpace() - 返回此抽象路径名指定的分区上可用于此虚拟机的字节数。若有可能，此方法将检查写权限和其他操作系统限制，因此与 getFreeSpace() 相比，此方法能更准确地估计可实际写入的新数据数。 </p>
<p><strong>如下方法获取文件权限：</strong><br>setWritable(boolean writable, boolean ownerOnly) 和 setWritable(boolean writable) - 设置此抽象路径名的所有者或所有用户的写权限。<br>setReadable(boolean readable, boolean ownerOnly) 和 setReadable(boolean readable) - 设置此抽象路径名的所有者或所有用户的读权限。<br>setExecutable(boolean executable, boolean ownerOnly) 和 setExecutable(boolean executable) - 设置此抽象路径名的所有者或所有用户的执行权限。<br>canExecute() - 测试应用程序是否可以执行此抽象路径名表示的文件。 </p>
<p><strong>IOException类增加构造函数</strong><br>IOException支持异常链通过新的构造函数：IOException(String, Throwable) 和IOException(Throwable)。<br>File.isFile()方法的行为发生变化。<br>Windows环境下对保留设备名如： CON, NUL, AUX, LPT, 等等，永远返回false。  </p>
<p><strong>java GUI界面的显示的改动</strong><br>JDK6.0（也就是JDK1.6）支持最新的windows vista系统的Windows Aero视窗效果，而JDK1.5不支持。<br>你要在vista环境下编程的话最好装jdk6.0，否则它总是换到windows basic视窗效果。  </p>
<p><strong>java.nio模块，增加java.nio.channels.SelectorProvider实现类等</strong></p>
</div><div class="tags"><a href="/tags/jdk/">jdk</a></div><div class="post-nav"><a class="pre" href="/2018/09/26/jdk新特性之jdk7/">jdk新特性之jdk7</a><a class="next" href="/2018/09/26/java编程思想-21/">java编程思想[21]-并发</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://dongme.site"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/music/">music</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/schedule/">schedule</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring-cloud/">spring cloud</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/"> 分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/名词解释/">名词解释</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂记/">杂记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/传输对象模式/" style="font-size: 15px;">传输对象模式</a> <a href="/tags/B2C/" style="font-size: 15px;">B2C</a> <a href="/tags/P2P/" style="font-size: 15px;">P2P</a> <a href="/tags/C2C/" style="font-size: 15px;">C2C</a> <a href="/tags/编程思想/" style="font-size: 15px;">编程思想</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/jdk/" style="font-size: 15px;">jdk</a> <a href="/tags/小记/" style="font-size: 15px;">小记</a> <a href="/tags/markdown/" style="font-size: 15px;">markdown</a> <a href="/tags/快捷键/" style="font-size: 15px;">快捷键</a> <a href="/tags/适配器模式/" style="font-size: 15px;">适配器模式</a> <a href="/tags/桥接模式/" style="font-size: 15px;">桥接模式</a> <a href="/tags/中介者模式/" style="font-size: 15px;">中介者模式</a> <a href="/tags/B2B/" style="font-size: 15px;">B2B</a> <a href="/tags/前端控制器模式/" style="font-size: 15px;">前端控制器模式</a> <a href="/tags/命令模式/" style="font-size: 15px;">命令模式</a> <a href="/tags/外观模式/" style="font-size: 15px;">外观模式</a> <a href="/tags/拦截过滤器模式/" style="font-size: 15px;">拦截过滤器模式</a> <a href="/tags/数据访问对象模式/" style="font-size: 15px;">数据访问对象模式</a> <a href="/tags/服务器定位模式/" style="font-size: 15px;">服务器定位模式</a> <a href="/tags/组合模式/" style="font-size: 15px;">组合模式</a> <a href="/tags/装饰器模式/" style="font-size: 15px;">装饰器模式</a> <a href="/tags/解释器模式/" style="font-size: 15px;">解释器模式</a> <a href="/tags/访问者模式/" style="font-size: 15px;">访问者模式</a> <a href="/tags/过滤器模式/" style="font-size: 15px;">过滤器模式</a> <a href="/tags/分布式事务/" style="font-size: 15px;">分布式事务</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/10/24/风暴之分布式事务/">风暴之分布式事务</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/21/设计模式之传输对象模式/">设计模式之传输对象模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/21/设计模式之服务定位器模式/">设计模式之服务定位器模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/21/设计模式之拦截过滤器模式/">设计模式之拦截过滤器模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/21/设计模式之前端控制器模式/">设计模式之前端控制器模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/21/设计模式之数据访问对象模式/">设计模式之数据访问对象模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/21/设计模式之组合实体模式/">设计模式之组合实体模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/21/设计模式之业务代表模式/">设计模式之业务代表模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/21/设计模式之MVC-模式/">设计模式之MVC 模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/21/设计模式之访问者模式/">设计模式之访问者模式</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">alvin's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>