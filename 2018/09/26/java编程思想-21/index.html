<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Maybe is Maybe"><title>java编程思想[21]-并发 | alvin's blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">java编程思想[21]-并发</h1><a id="logo" href="/.">alvin's blog</a><p class="description">Good memory is worse than bad writing</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">java编程思想[21]-并发</h1><div class="post-meta">Sep 26, 2018</div><div class="post-content"><p>并发老生常谈，确实也是java中十分重要的模块，该部分重点讲解并发相关的零碎知识点。<br><a id="more"></a>   </p>
<h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><hr>
<h5 id="并发的多面性"><a href="#并发的多面性" class="headerlink" title="并发的多面性"></a>并发的多面性</h5><p>用并发解决的问题大体上可以分为速度和设计可管理性两种。  </p>
<ul>
<li>更快的执行<br>为了程序运行的更快，并发充分利用这些额外的处理器。<br>单核处理器上并发带来的开销比顺序执行大，因为其中增加了大量的上下文切换。但在单核上使用并发可以防止程序停止，即使一个任务阻塞了，其它任务可以继续执行。  </li>
<li>改进代码设计<br>单核机器通过并发可以仿真，仿真目标一般都是多任务的，每个线程处理单独的任务。  </li>
</ul>
<h5 id="基本的线程机制"><a href="#基本的线程机制" class="headerlink" title="基本的线程机制"></a>基本的线程机制</h5><p>并发编程使我们可以将程序划分为多个分离的、独立运行的任务。通过使用多线程机制，这些独立任务中的每一个都将由执行线程来驱动。  </p>
<ul>
<li>定义任务<br>实现Runnable接口，实现方法run。<br>在main方法中直接调用run方法，是顺序执行，并不会启动一个新的线程处理。  </li>
<li>Thread类<br>将Runnable对象转变为工作任务的传统方式是把它提交给一个Thread构造器。  </li>
<li><p>使用Executor  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">for()&#123;</span><br><span class="line">   exec.execute(实现Runnable的对象实例);</span><br><span class="line">&#125;</span><br><span class="line">exec.shutdown();</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">可以将上面的CachedThreadPool替换为不同类型的Executor。FixedThreadPool使用了有限的线程集来执行所提交的任务。  </span><br><span class="line">``` </span><br><span class="line">ExecutorService exec = Executor.newFixedThreadPool(5);</span><br><span class="line">for()&#123;</span><br><span class="line">    exec.execute(实现Runnable的对象实例);</span><br><span class="line">&#125;</span><br><span class="line">exec.shutdown();</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">SingleThreadExecutor就像是线程数量为1的FixedTreadPool。这对于希望在另一个线程中连续运行的事物来说，都是很有用的。  </span><br><span class="line">``` </span><br><span class="line">ExecutorService exec = Executor.SingleThreadExecutor();</span><br><span class="line">for()&#123;</span><br><span class="line">    exec.execute(实现Runnable的对象实例);</span><br><span class="line">&#125;</span><br><span class="line">exec.shutdown();</span><br></pre></td></tr></table></figure>
</li>
<li><p>从任务中产生返回值<br>Runnable独立执行任务，不返回值。Callable是一种具有类型参数的泛型，它的类型参数表示的是从call()方法返回的值，并且必须使用ExecutorService.submit()方法调用它。如下： </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line">class TaskWithResult implements Callable&lt;String&gt; &#123;</span><br><span class="line">    private int id;</span><br><span class="line"></span><br><span class="line">    public TaskWithResult(int id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        return &quot;result of TaskWithResult &quot; + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CallableDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        ArrayList&lt;Future&lt;String&gt;&gt; results = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            results.add(exec.submit(new TaskWithResult(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        for (Future&lt;String&gt; fs : results) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(fs.get());</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">                return;</span><br><span class="line">            &#125; catch (ExecutionException e) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;finally &#123;</span><br><span class="line">                exec.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">+ 休眠  </span><br><span class="line">sleep(long)将使任务中止执行指定时间。  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">try &#123;</span><br><span class="line">  TimeUnit.MILLISECONDS.sleep(100);</span><br><span class="line">&#125; catch (InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">+ 优先级  </span><br><span class="line">线程的优先级将该线程的重要性传递给了调度器。优先级较低的线程仅仅是执行的频率较低。  </span><br><span class="line">设置线程的优先级通过setPriority()方法进行设置。  </span><br><span class="line"></span><br><span class="line">+ 后台线程即守护线程  </span><br><span class="line">当所有非后台线程结束时，程序也就终止了，同时会杀死进程中所有的后台线程。  </span><br><span class="line">只要有任何非后台线程还在执行，程序就不好终止。  </span><br><span class="line">通过setDeamon()方法设置为后台线程。</span><br><span class="line"></span><br><span class="line">+ 让步</span><br><span class="line">调用yield()时，你也是在建议具有相同优先级的其他线程可以运行。</span><br><span class="line"></span><br><span class="line">+ 编码的变体</span><br><span class="line">通过继承Thread创建线程类。通过构造器设置线程名。</span><br><span class="line"></span><br><span class="line">+ 术语</span><br><span class="line">任务和线程并不等价。在描述将要执行的任务时使用术语&quot;任务&quot;，只有在引用到驱动任务的具体机制时，才使用线程。只在概念</span><br><span class="line">级别上讨论系统，就可以只使用任务，而不需要提及驱动机制。</span><br><span class="line"></span><br><span class="line">+ 加入一个线程</span><br><span class="line">一个线程可以在其他线程之上调用join()方法，其效果是等待一段时间直到第二个线程结束才继续执行。如果某个线程在另一个线程t上调用</span><br><span class="line">t.join()，此线程将被挂起，直到目标t结束才恢复（即t.isAlive()返回为false）。</span><br><span class="line">也可以在调用join()时带上一个超时参数，如果目标线程在这段时间到期时还没有结束，join()总能返回。</span><br><span class="line">对join()对方法调用可以被中断，做法是在调用线程上调用interrupt()方法，这时需要用到try-catch字句。  </span><br><span class="line"></span><br><span class="line">+ 线程组  </span><br><span class="line">线程组持有一个线程集合。可以把线程组看成是一次不成功的尝试，忽略就好。  </span><br><span class="line"></span><br><span class="line">+ 捕获异常  </span><br><span class="line">由于线程的本质特性，使得你不能捕获从线程中逃逸的异常。一旦异常逃出任务的run()方法，它就会向外传播到控制台。可以用Executor来解决这个问题。</span><br><span class="line">通过在每个Thread对象上都附着一个异常处理器。Thread.UncaughtExceptionHandler.uncaughtException()会在线程因未捕获的异常而临近死亡时被调用。创建一个新类型的ThreadFactory，</span><br><span class="line">它将在每个新创建的Thread对象上附着一个Thread.UncaughtExceptionHandler。  </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">class ExceptionThread2 implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        System.out.println(&quot;run() by &quot; + t);</span><br><span class="line">        System.out.println(&quot;eh = &quot; + t.getUncaughtExceptionHandler());</span><br><span class="line">        throw new RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void uncaughtException(Thread t, Throwable e) &#123;</span><br><span class="line">        System.out.println(&quot;caught &quot; + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HandlerThreadFactory implements ThreadFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Thread newThread(Runnable r) &#123;</span><br><span class="line">        System.out.println(this + &quot;creating new Thread&quot;);</span><br><span class="line">        Thread t = new Thread(r);</span><br><span class="line">        System.out.println(&quot;created &quot; + t);</span><br><span class="line">        t.setUncaughtExceptionHandler(new MyUncaughtExceptionHandler());</span><br><span class="line">        System.out.println(&quot;eh = &quot; + t.getUncaughtExceptionHandler());</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CaptureUncaughtException &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool(new HandlerThreadFactory());</span><br><span class="line">        exec.execute(new ExceptionThread2());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">##### 共享受限资源  </span><br><span class="line">基本上所有的并发模式在解决线程冲突问题的时候，都是采用序列化访问共享资源的方案。  </span><br><span class="line">在共享资源的代码前加锁语句来实现，使得一段时间内只有一个任务访问共享资源。锁语句产生了一种互相排斥的效果，所以这种机制常常称为互斥量。  </span><br><span class="line"></span><br><span class="line">+ 描述  </span><br><span class="line"></span><br><span class="line">屋子里的浴室实例：房子里的多个人都希望单独使用浴室。为了使用浴室，一个人先敲门，看看能否使用。如果没人的话，他就进入浴室锁上门。这时其它人</span><br><span class="line">要使用浴室的话，就会被阻挡，所以他们要在门口等待，直到浴室可用。  </span><br><span class="line">当浴室使用完毕，当锁住浴室门的那个人打开锁准备离开的时候，簇拥在门口的人中，离门口最近的那个最有可能成为下一个进入浴室的人。可以通过yield</span><br><span class="line">和setPriority来给线程调度器建议，但这些建议未必有多大效果，这取决于具体的平台和JVM实现。  </span><br><span class="line"></span><br><span class="line">共享资源一般是以对象存在的内存片段，但也可以是文件、输入/输出端口、或者是打印机。要控制对共享资源的访问，得先把它包装成对象，然后把所有要</span><br><span class="line">访问这个资源的方法都标记为synchronized。  </span><br><span class="line"></span><br><span class="line">在使用并发时，将域设置为private是非常重要的。否则，synchronized就不能防止其它任务直接访问域，这样就会产生冲突。  </span><br><span class="line"></span><br><span class="line">一个任务可以多次获得对象的锁，如果调用了一个对象的同步方法，方法中又调用了同一对象的另一个同步方法，JVM负责跟踪统计对象加锁的次数，每进入这个对象</span><br><span class="line">的同步方法，计数加1；每退出这个对象的同步方法，计数减一。如果对象被解锁，计数为0。  </span><br><span class="line"></span><br><span class="line">针对每个类，也有一个锁（作为类的Class对象的一部分），所以synchronized static可以在类的范围内防止对static数据的并发访问。  </span><br><span class="line"></span><br><span class="line">每个访问临界共享资源的方法都应该被同步，否则它们就不能正确的工作。  </span><br><span class="line"></span><br><span class="line">+ 使用显式的Lock对象  </span><br><span class="line"></span><br><span class="line">java.util.concurrent类库包含定义在java.util.concurrent.locks中显示的互斥机制。Lock对象必须被显式地创建、锁定</span><br><span class="line">和释放。与内建的锁形式相比，代码缺乏优雅性，出错的可能性比较大。但是，对于解决某些类型的问题来说，它更加灵活。  </span><br><span class="line"></span><br><span class="line">+ 原子性与易变性  </span><br><span class="line"></span><br><span class="line">原子操作是不能被线程调度机制中断的操作；一旦操作开始，那么它一定在 &quot;上下文切换&quot; 之前执行完毕。原子性不能替代同步，除非</span><br><span class="line">有十足的把握。  </span><br><span class="line">原子性可以应用于除long和double之外的所有基本类型之上的简单操作。当你定义long或double变量时，如果使用volatitle</span><br><span class="line">关键字，就会获得原子性。  </span><br><span class="line"></span><br><span class="line">在多处理器系统上，相对于单处理器系统而言，可视性问题远比原子性问题多得多。一个任务做出的修改，即使在不中断的意义上讲</span><br><span class="line">是原子性的，对其他任务也可能是不可视的。  </span><br><span class="line"></span><br><span class="line">volatitle确保了应用中的可视性。一个域声明为volatitle的，那么只要对这个域产生了写操作，那么所有的读操作就都可以看到</span><br><span class="line">这个修改。volatitle域会立即被写入到主内存中，而读取操作就发生在主内存中。  </span><br><span class="line"></span><br><span class="line">synchronized会将工作内存变量值刷新到主内存中，用synchronized一般不需要volatitle。  </span><br><span class="line"></span><br><span class="line">使用volatile而不是synchronized关键字的唯一安全的情况是类中只有一个可变的域。再次提醒，你的第一选择应该是使用synchronized</span><br><span class="line">关键字，这是最安全的方式，而尝试其他任何方式都是有风险的。</span><br><span class="line"></span><br><span class="line">+ 原子类  </span><br><span class="line"></span><br><span class="line">AtomicInteger、AtomicLong、AtomicReference等原子变量类，一般涉及到性能调优会用到。常规编程也很少用到。  </span><br><span class="line"></span><br><span class="line">+ 临界区  </span><br><span class="line"></span><br><span class="line">也称为同步代码块；防止多个线程同时访问方法内部的部分代码而不是防止访问整个方法。通过这种方式分离出的代码段被称为</span><br><span class="line">临界区，形式如下：  </span><br><span class="line">``` </span><br><span class="line">synchronized(syncObject) &#123;</span><br><span class="line">  //</span><br><span class="line">  //</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在其他对象上同步   </li>
</ul>
<p>synchronized块必须给定一个在其上进行同步的对象，使用synchronized(this)时，其他synchronized方法和临界区就不能<br>被调用。因此一般设置一个私有成员变量，以该变量作为同步对象。  </p>
<ul>
<li>线程本地存储  </li>
</ul>
<p>线程本地存储是一种自动化机制，可以为使用相同变量的每个不同的线程都创建不同的存储。<br>创建和管理本地存储一般使用java.lang.ThreadLocal类来实现。<br>ThreadLocal对象通常当作静态域存储。在创建ThreadLocal时，你只能通过get()和set()方法来访问该对象内容。<br>其中get()方法将返回与其线程相关联的对象的副本，而set()会将参数插入到为其线程存储的对象中，并返回存储中<br>原有的对象。  </p>
<h5 id="终结任务"><a href="#终结任务" class="headerlink" title="终结任务"></a>终结任务</h5><ul>
<li>装饰性花园  </li>
<li>在阻塞时终结  </li>
</ul>
<p>sleep()的一种情况，它使任务从执行状态变为被阻塞状态，而有时你必须终止被阻塞的任务。  </p>
<p><strong>线程状态</strong><br>1）新建（New）:当线程被创建时，它只会短暂地处于这种状态。此时它已经分配了必须的系统资源，并执行了<br>初始化。此刻线程已有资格获得CPU时间了，之后调度器将把这个线程转变为可运行状态或阻塞状态。<br>2）就绪（Runnable）：在这种状态下，只要调度器把时间片分配给线程，线程就可以运行。<br>3）阻塞（Blocked）：线程能够运行，但有某个条件阻止它的运行。当线程处于阻塞状态时，调度器将忽略线程，不会<br>分配线程任何cpu时间。直到线程重新进入就绪状态。<br>4）死亡（Dead）：处于死亡或终止状态的线程将不再是可调度的，并且再也不会得到cpu时间，它的任务已结束，或不再<br>是可运行的。任务死亡的通常方式是从run()方法返回，但是任务的线程还可以被中断。  </p>
<p><strong>进入阻塞状态</strong><br>进入阻塞状态的原因有如下：<br>1）通过调用sleep(milliseconds)使任务进入休眠状态，在这种情况下，任务在指定时间内不会运行。<br>2）调用wait()使线程挂起。直到线程得到了notify()或notifyAll()的消息（或在java.util.concurrent类库中等价的signal()或signalAll()消息），<br>线程才会进入就绪状态。<br>3）任务在等待某个输入/输出完成。<br>4）任务试图在某个对象上调用其同步控制方法，但是对象锁不可用，因为另一个任务已经获取了这个锁。<br>在较早的代码中可能看到suspend()和resume()来阻塞和唤醒线程，因为可能导致死锁，现在已经废弃了。stop()<br>方法也已经被弃用了，因为它不释放线程获得的锁，并且如果线程处于不一致状态，其它任务可以在这种状态下浏览并<br>修改它们，造成的问题难以发现。  </p>
<ul>
<li><p>中断<br>异常中断通过调用Thread的interrupt()方法。<br>当线程抛出异常InterruptedException或调用中断方法时，中断状态将被复位。<br>SleepBlocked是可中断，IOBlocked和SynchronizedBlocked是不可以中断的，对于这类问题可以关闭任务在其上发生阻塞的底层资源。  </p>
</li>
<li><p>被互斥所阻塞  </p>
</li>
<li>检查中断<br>通过调用interrupted()来检查中断状态。  </li>
</ul>
<h5 id="线程之间的协作"><a href="#线程之间的协作" class="headerlink" title="线程之间的协作"></a>线程之间的协作</h5><ul>
<li>wait()与notifyAll()<br>调用sleep()和yield()时候锁并没有被释放。<br>wait()调用时，线程将被挂起，对象上的锁被释放。在该对象上的其它synchronized方法在wait()期间被调用。<br>两种形式的wait：第一种接受毫秒作为参数，意为在此期间等待；第二种没有参数，一直等待。两种方式都可以通过notify和notifyAll恢复执行。<br>wait、notify、notifyAll这些方法是基类Object的一部分。在调用这些方法前必须先获取该对象的锁。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sychronized(x) &#123;</span><br><span class="line">    x.notifyAll();</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">+ 错失的信号  </span><br><span class="line">+ notify()与nitifyAll()  </span><br><span class="line">使用nitify()而不是nitifyAll()是一种优化。  </span><br><span class="line">使用notify()时，在众多等待同一个锁的任务中只有一个会被唤醒，因此要使用notify就必须保证被唤醒的是恰当的任务。  </span><br><span class="line"></span><br><span class="line">+ 生产者与消费者  </span><br><span class="line"></span><br><span class="line">+ 使用显示的Lock和Condition对象</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>private Lock lock = new ReentrantLock();<br>private Condition condition = lock.newCondition();<br>public void test() {<br>    lock.lock();<br>    try {<br>      condition.await();<br>      condition.signalAll();//<br>    } finally {<br>      lock.unlock();<br>    }<br>}<br>```  </p>
<ul>
<li>生产者-消费者队列  </li>
<li>任务间使用管道进行输入/输出  </li>
</ul>
<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><h5 id="新类库中的构件"><a href="#新类库中的构件" class="headerlink" title="新类库中的构件"></a>新类库中的构件</h5><ul>
<li>CountDownLatch<br>它被用来同步一个或多个任务，强制它们等待由其他任务执行的一组操作完成。不能充值。  </li>
<li>CyclicBarrier<br>你希望创建一组任务，它们并行地执行工作，然后在进行下一个步骤之前等待，直至所有任务都完成。可以重置。  </li>
<li>DelayQueue<br>一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象的延迟<br>到期的时间最长。如果没有任何延迟到期，那么就不会有任何头元素。  </li>
<li>PriorityBlockingQueue<br>这是一个很基础的优先级队列，它具有可阻塞的读取操作。  </li>
<li>使用ScheduledExecutor的温室控制器  </li>
<li>Semaphore<br>计数信号量允许n个任务同时访问这个资源。  </li>
<li>Exchanger<br>Exchanger是在两个任务之间交换对象的栅栏。当这些任务进入栅栏时，它们各自拥有一个对象，当它们离开时，它们都拥有之前由对象持有的对象。  </li>
</ul>
<h5 id="仿真"><a href="#仿真" class="headerlink" title="仿真"></a>仿真</h5><h5 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h5><h5 id="活动对象"><a href="#活动对象" class="headerlink" title="活动对象"></a>活动对象</h5></div><div class="tags"><a href="/tags/编程思想/">编程思想</a></div><div class="post-nav"><a class="pre" href="/2018/09/26/jdk新特性之jdk6/">jdk新特性之jdk6</a><a class="next" href="/2018/09/25/java编程思想-17/">java编程思想[17]-容器</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://dongme.site"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/music/">music</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/schedule/">schedule</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring-cloud/">spring cloud</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/名词解释/">名词解释</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂记/">杂记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/中介者模式/" style="font-size: 15px;">中介者模式</a> <a href="/tags/B2C/" style="font-size: 15px;">B2C</a> <a href="/tags/P2P/" style="font-size: 15px;">P2P</a> <a href="/tags/C2C/" style="font-size: 15px;">C2C</a> <a href="/tags/编程思想/" style="font-size: 15px;">编程思想</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/jdk/" style="font-size: 15px;">jdk</a> <a href="/tags/小记/" style="font-size: 15px;">小记</a> <a href="/tags/markdown/" style="font-size: 15px;">markdown</a> <a href="/tags/快捷键/" style="font-size: 15px;">快捷键</a> <a href="/tags/适配器模式/" style="font-size: 15px;">适配器模式</a> <a href="/tags/桥接模式/" style="font-size: 15px;">桥接模式</a> <a href="/tags/B2B/" style="font-size: 15px;">B2B</a> <a href="/tags/传输对象模式/" style="font-size: 15px;">传输对象模式</a> <a href="/tags/前端控制器模式/" style="font-size: 15px;">前端控制器模式</a> <a href="/tags/命令模式/" style="font-size: 15px;">命令模式</a> <a href="/tags/外观模式/" style="font-size: 15px;">外观模式</a> <a href="/tags/拦截过滤器模式/" style="font-size: 15px;">拦截过滤器模式</a> <a href="/tags/数据访问对象模式/" style="font-size: 15px;">数据访问对象模式</a> <a href="/tags/服务器定位模式/" style="font-size: 15px;">服务器定位模式</a> <a href="/tags/组合模式/" style="font-size: 15px;">组合模式</a> <a href="/tags/装饰器模式/" style="font-size: 15px;">装饰器模式</a> <a href="/tags/解释器模式/" style="font-size: 15px;">解释器模式</a> <a href="/tags/访问者模式/" style="font-size: 15px;">访问者模式</a> <a href="/tags/过滤器模式/" style="font-size: 15px;">过滤器模式</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/10/21/设计模式之传输对象模式/">设计模式之传输对象模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/21/设计模式之服务定位器模式/">设计模式之服务定位器模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/21/设计模式之拦截过滤器模式/">设计模式之拦截过滤器模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/21/设计模式之前端控制器模式/">设计模式之前端控制器模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/21/设计模式之数据访问对象模式/">设计模式之数据访问对象模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/21/设计模式之组合实体模式/">设计模式之组合实体模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/21/设计模式之业务代表模式/">设计模式之业务代表模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/21/设计模式之MVC-模式/">设计模式之MVC 模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/21/设计模式之访问者模式/">设计模式之访问者模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/21/设计模式之/">设计模式之模板模式</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">alvin's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>