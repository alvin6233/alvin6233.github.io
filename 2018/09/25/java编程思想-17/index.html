<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>java编程思想[17]-容器 | alvin&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="编程思想" />
  
  
  
  
  <meta name="description" content="在Java当中，如果有一个类专门用来存放其它类的对象，这个类就叫做容器，或者就叫做集合，集合就是将若干性质相同或相近的类对象组合在一起而形成的一个整体。">
<meta name="keywords" content="编程思想">
<meta property="og:type" content="article">
<meta property="og:title" content="java编程思想[17]-容器">
<meta property="og:url" content="https://dongme.site/2018/09/25/java编程思想-17/index.html">
<meta property="og:site_name" content="alvin&#39;s blog">
<meta property="og:description" content="在Java当中，如果有一个类专门用来存放其它类的对象，这个类就叫做容器，或者就叫做集合，集合就是将若干性质相同或相近的类对象组合在一起而形成的一个整体。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-11-26T15:44:55.330Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java编程思想[17]-容器">
<meta name="twitter:description" content="在Java当中，如果有一个类专门用来存放其它类的对象，这个类就叫做容器，或者就叫做集合，集合就是将若干性质相同或相近的类对象组合在一起而形成的一个整体。">
  
    <link rel="alternate" href="/atom.xml" title="alvin&#39;s blog" type="application/atom+xml">
  

  

  <link rel="icon" href="/css/images/mylogo.jpg">
  <link rel="apple-touch-icon" href="/css/images/mylogo.jpg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>
  <script src="/js/bootstrap.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >

  
    <link rel="stylesheet" href="/css/dialog.css">
  

  

  
    <link rel="stylesheet" href="/css/header-post.css" >
  

  
  
  
    <link rel="stylesheet" href="/css/vdonate.css" >
  

</head>



  <body data-spy="scroll" data-target="#toc" data-offset="50">


  
  <div id="container">
    <div id="wrap">
      
        <header>

    <div id="allheader" class="navbar navbar-default navbar-static-top" role="navigation">
        <div class="navbar-inner">
          
          <div class="container"> 
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>

            
              <a class="brand" style="
                 margin-top: 0px;"  
                href="#" data-toggle="modal" data-target="#myModal" >
                  <img width="124px" height="124px" alt="Hike News" src="/css/images/mylogo.jpg">
              </a>
            
            
            <div class="navbar-collapse collapse">
              <ul class="hnav navbar-nav">
                
                  <li> <a class="main-nav-link" href="/">首页</a> </li>
                
                  <li> <a class="main-nav-link" href="/archives">归档</a> </li>
                
                  <li> <a class="main-nav-link" href="/categories">分类</a> </li>
                
                  <li> <a class="main-nav-link" href="/tags">标签</a> </li>
                
                  <li> <a class="main-nav-link" href="/about">关于</a> </li>
                
                  <li><div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div></li>
            </div>
          </div>
                
      </div>
    </div>

</header>



      
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-java编程思想-17" style="width: 75%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      java编程思想[17]-容器
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/09/25/java编程思想-17/" class="article-date">
	  <time datetime="2018-09-25T10:32:00.000Z" itemprop="datePublished">2018-09-25</time>
	</a>

      
      
	<a class="article-views">
	<span id="busuanzi_container_page_pv">
		阅读量<span id="busuanzi_value_page_pv"></span>
	</span>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Java当中，如果有一个类专门用来存放其它类的对象，这个类就叫做容器，或者就叫做集合，集合就是将若干性质相同或相近的类对象组合在一起而形成的一个整体。<br><a id="more"></a> </p>
<h4 id="容器深入研究"><a href="#容器深入研究" class="headerlink" title="容器深入研究"></a>容器深入研究</h4><hr>
<h5 id="完整的容器分类法"><a href="#完整的容器分类法" class="headerlink" title="完整的容器分类法"></a>完整的容器分类法</h5><h5 id="填充容器"><a href="#填充容器" class="headerlink" title="填充容器"></a>填充容器</h5><p>使用Collections.nCopies()进行填充，可以自定义添加填充个数，而Collections.fill()只能替换元素不能添加元素。  </p>
<h5 id="Collections的功能方法"><a href="#Collections的功能方法" class="headerlink" title="Collections的功能方法"></a>Collections的功能方法</h5><p>如下Collection所有操作，也是可以通过Set或List执行的所有操作（List还有额外功能）。Map不是继承自Collecion所以不使用下面方法。  </p>
<ul>
<li>boolean add(T) 确保容器持有具有泛型类型T的参数。如果没有将此参数添加进容器，则返回false。  </li>
<li>boolean addAll(Collection&lt;? extends T&gt;) 添加参数中的所有元素，只要添加了任意元素就返回true。  </li>
<li>void clear()  移除容器中的所有元素。  </li>
<li>boolean contains(T) 如果容器已经持有具有泛型类型T此参数，则返回true。  </li>
<li>Boolean containsAll(Collecion&lt;?&gt;) 如果容器持有此参数的所有元素，则返回true。  </li>
<li>boolean isEmpty() 容器中没有任何元素返回true。  </li>
<li>Iterator<t> iterator() 返回一个Iterator<t>，可以用来遍历容器中的元素。  </t></t></li>
<li>Boolean remove(Object) 如果参数在容器中，则移除此元素一个实例。如果做了移除动作，返回true。  </li>
<li>boolean removeAll(Collection&lt;?&gt;) 移除参数中的所有元素。只要有移除动作发生就返回true。  </li>
<li>Boolean retainAll(Collection&lt;?&gt;) 只保存参数中的元素（应用集合论的”交集”概念）。 只要集合发生了改变就返回true。  </li>
<li>int size()返回容器中元素数目。  </li>
<li>Object[] toArray() 返回一个数组，该数组包含容器中的所有元素。  </li>
<li><t> T[] toArray(T[] a) 返回一个数组，该数组包含容器中的所有元素。返回结果的运行时类型与参数数组a的相同，而不是单纯的Object。  </t></li>
</ul>
<h5 id="可选操作"><a href="#可选操作" class="headerlink" title="可选操作"></a>可选操作</h5><h5 id="List的功能方法"><a href="#List的功能方法" class="headerlink" title="List的功能方法"></a>List的功能方法</h5><h5 id="Set和存储顺序"><a href="#Set和存储顺序" class="headerlink" title="Set和存储顺序"></a>Set和存储顺序</h5><p>Set中的存储顺序如何维护，Set的不同实现之间有所变化。因此不同Set实现不仅有不同的行为，而且它们对于可以在特定的Set中放置的元素的类型也有不同的要求  </p>
<blockquote>
<p><strong>Set（interface）:</strong>存入Set的每个元素必须是唯一的，因为Set不保存重复元素。加入Set的元素必须定义equals()方法以确保对象的唯一性。Set与Collection有完全一样的接口。Set接口不保证维护元素的次序。<br><strong>HashSet：</strong>为快速查找而设计的Set，存入HashSet的元素必须定义hashCode()，没有其他的限制，应默认采取该方式，对速度进行了优化。<br><strong>TreeSet：</strong>保持次序的Set，底层为树结构。使用它可以从Set中提取有序的序列。元素必须实现Comparable<br><strong>LinkedHashSet：</strong>具有HashSet的查询速度，且内部使用链表维护元素的顺序（插入的次序）。于是在使用迭代器遍历Set时，结果会按元素插入的次序显示，元素也必须定义hashCode()方法   </p>
</blockquote>
<ul>
<li>SortedSet<br>SortedSet中的元素可以保证处于排序状态，具有如下方法提供的附加功能：<br><strong>Comparator comparator()</strong>返回当前Set使用的Comparator。<br><strong>Object first()</strong>返回容器中的第一个元素。<br><strong>Object last()</strong>返回容器中的最末一个元素。<br><strong>SortedSet subSet(fromElement, toElement)</strong>返回从fromElement（包含）到toElement（不包含）<br><strong>SortedSet headSet(toElement)</strong>生成此Set的子集，由小于toElement的元素组成。<br><strong>SortedSet tailSet(fromElement)</strong>生成此Set的子集，由大于或等于fromElement的元素组成。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class SortedSetDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SortedSet&lt;String&gt; sortedSet = new TreeSet&lt;&gt;();</span><br><span class="line">        Collections.addAll(sortedSet, &quot;one two three four five six seven eight&quot;.split(&quot; &quot;));</span><br><span class="line">        System.out.println(sortedSet);</span><br><span class="line">        String low = sortedSet.first();</span><br><span class="line">        String high = sortedSet.last();</span><br><span class="line">        System.out.println(low);</span><br><span class="line">        System.out.println(high);</span><br><span class="line">        Iterator&lt;String&gt; it = sortedSet.iterator();</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt;= 6; i++) &#123;</span><br><span class="line">    if (i == 3) &#123;</span><br><span class="line">    low = it.next();</span><br><span class="line">    System.out.println(&quot;i==3 low:&quot; + low);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    if (i == 6) &#123;</span><br><span class="line">    high = it.next();</span><br><span class="line">    System.out.println(&quot;i==6 high:&quot; + high);</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    String temp =  it.next();</span><br><span class="line">    System.out.println(&quot;temp:&quot; + temp);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(low);</span><br><span class="line">    System.out.println(high);</span><br><span class="line">    System.out.println(sortedSet.subSet(low,high));</span><br><span class="line">    System.out.println(sortedSet.headSet(high));</span><br><span class="line">    System.out.println(sortedSet.tailSet(low));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// output : </span><br><span class="line">[eight, five, four, one, seven, six, three, two]</span><br><span class="line">eight</span><br><span class="line">two</span><br><span class="line">temp:eight</span><br><span class="line">temp:five</span><br><span class="line">temp:four</span><br><span class="line">i==3 low:one</span><br><span class="line">temp:seven</span><br><span class="line">temp:six</span><br><span class="line">temp:three</span><br><span class="line">i==6 high:two</span><br><span class="line">one</span><br><span class="line">two</span><br><span class="line">[one, seven, six, three]</span><br><span class="line">[eight, five, four, one, seven, six, three]</span><br><span class="line">[one, seven, six, three, two]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意：SortedSet是按照元素的比较函数对元素排序，而不是元素插入的顺序。出入顺序可以用LinkedHashSet保存。   </p>
<h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><ul>
<li>Java SE5中仅有的两个实现是LinkedList和PriorityQueue，它们差异在于排序行为而不是性能。  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class QueueBehavior &#123;</span><br><span class="line">    private static int count = 10;</span><br><span class="line"></span><br><span class="line">    static &lt;T&gt; void test(Queue&lt;T&gt; queue, Generator&lt;T&gt; gen) &#123;</span><br><span class="line">        for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            queue.offer(gen.next());//队尾添加元素，队满返回false</span><br><span class="line">        &#125;</span><br><span class="line">        while (queue.peek() != null) &#123;//取队头，没有返回null</span><br><span class="line">            System.out.print(queue.remove() + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    static class Gen implements Generator&lt;String&gt; &#123;</span><br><span class="line">        String[] s = (&quot;one two three four five six seven eight nine ten&quot;).split(&quot; &quot;);</span><br><span class="line">        int i;</span><br><span class="line">        public String next() &#123;</span><br><span class="line">            return s[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        test(new LinkedList&lt;String&gt;(), new Gen());</span><br><span class="line">        test(new PriorityQueue&lt;String&gt;(), new Gen());//优先队列的作用是能保证每次取出的元素都是队列中权值最小的</span><br><span class="line">        test(new ArrayBlockingQueue&lt;&gt;(count), new Gen());//阻塞队列</span><br><span class="line">        test(new ConcurrentLinkedDeque&lt;&gt;(), new Gen());//非阻塞线程安全队列</span><br><span class="line">        test(new LinkedBlockingDeque&lt;&gt;(), new Gen());//基于链表的双端阻塞队列，支持FIFO和FILO，线程安全</span><br><span class="line">        test(new PriorityBlockingQueue&lt;&gt;(), new Gen());//阻塞优先级队列，线程安全</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>双向队列<br>ArrayDeque不是线程安全的，可以双向（队头和队尾操作），主要方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">1.添加元素</span><br><span class="line">     addFirst(E e)在数组前面添加元素</span><br><span class="line">     addLast(E e)在数组后面添加元素</span><br><span class="line">     offerFirst(E e) 在数组前面添加元素，并返回是否添加成功</span><br><span class="line">     offerLast(E e) 在数组后天添加元素，并返回是否添加成功</span><br><span class="line"></span><br><span class="line">2.删除元素</span><br><span class="line">     removeFirst()删除第一个元素，并返回删除元素的值,如果元素为null，将抛出异常</span><br><span class="line">     pollFirst()删除第一个元素，并返回删除元素的值，如果元素为null，将返回null</span><br><span class="line">     removeLast()删除最后一个元素，并返回删除元素的值，如果为null，将抛出异常</span><br><span class="line">     pollLast()删除最后一个元素，并返回删除元素的值，如果为null，将返回null</span><br><span class="line">     removeFirstOccurrence(Object o) 删除第一次出现的指定元素</span><br><span class="line">     removeLastOccurrence(Object o) 删除最后一次出现的指定元素</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 3.获取元素</span><br><span class="line">     getFirst() 获取第一个元素,如果没有将抛出异常</span><br><span class="line">     getLast() 获取最后一个元素，如果没有将抛出异常</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 4.队列操作</span><br><span class="line">     add(E e) 在队列尾部添加一个元素</span><br><span class="line">     offer(E e) 在队列尾部添加一个元素，并返回是否成功</span><br><span class="line">     remove() 删除队列中第一个元素，并返回该元素的值，如果元素为null，将抛出异常(其实底层调用的是removeFirst())</span><br><span class="line">     poll()  删除队列中第一个元素，并返回该元素的值,如果元素为null，将返回null(其实调用的是pollFirst())</span><br><span class="line">     element() 获取第一个元素，如果没有将抛出异常</span><br><span class="line">     peek() 获取第一个元素，如果返回null</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"> 5.栈操作</span><br><span class="line">     push(E e) 栈顶添加一个元素</span><br><span class="line">     pop(E e) 移除栈顶元素,如果栈顶没有元素将抛出异常</span><br><span class="line">     </span><br><span class="line"></span><br><span class="line"> 6.其他</span><br><span class="line">     size() 获取队列中元素个数</span><br><span class="line">     isEmpty() 判断队列是否为空</span><br><span class="line">     iterator() 迭代器，从前向后迭代</span><br><span class="line">     descendingIterator() 迭代器，从后向前迭代</span><br><span class="line">     contain(Object o) 判断队列中是否存在该元素</span><br><span class="line">     toArray() 转成数组</span><br><span class="line">     clear() 清空队列</span><br><span class="line">     clone() 克隆(复制)一个新的队列</span><br></pre></td></tr></table></figure>
<h5 id="理解Map"><a href="#理解Map" class="headerlink" title="理解Map"></a>理解Map</h5><ul>
<li>性能<br>HashMap是使用对象的hashCode()进行快速查询的，此方法能够显著提高性能。<br>下面是基本的Map实现。在HashMap上打星号表示如果没有其他的限制，它就应该成为你的默认选择，因为它对速度进行了优化。其它实现强调了其他的特性，因此都不如HashMap快。  </li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">HashMap</td>
<td style="text-align:left">Map基于散列表的实现。插入和查询键值对的开销是固定的。可以通过构造器设置容量和负载因子，以调整容器的性能。</td>
</tr>
<tr>
<td style="text-align:left">LinkedHashMap</td>
<td style="text-align:left">类似于HashMap，但是迭代遍历它时，取得键值对的顺序是其插入次序，或者是最近最少使用的次序。只比HashMap慢一点，而在迭代访问时反而更快，因为它使用链表维护内部次序。</td>
</tr>
<tr>
<td style="text-align:left">TreeMap</td>
<td style="text-align:left">基于红黑树的实现。查看键或键值对时，它们会被排序（有Comparable或Comparator决定）。TreeMap的特点在于，所得到的结果是经过排序的。唯一带有subMap()方法的Map。</td>
</tr>
<tr>
<td style="text-align:left">WeakHashMap</td>
<td style="text-align:left">弱键映射，允许释放映射所指向的对象；为解决某类特殊问题而设计的。如果映射之外没有引用指向某个键，则此键可以被垃圾回收器回收。</td>
</tr>
<tr>
<td style="text-align:left">ConcurrentHashMap</td>
<td style="text-align:left">一种线程安全的Map，它不涉及同步加锁。</td>
</tr>
<tr>
<td style="text-align:left">IdentityHashMap</td>
<td style="text-align:left">使用==代替equals对键进行比较的散列映射。</td>
</tr>
</tbody>
</table>
<ul>
<li>SortedMap<br>使用SortedMap（TreeMap是现阶段唯一实现），可以确保键处于排序状态。  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//返回元素比较器。如果是自然顺序，则返回null；</span><br><span class="line">    Comparator&lt;? super K&gt; comparator();</span><br><span class="line">    </span><br><span class="line">    //返回从fromKey到toKey的集合：含头不含尾</span><br><span class="line">    java.util.SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey);</span><br><span class="line"></span><br><span class="line">    //返回从头到toKey的集合：不包含toKey</span><br><span class="line">    java.util.SortedMap&lt;K,V&gt; headMap(K toKey);</span><br><span class="line"></span><br><span class="line">    //返回从fromKey到结尾的集合：包含fromKey</span><br><span class="line">    java.util.SortedMap&lt;K,V&gt; tailMap(K fromKey);</span><br><span class="line">    </span><br><span class="line">    //返回集合中的第一个元素：</span><br><span class="line">    K firstKey();</span><br><span class="line">   </span><br><span class="line">    //返回集合中的最后一个元素：</span><br><span class="line">    K lastKey();</span><br><span class="line">    </span><br><span class="line">    //返回集合中所有key的集合：</span><br><span class="line">    Set&lt;K&gt; keySet();</span><br><span class="line">    </span><br><span class="line">    //返回集合中所有value的集合：</span><br><span class="line">    Collection&lt;V&gt; values();</span><br><span class="line">    </span><br><span class="line">    //返回集合中的元素映射：</span><br><span class="line">    Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</span><br></pre></td></tr></table></figure>
<ul>
<li>LinkedHashMap<br>LinkedHashMap 是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，<br>按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。  </li>
</ul>
<h5 id="散列和散列码"><a href="#散列和散列码" class="headerlink" title="散列和散列码"></a>散列和散列码</h5><p>假如键没有按照一定的顺序进行保存，那么查询的时候就只能按照顺序进行线性查询，然而，线性查询是最慢的查询方式。所以，将键值按照一定的顺序排序，并且使用二分查找能购有效的提升速度。散列在此之上，更近一步，他将键保存在数组中(数组的查询速度最快)，用数组来表示键的信息，但是由于Map的容量是可变的，而数组的容量是不变的。要解决这个问题，数组中存的并不是键本身，而是键对象生成的一个数字，将其作为数组的下标，这个数字就是散列码。<br>而这种办法所产生的问题就是下标重复。而我们的解决办法就是配合equals来确定键值。<br>查询的过程首先就是计算散列码，然后用散列码来查询函数(下标)，通常，我们的数组中保存的是值的list，因此，我们计算出散列码之后，通过下表取到的对应部分的list，然后通过equals就可以快速找到键值。  </p>
<p>散列码：通过hashCode返回int类型的数值，即为对象的散列码。</p>

      
    </div>
    <footer class="article-footer">
      
        <div id="donation_div"></div>

<script src="/js/vdonate.js"></script>
<script>
var a = new Donate({
  title: '如果觉得我的文章对您有用，请随意打赏。您的支持将鼓励我继续创作!', // 可选参数，打赏标题
  btnText: '打赏支持', // 可选参数，打赏按钮文字
  el: document.getElementById('donation_div'),
  wechatImage: 'https://raw.githubusercontent.com/iTimeTraveler/iTimeTraveler.github.io/site/source/about/donate/images/WeChanQR.png',
  alipayImage: 'https://raw.githubusercontent.com/iTimeTraveler/iTimeTraveler.github.io/site/source/about/donate/images/AliPayQR.jpg'
});
</script>
      
      
      <div>
        <ul class="post-copyright">
          <li class="post-copyright-author">
          <strong>本文作者:  </strong>alvin dong</a>
          </li>
          <li class="post-copyright-link">
          <strong>本文链接:  </strong>
          <a href="/2018/09/25/java编程思想-17/" target="_blank" title="java编程思想[17]-容器">https://dongme.site/2018/09/25/java编程思想-17/</a>
          </li>
          <li class="post-copyright-license">
            <strong>版权声明:   </strong>
            本博客所有文章除特别声明外，均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
            许可协议。转载请注明出处
          </li>
         
        </ul>
<div>

      
      
        
	<div id="comment">
		<!-- 来必力City版安装代码 -->
		<div id="lv-container" data-id="city" data-uid="MTAyMC8yOTQ4MS82MDQ5">
		<script type="text/javascript">
		   (function(d, s) {
		       var j, e = d.getElementsByTagName(s)[0];

		       if (typeof LivereTower === 'function') { return; }

		       j = d.createElement(s);
		       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
		       j.async = true;

		       e.parentNode.insertBefore(j, e);
		   })(document, 'script');
		</script>
		<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
		</div>
		<!-- City版安装代码已完成 -->
	</div>



      
      

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/09/26/java编程思想-21/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          java编程思想[21]-并发
        
      </div>
    </a>
  
  
    <a href="/2018/08/23/java编程思想-16/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">java编程思想[16]-数组</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="toc-sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
        <ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#容器深入研究"><span class="nav-number">1.</span> <span class="nav-text">容器深入研究</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#完整的容器分类法"><span class="nav-number">1.1.</span> <span class="nav-text">完整的容器分类法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#填充容器"><span class="nav-number">1.2.</span> <span class="nav-text">填充容器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Collections的功能方法"><span class="nav-number">1.3.</span> <span class="nav-text">Collections的功能方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#可选操作"><span class="nav-number">1.4.</span> <span class="nav-text">可选操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#List的功能方法"><span class="nav-number">1.5.</span> <span class="nav-text">List的功能方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Set和存储顺序"><span class="nav-number">1.6.</span> <span class="nav-text">Set和存储顺序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#队列"><span class="nav-number">1.7.</span> <span class="nav-text">队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#理解Map"><span class="nav-number">1.8.</span> <span class="nav-text">理解Map</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#散列和散列码"><span class="nav-number">1.9.</span> <span class="nav-text">散列和散列码</span></a></li></ol></li></ol>
    
    </div>
  </aside>

</section>
        
      </div>
      
      <footer id="footer">
  

  <div class="container">
      	<div class="row">
	      <p> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/iTimeTraveler/hexo-theme-hiker" target="_blank">Hexo-theme-hiker</a> </p>
	      <p id="copyRightEn">Copyright &copy; 2013 - 2018 alvin&#39;s blog All Rights Reserved.</p>
	      
	      
    		<p class="busuanzi_uv">
				访客数 : <span id="busuanzi_value_site_uv"></span> |  
				访问量 : <span id="busuanzi_value_site_pv"></span>
		    </p>
  		   
		</div>

		
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");
    var allheader = document.getElementById("allheader");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    if (allheader != null) {
      contentdiv.style.minHeight = document.body.offsetHeight - allheader.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    } else {
      contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    }
</script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/scripts.js"></script>




  <script src="/js/dialog.js"></script>








	<div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="myModalLabel">设置</h2>
      </div>
      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">


      <div class="modal-body">
          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" onclick="javascript:setFontSize();" aria-expanded="true" aria-controls="collapseOne">
              正文字号大小
            </a>
          </div>
          <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
          <div class="panel-body">
            您已调整页面字体大小
          </div>
        </div>
      


          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" onclick="javascript:setBackground();" aria-expanded="true" aria-controls="collapseTwo">
              夜间护眼模式
            </a>
        </div>
          <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
          <div class="panel-body">
            夜间模式已经开启，再次单击按钮即可关闭 
          </div>
        </div>

        <div>
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="true" aria-controls="collapseThree">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关 于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
        </div>
         <div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
          <div class="panel-body">
            alvin&#39;s blog
          </div>
          <div class="panel-body">
            Copyright © 2018 alvin dong All Rights Reserved.
          </div>
        </div>
      </div>


      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <div class="modal-footer">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
      </div>
    </div>
  </div>
</div>
  
  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
  
    <a id="menu-switch"><i class="fa fa-bars fa-lg"></i></a>
  
</body>
</html>