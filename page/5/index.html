<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>alvin&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  
  <meta name="description" content="Record as you like">
<meta property="og:type" content="website">
<meta property="og:title" content="alvin&#39;s blog">
<meta property="og:url" content="https://dongme.site/page/5/index.html">
<meta property="og:site_name" content="alvin&#39;s blog">
<meta property="og:description" content="Record as you like">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="alvin&#39;s blog">
<meta name="twitter:description" content="Record as you like">
  
    <link rel="alternate" href="/atom.xml" title="alvin&#39;s blog" type="application/atom+xml">
  

  

  <link rel="icon" href="/css/images/mylogo.jpg">
  <link rel="apple-touch-icon" href="/css/images/mylogo.jpg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>
  <script src="/js/bootstrap.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >

  
    <link rel="stylesheet" href="/css/home.css" >
  

  

  

  
  
  
    <link rel="stylesheet" href="/css/vdonate.css" >
  

</head>



  <body>


  
    <header id="header">

	<!-- 背景图模式 -->
	

    
      <div id="intrologo" class="intro-logo" style="background-position:center; background-repeat:no-repeat; background-image: url(); background-size: auto 100%;">

      <!-- Support rolling -->  
        
        <section class="awSlider">
          <div class="carousel slide carousel-fade " data-ride="carousel">

            <!-- Wrapper for slides -->
            <div class="carousel-inner">
               
                  
                    <div class="item active">
                  
                    <img id="carousel-img0" src="/css/images/home-bg.jpg">
                  </div>

                  <!-- 自适应大图 -->
                  <script>
                      var img0 = new Image();
                      var imageTag0 = document.getElementById("carousel-img0");
                      img0.src = imageTag0.src;
                      img0.onload=function(){
                        if (img0.width / img0.height <= document.body.clientWidth / document.body.clientHeight) {
                          imageTag0.style.width = document.body.clientWidth + "px";
                        } else {
                          imageTag0.style.height = document.body.clientHeight + "px";
                          imageTag0.style.marginLeft = -(document.body.clientHeight * img0.width / img0.height - document.body.clientWidth) / 2 + "px";
                        }
                      };
                  </script>
                
                  
                    <div class="item">
                  
                    <img id="carousel-img1" src="/css/images/sample.jpg">
                  </div>

                  <!-- 自适应大图 -->
                  <script>
                      var img1 = new Image();
                      var imageTag1 = document.getElementById("carousel-img1");
                      img1.src = imageTag1.src;
                      img1.onload=function(){
                        if (img1.width / img1.height <= document.body.clientWidth / document.body.clientHeight) {
                          imageTag1.style.width = document.body.clientWidth + "px";
                        } else {
                          imageTag1.style.height = document.body.clientHeight + "px";
                          imageTag1.style.marginLeft = -(document.body.clientHeight * img1.width / img1.height - document.body.clientWidth) / 2 + "px";
                        }
                      };
                  </script>
                
                  
                    <div class="item">
                  
                    <img id="carousel-img2" src="https://source.unsplash.com/collection/954550/1920x1080">
                  </div>

                  <!-- 自适应大图 -->
                  <script>
                      var img2 = new Image();
                      var imageTag2 = document.getElementById("carousel-img2");
                      img2.src = imageTag2.src;
                      img2.onload=function(){
                        if (img2.width / img2.height <= document.body.clientWidth / document.body.clientHeight) {
                          imageTag2.style.width = document.body.clientWidth + "px";
                        } else {
                          imageTag2.style.height = document.body.clientHeight + "px";
                          imageTag2.style.marginLeft = -(document.body.clientHeight * img2.width / img2.height - document.body.clientWidth) / 2 + "px";
                        }
                      };
                  </script>
                
            </div>

            <!-- Controls -->
            <a class="left carousel-control" href=".carousel" role="button" data-slide="prev">
              <span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>
              <span class="sr-only">Geri</span>
            </a>
            <a class="right carousel-control" href=".carousel" role="button" data-slide="next">
              <span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span>
              <span class="sr-only">İleri</span>
            </a>
          </div>
        </section>
        <script>
          $('section.awSlider .carousel').carousel({
              pause: '',
              interval: 5000
          });
          var startImage = $('section.awSlider .item.active > img').attr('src');
          $('section.awSlider .carousel').on('slid.bs.carousel', function () {
              var bscn = $(this).find('.item.active > img').attr('src');
              $('section.awSlider > img').attr('src', bscn);
          });
        </script>
      

    
 


    <canvas width="100%" height="100%"></canvas>
    <script>
      var c = document.getElementsByTagName('canvas')[0],
          x = c.getContext('2d'),
          w = window.innerWidth,
          h = window.innerHeight,
          pr = window.devicePixelRatio || 1,
          f = 90,
          q,
          m = Math,
          r = 0,
          u = m.PI*2,
          v = m.cos,
          z = m.random
      c.width = w*pr
      c.height = h*pr
      x.scale(pr, pr)
      x.globalAlpha = 0.6

      <!-- 折线Polyline背景 -->
      
    </script>
    

    
      <div id="homelogo" class="homelogo" style="background: rgba(255,255,255,1);"> 
    

        
          <div class="homelogoback"  style="border: 1px solid #404040;" >
            <h1><a href="#content" id="logo">alvin&#39;s blog</a></h1>
            <h3>Record as you like</h3>
            <h5>alvin dong</h5>
            <!-- <p><a href="https://github.com/iTimeTraveler" target="_blank">Github</a></p> -->
          </div>
        
    
    </div>
  </div>

  <!-- 自适应主页背景大图 -->
  

 <!-- home_logo_image居中 -->
 
    <script>
        var homelogodiv = document.getElementById("homelogo");
        if (document.all.homelogo.offsetWidth > document.body.clientWidth) {
          homelogodiv.style.width = document.body.clientWidth + "px";
          homelogodiv.style.marginLeft = document.body.clientWidth * -0.5 + "px";
        } else {
          homelogodiv.style.width = homelogodiv.clientWidth  + "px";
          homelogodiv.style.marginLeft = (homelogodiv.clientWidth)  * -0.5 + "px";
        }
    </script>
  

  <div class="intro-navigate">
      <p class="navigater-list">
        
          <a id="beautifont" class="main-nav-link" href="/">首页</a>
        
          <a id="beautifont" class="main-nav-link" href="/archives">归档</a>
        
          <a id="beautifont" class="main-nav-link" href="/categories">分类</a>
        
          <a id="beautifont" class="main-nav-link" href="/tags">标签</a>
        
          <a id="beautifont" class="main-nav-link" href="/about">关于</a>
        
      </p>
  </div>

</header>
  
  <div id="container">
    <div id="wrap">
      
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;">
  
    <article id="post-设计模式之工厂模式"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/10/17/设计模式之工厂模式/">设计模式之工厂模式</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/10/17/设计模式之工厂模式/" class="article-date">
	  <time datetime="2018-10-16T16:57:18.000Z" itemprop="datePublished">2018-10-17</time>
	</a>

      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。  </p>
<p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。<br><a id="more"></a> </p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><strong>意图：</strong> 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。<br><strong>主要解决：</strong> 主要解决接口选择的问题。<br><strong>何时使用：</strong> 我们明确地计划不同条件下创建不同实例时。<br><strong>如何解决：</strong> 让其子类实现工厂接口，返回的也是一个抽象的产品。<br><strong>关键代码：</strong> 创建过程在其子类进行。<br><strong>应用实例：</strong> 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。<br><strong>优点：</strong> 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。<br><strong>缺点：</strong> 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事<br><strong>使用场景：</strong> 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。<br><strong>注意事项：</strong> 作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。  </p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>我们将创建一个 Shape 接口和实现 Shape 接口的实体类。下一步是定义工厂类 ShapeFactory。<br>FactoryPatternDemo，我们的演示类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。<br><img src="http://ombpxfki1.bkt.clouddn.com/factorypattern-1.png" alt="">  </p>
<h5 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h5><p>创建一个接口 Shape.java：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h5><p>创建实现接口的实现类。  </p>
<p>Rectangle.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Inside Rectangle::draw() method."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Square.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Inside Square::draw() method."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Circle.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Inside Circle::draw() method."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="步骤3"><a href="#步骤3" class="headerlink" title="步骤3"></a>步骤3</h5><p>创建一个工厂，生成基于给定信息的实体类的对象。  </p>
<p>ShapeFactory.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用 getShape 方法获取形状类型的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (shapeType == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (shapeType.equalsIgnoreCase(<span class="string">"CIRCLE"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeType.equalsIgnoreCase(<span class="string">"RECTANGLE"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeType.equalsIgnoreCase(<span class="string">"SQUARE"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="步骤4"><a href="#步骤4" class="headerlink" title="步骤4"></a>步骤4</h5><p>使用该工厂，通过传递类型信息来获取实体类的对象。  </p>
<p>FactoryPatternDemo.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShapeFactory shapeFactory = <span class="keyword">new</span> ShapeFactory();</span><br><span class="line">        <span class="comment">//获取 Circle 的对象，并调用它的 draw 方法</span></span><br><span class="line">        Shape shape1 = shapeFactory.getShape(<span class="string">"CIRCLE"</span>);</span><br><span class="line">        <span class="comment">//调用 Circle 的 draw 方法</span></span><br><span class="line">        shape1.draw();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取 Rectangle 的对象，并调用它的 draw 方法</span></span><br><span class="line">        Shape shape2 = shapeFactory.getShape(<span class="string">"RECTANGLE"</span>);</span><br><span class="line">        <span class="comment">//调用 Rectangle 的 draw 方法</span></span><br><span class="line">        shape2.draw();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取 Square 的对象，并调用它的 draw 方法</span></span><br><span class="line">        Shape shape3 = shapeFactory.getShape(<span class="string">"SQUARE"</span>);</span><br><span class="line">        <span class="comment">//调用 Square 的 draw 方法</span></span><br><span class="line">        shape3.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      
      
      
      
        
      

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->


  
    <article id="post-jdk新特性之jdk10"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/10/16/jdk新特性之jdk10/">jdk新特性之jdk10</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/10/16/jdk新特性之jdk10/" class="article-date">
	  <time datetime="2018-10-15T16:40:00.000Z" itemprop="datePublished">2018-10-16</time>
	</a>

      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>jdk10新特性。<br><a id="more"></a></p>
<h3 id="jdk10新特性"><a href="#jdk10新特性" class="headerlink" title="jdk10新特性"></a>jdk10新特性</h3><p>Java 在 2018 年 3 月 21 日发布了第十个大版本。为了更快地迭代、更好地跟进社区反馈，Java 语言版本发布周期调整为每隔 6 个月发布一次。<br>Java 10 是这一新规则之后，采用新发布周期的第一个大版本。Java 10 版本带来了很多新特性，其中最备受广大开发者关注的莫过于局部变量类型推断。<br>除此之外，还有其他包括垃圾收集器改善、GC 改进、性能提升、线程管控等一批新特性。  </p>
<h4 id="局部变量类型推断"><a href="#局部变量类型推断" class="headerlink" title="局部变量类型推断"></a>局部变量类型推断</h4><p>部变量类型推断是 Java 10 中最值得开发人员注意的新特性，允许开发人员省略通常不必要的局部变量类型初始化声明。<br>新的语法将减少 Java 代码的冗长度，同时保持对静态类型安全性的承诺。局部变量类型推断主要是向 Java 语法中引入<br>在其他语言（比如 C#、JavaScript）中很常见的保留类型名称 var。但需要特别注意的是：var 不是一个关键字，而是一个保留字。<br>只要编译器可以推断此种类型，开发人员不再需要专门声明一个局部变量的类型，也就是可以随意定义变量而不必指定变量的类型。<br>这种改进对于链式表达式来说，也会很方便。以下是一个简单的例子：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var list = new ArrayList&lt;String&gt;(); // ArrayList&lt;String&gt;</span><br><span class="line"></span><br><span class="line">var stream = list.stream(); //Stream&lt;String&gt;</span><br></pre></td></tr></table></figure>
<p>但这种 var 变量类型推断的使用也有局限性，仅局限于具有初始化器的局部变量、增强型 for 循环中的索引变量以及在传统 for 循环中声明的局部变量，<br>而不能用于推断方法的参数类型，不能用于构造函数参数类型推断，不能用于推断方法返回类型，也不能用于字段类型推断，同时还不能用于捕获表达式（或任何其他类型的变量声明）。  </p>
<h4 id="整合-JDK-代码仓库"><a href="#整合-JDK-代码仓库" class="headerlink" title="整合 JDK 代码仓库"></a>整合 JDK 代码仓库</h4><p>在已发布的 Java 版本中，JDK 的整套代码根据不同功能已被分别存储在多个 Mercurial 存储库，这八个 Mercurial 存储库分别是：root、corba、hotspot、jaxp、jaxws、jdk、langtools、nashorn。<br>虽然以上八个存储库之间相互独立以保持各组件代码清晰分离，但同时管理这些存储库存在许多缺点，并且无法进行相关联源代码的管理操作。其中最重要的一点是，涉及多个存储库的变更集无法进行原子提交 （atomic commit）。<br>例如，如果一个 bug 修复时需要对独立存储两个不同代码库的代码进行更改，那么必须创建两个提交：每个存储库中各一个。<br>这种不连续性很容易降低项目和源代码管理工具的可跟踪性和加大复杂性。特别是，不可能跨越相互依赖的变更集的存储库执行原子提交这种多次跨仓库的变化是常见现象。   </p>
<p>为了解决这个问题，JDK 10 中将所有现有存储库合并到一个 Mercurial 存储库中。这种合并的一个次生效应是，单一的 Mercurial 存储库比现有的八个存储库要更容易地被镜像(作为一个 Git 存储库)，<br>并且使得跨越相互依赖的变更集的存储库运行原子提交成为可能，从而简化开发和管理过程。虽然在整合过程中，外部开发人员有一些阻力，但是 JDK 开发团队已经使这一更改成为 JDK 10 的一部分。   </p>
<h4 id="统一的垃圾回收接口"><a href="#统一的垃圾回收接口" class="headerlink" title="统一的垃圾回收接口"></a>统一的垃圾回收接口</h4><p>在当前的 Java 结构中，组成垃圾回收器（GC）实现的组件分散在代码库的各个部分。尽管这些惯例对于使用 GC 计划的 JDK 开发者来说比较熟悉，但对新的开发人员来说，对于在哪里查找特定 GC 的源代码，或者实现一个新的垃圾收集器常常会感到困惑。更重要的是，随着 Java modules 的出现，我们希望在构建过程中排除不需要的 GC，但是当前 GC 接口的横向结构会给排除、定位问题带来困难。<br>为解决此问题，需要整合并清理 GC 接口，以便更容易地实现新的 GC，并更好地维护现有的 GC。Java 10 中，hotspot/gc 代码实现方面，引入一个干净的 GC 接口，改进不同 GC 源代码的隔离性，多个 GC 之间共享的实现细节代码应该存在于辅助类中。这种方式提供了足够的灵活性来实现全新 GC 接口，同时允许以混合搭配方式重复使用现有代码，并且能够保持代码更加干净、整洁，便于排查收集器问题。  </p>
<h4 id="并行全垃圾回收器-G1"><a href="#并行全垃圾回收器-G1" class="headerlink" title="并行全垃圾回收器 G1"></a>并行全垃圾回收器 G1</h4><p>大家如果接触过 Java 性能调优工作，应该会知道，调优的最终目标是通过参数设置来达到快速、低延时的内存垃圾回收以提高应用吞吐量，尽可能的避免因内存回收不及时而触发的完整 GC（Full GC 会带来应用出现卡顿）。<br>G1 垃圾回收器是 Java 9 中 Hotspot 的默认垃圾回收器，是以一种低延时的垃圾回收器来设计的，旨在避免进行 Full GC，但是当并发收集无法快速回收内存时，会触发垃圾回收器回退进行 Full GC。之前 Java 版本中的 G1 垃圾回收器执行 GC 时采用的是基于单线程标记扫描压缩算法（mark-sweep-compact）。为了最大限度地减少 Full GC 造成的应用停顿的影响，Java 10 中将为 G1 引入多线程并行 GC，同时会使用与年轻代回收和混合回收相同的并行工作线程数量，从而减少了 Full GC 的发生，以带来更好的性能提升、更大的吞吐量。<br>Java 10 中将采用并行化 mark-sweep-compact 算法，并使用与年轻代回收和混合回收相同数量的线程。具体并行 GC 线程数量可以通过：-XX：ParallelGCThreads 参数来调节，但这也会影响用于年轻代和混合收集的工作线程数。  </p>
<h4 id="应用程序类数据共享"><a href="#应用程序类数据共享" class="headerlink" title="应用程序类数据共享"></a>应用程序类数据共享</h4><p>在 Java 5 中就已经引入了类数据共享机制 (Class Data Sharing，简称 CDS)，允许将一组类预处理为共享归档文件，以便在运行时能够进行内存映射以减少 Java 程序的启动时间，当多个 Java 虚拟机（JVM）共享相同的归档文件时，还可以减少动态内存的占用量，同时减少多个虚拟机在同一个物理或虚拟的机器上运行时的资源占用。简单来说，Java 安装程序会把 rt.jar 中的核心类提前转化成内部表示，转储到一个共享存档（shared archive）中。多个 Java 进程（或者说 JVM 实例）可以共享这部分数据。为改善启动和占用空间，Java 10 在现有的 CDS 功能基础上再次拓展，以允许应用类放置在共享存档中。<br>CDS 特性在原来的 bootstrap 类基础之上，扩展加入了应用类的 CDS (Application Class-Data Sharing) 支持。<br>其原理为：在启动时记录加载类的过程，写入到文本文件中，再次启动时直接读取此启动文本并加载。设想如果应用环境没有大的变化，启动速度就会得到提升。<br>可以想像为类似于操作系统的休眠过程，合上电脑时把当前应用环境写入磁盘，再次使用时就可以快速恢复环境。<br>对大型企业应用程序的内存使用情况的分析表明，此类应用程序通常会将数以万计的类加载到应用程序类加载器中，如果能够将 AppCDS 应用于这些应用，将为每个 JVM 进程节省数十乃至数百兆字节的内存。另外对于云平台上的微服务分析表明，许多服务器在启动时会加载数千个应用程序类，AppCDS 可以让这些服务快速启动并改善整个系统响应时间。  </p>
<h4 id="线程-局部管控"><a href="#线程-局部管控" class="headerlink" title="线程-局部管控"></a>线程-局部管控</h4><p>在已有的 Java 版本中，JVM 线程只能全部启用或者停止，没法做到对单独某个线程的操作。为了能够对单独的某个线程进行操作，Java 10 中线程管控引入 JVM 安全点的概念，将允许在不运行全局 JVM 安全点的情况下实现线程回调，由线程本身或者 JVM 线程来执行，同时保持线程处于阻塞状态，这种方式使得停止单个线程变成可能，而不是只能启用或停止所有线程。通过这种方式显著地提高了现有 JVM 功能的性能开销，并且改变了到达 JVM 全局安全点的现有时间语义。<br>增加的参数为：-XX:ThreadLocalHandshakes (默认为开启)，将允许用户在支持的平台上选择安全点  </p>
<h4 id="移除-Native-Header-自动生成工具"><a href="#移除-Native-Header-自动生成工具" class="headerlink" title="移除 Native-Header 自动生成工具"></a>移除 Native-Header 自动生成工具</h4><p>自 Java 9 以来便开始了一些对 JDK 的调整，用户每次调用 javah 工具时会被警告该工具在未来的版本中将会执行的删除操作。当编译 JNI 代码时，已不再需要单独的 Native-Header 工具来生成头文件，因为这可以通过 Java 8（JDK-7150368）中添加的 javac 来完成。在未来的某一时刻，JNI 将会被 Panama 项目的结果取代，但是何时发生还没有具体时间表。  </p>
<h4 id="额外的-Unicode-语言标签扩展"><a href="#额外的-Unicode-语言标签扩展" class="headerlink" title="额外的 Unicode 语言标签扩展"></a>额外的 Unicode 语言标签扩展</h4><p>自 Java 7 开始支持 BCP 47 语言标记以来， JDK 中便增加了与日历和数字相关的 Unicode 区域设置扩展，在 Java 9 中，新增支持 ca 和 nu 两种语言标签扩展。而在 Java 10 中将继续增加 Unicode 语言标签扩展，具体为：增强 java.util.Locale 类及其相关的 API，以更方便的获得所需要的语言地域环境信息。同时在这次升级中还带来了如下扩展支持：  </p>
<p>表 1.Unicode 扩展表  </p>
<table>
<thead>
<tr>
<th style="text-align:left">编码</th>
<th style="text-align:left">注释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">cu</td>
<td style="text-align:left">货币类型</td>
</tr>
<tr>
<td style="text-align:left">fw</td>
<td style="text-align:left">一周的第一天</td>
</tr>
<tr>
<td style="text-align:left">rg</td>
<td style="text-align:left">区域覆盖</td>
</tr>
<tr>
<td style="text-align:left">tz</td>
<td style="text-align:left">时区</td>
</tr>
</tbody>
</table>
<h4 id="备用存储装置上的堆分配"><a href="#备用存储装置上的堆分配" class="headerlink" title="备用存储装置上的堆分配"></a>备用存储装置上的堆分配</h4><p>硬件技术在持续进化，现在可以使用与传统 DRAM 具有相同接口和类似性能特点的非易失性 RAM。Java 10 中将使得 JVM 能够使用适用于不同类型的存储机制的堆，在可选内存设备上进行堆内存分配。<br>一些操作系统中已经通过文件系统提供了使用非 DRAM 内存的方法。例如：NTFS DAX 模式和 ext4 DAX。这些文件系统中的内存映射文件可绕过页面缓存并提供虚拟内存与设备物理内存的相互映射。与 DRAM 相比，NV-DIMM 可能具有更高的访问延迟，低优先级进程可以为堆使用 NV-DIMM 内存，允许高优先级进程使用更多 DRAM。<br>要在这样的备用设备上进行堆分配，可以使用堆分配参数 -XX：AllocateHeapAt = <path></path>，这个参数将指向文件系统的文件并使用内存映射来达到在备用存储设备上进行堆分配的预期结果。  </p>
<h4 id="基于-Java-的-实验性-JIT-编译器"><a href="#基于-Java-的-实验性-JIT-编译器" class="headerlink" title="基于 Java 的 实验性 JIT 编译器"></a>基于 Java 的 实验性 JIT 编译器</h4><p>Java 10 中开启了基于 Java 的 JIT 编译器 Graal，并将其用作 Linux/x64 平台上的实验性 JIT 编译器开始进行测试和调试工作，另外 Graal 将使用 Java 9 中引入的 JVM 编译器接口（JVMCI）。<br>Graal 是一个以 Java 为主要编程语言、面向 Java bytecode 的编译器。与用 C++实现的 C1 及 C2 相比，它的模块化更加明显，也更加容易维护。Graal 既可以作为动态编译器，在运行时编译热点方法；亦可以作为静态编译器，实现 AOT 编译。在 Java 10 中，Graal 作为试验性 JIT 编译器一同发布（JEP 317）。将 Graal 编译器研究项目引入到 Java 中，或许能够为 JVM 性能与当前 C++ 所写版本匹敌（或有幸超越）提供基础。<br>Java 10 中默认情况下 HotSpot 仍使用的是 C2 编译器，要启用 Graal 作为 JIT 编译器，请在 Java 命令行上使用以下参数：<br>启用 Graal 为 JIT 编译器示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX：+ UnlockExperimentalVMOptions -XX：+ UseJVMCICompiler</span><br></pre></td></tr></table></figure></p>
<h4 id="根证书认证"><a href="#根证书认证" class="headerlink" title="根证书认证"></a>根证书认证</h4><p>自 Java 9 起在 keytool 中加入参数 -cacerts，可以查看当前 JDK 管理的根证书。而 Java 9 中 cacerts 目录为空，这样就会给开发者带来很多不便。从 Java 10 开始，将会在 JDK 中提供一套默认的 CA 根证书。<br>作为 JDK 一部分的 cacerts 密钥库旨在包含一组能够用于在各种安全协议的证书链中建立信任的根证书。但是，JDK 源代码中的 cacerts 密钥库至目前为止一直是空的。因此，在 JDK 构建中，默认情况下，关键安全组件（如 TLS）是不起作用的。要解决此问题，用户必须使用一组根证书配置和 cacerts 密钥库下的 CA 根证书。  </p>
<h4 id="基于时间的版本发布模式"><a href="#基于时间的版本发布模式" class="headerlink" title="基于时间的版本发布模式"></a>基于时间的版本发布模式</h4><p>虽然 JEP 223中引入的版本字符串方案较以往有了显著的改进。但是，该方案并不适合以后严格按照六个月的节奏来发布 Java 新版本的这种情况。<br>按照 JEP 223 的语义中，每个基于 JDK 构建或使用组件的开发者（包括 JDK 的发布者）都必须提前敲定版本号，然后切换过去。开发人员则必须在代码中修改检查版本号的相关代码，这对所有参与者来说都很尴尬和混乱。<br>Java 10 中将重新编写之前 JDK 版本中引入的版本号方案，将使用基于时间模型定义的版本号格式来定义新版本。保留与 JEP 223 版本字符串方案的兼容性，同时也允许除当前模型以外的基于时间的发布模型。使开发人员或终端用户能够轻松找出版本的发布时间，以便开发人员能够判断是否将其升级到具有最新安全修补程序或可能的附加功能的新版本。<br>Oracle Java 平台组的首席架构师 Mark Reinhold 在博客上介绍了有关 Java 未来版本的一些想法（你能接受 Java 9 的下一个版本是 Java 18.3 吗？）。他提到，Java 计划按照时间来发布，每半年一个版本，而不是像之前那样按照重要特性来确定大版本，如果某个大的特性因故延期，这个版本可能一拖再拖。<br>当时，Mark 也提出来一种基于时间命名版本号的机制，比如下一个将于 2018 年 3 月发布的版本，就是 18.3，再下一个版本是 18.9，以后版本依此类推。<br>不过经过讨论，考虑和之前版本号的兼容等问题，最终选择的命名机制是：<br>$FEATURE.$INTERIM.$UPDATE.$PATCH<br>$FEATURE，每次版本发布加 1，不考虑具体的版本内容。2018 年 3 月的版本是 JDK 10，9 月的版本是 JDK 11，依此类推。<br>$INTERIM，中间版本号，在大版本中间发布的，包含问题修复和增强的版本，不会引入非兼容性修改。</p>

      
    </div>
    <footer class="article-footer">
      
      
      
      
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jdk/">jdk</a></li></ul>

      

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->


  
    <article id="post-jdk新特性之jdk9"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/10/16/jdk新特性之jdk9/">jdk新特性之jdk9</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/10/16/jdk新特性之jdk9/" class="article-date">
	  <time datetime="2018-10-15T16:38:00.000Z" itemprop="datePublished">2018-10-16</time>
	</a>

      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>jdk9新特性。<br><a id="more"></a></p>
<h3 id="jdk9新特性"><a href="#jdk9新特性" class="headerlink" title="jdk9新特性"></a>jdk9新特性</h3><p>Java 9 发布于 2017 年 9 月 22 日，带来了很多新特性，其中最主要的变化是已经实现的模块化系统。接下来我们会详细介绍 Java 9 的新特性。  </p>
<ul>
<li><strong>模块系统：</strong> 模块是一个包的容器，Java 9 最大的变化之一是引入了模块系统（Jigsaw 项目）。  </li>
<li><strong>HTTP 2 客户端：</strong> HTTP/2标准是HTTP协议的最新版本，新的 HTTPClient API 支持 WebSocket 和 HTTP2 流以及服务器推送特性。  </li>
<li><strong>改进的 Javadoc：</strong> Javadoc 现在支持在 API 文档中的进行搜索。另外，Javadoc 的输出现在符合兼容 HTML5 标准。  </li>
<li><strong>多版本兼容 JAR 包：</strong> 多版本兼容 JAR 功能能让你创建仅在特定版本的 Java 环境中运行库程序时选择使用的 class 版本。  </li>
<li><strong>集合工厂方法：</strong> List，Set 和 Map 接口中，新的静态工厂方法可以创建这些集合的不可变实例。   </li>
<li><strong>私有接口方法：</strong> 在接口中使用private私有方法。我们可以使用 private 访问修饰符在接口中编写私有方法。  </li>
<li><strong>进程 API：</strong> 改进的 API 来控制和管理操作系统进程。引进 java.lang.ProcessHandle 及其嵌套接口 Info 来让开发者逃离时常因为要获取一个本地进程的 PID 而不得不使用本地代码的窘境。  </li>
<li><strong>改进的 Stream API：</strong> 改进的 Stream API 添加了一些便利的方法，使流处理更容易，并使用收集器编写复杂的查询。  </li>
<li><strong>改进 try-with-resources：</strong> 如果你已经有一个资源是 final 或等效于 final 变量,您可以在 try-with-resources 语句中使用该变量，而无需在 try-with-resources 语句中声明一个新变量。  </li>
<li><strong>改进的弃用注解 @Deprecated：</strong>  @Deprecated 可以标记 Java API 状态，可以表示被标记的 API 将会被移除，或者已经破坏。  </li>
<li><strong>改进钻石操作符(Diamond Operator) ：</strong> 匿名类可以使用钻石操作符(Diamond Operator)。  </li>
<li><strong>改进 Optional 类：</strong> java.util.Optional 添加了很多新的有用方法，Optional 可以直接转为 stream。    </li>
<li><strong>多分辨率图像 API：</strong> 定义多分辨率图像API，开发者可以很容易的操作和展示不同分辨率的图像了。   </li>
<li><strong>改进的 CompletableFuture API ：</strong> CompletableFuture 类的异步机制可以在 ProcessHandle.onExit 方法退出时执行操作。   </li>
<li><strong>轻量级的 JSON API：</strong> 内置了一个轻量级的JSON API  </li>
<li><strong>响应式流（Reactive Streams) API：</strong> Java 9中引入了新的响应式流 API 来支持 Java 9 中的响应式编程。  </li>
</ul>
<h4 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h4><p>Java 9 最大的变化之一是引入了模块系统（Jigsaw 项目）。<br>模块就是代码和数据的封装体。模块的代码被组织成多个包，每个包中包含Java类和接口；模块的数据则包括资源文件和其他静态信息。<br>Java 9 模块的重要特征是在其工件（artifact）的根目录中包含了一个描述模块的 module-info.class 文 件。 工件的格式可以是传统的 JAR 文件或是 Java 9 新增的 JMOD 文件。这个文件由根目录中的源代码文件 module-info.java 编译而来。该模块声明文件可以描述模块的不同特征。<br>在 module-info.java 文件中，我们可以用新的关键词module来声明一个模块，如下所示。下面给出了一个模块com.mycompany.mymodule的最基本的模块声明。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module com.alvin.mymodule &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h5><p>接下来我们创建一个com.alvin.greetings的模块。<br><strong>第一步</strong><br>创建文件夹 alvin/src，然后在src目录下创建与模块名相同的文件夹 com.alvin.greetings。  </p>
<p><strong>第二步</strong><br>在com.alvin.greetings文件夹下创建module-info.java文件，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module com.alvin.greetings &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>第三步</strong><br>在模块中添加源代码文件，在目录 alvin/src/com/alvin/greetings中创建文件Java9Demo.java，代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.alvin.greetings;</span><br><span class="line"></span><br><span class="line">public class Java9Demo &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第四步</strong><br>创建文件夹java/mods，然后在该目录下创建com.alvin.greetings文件夹，编译模块到这个目录下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javac -d mods/com.alvin.greetings </span><br><span class="line">  src/com.alvin.greetings/module-info.java </span><br><span class="line">  src/com.alvin.greetings/com/alvin/greetings/Java9Demo.java</span><br></pre></td></tr></table></figure>
<p><strong>第五步</strong><br>执行模块，查看输出结果：    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java --module-path mods -m com.alvin.greetings/com.alvin.greetings.Java9Demo</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>
<p><em>module-path</em> 指定了模块所在的路径。<br><em>-m</em> 指定主要模块。  </p>
<h4 id="Java-9-REPL-JShell"><a href="#Java-9-REPL-JShell" class="headerlink" title="Java 9 REPL (JShell)"></a>Java 9 REPL (JShell)</h4><p>REPL(Read Eval Print Loop)意为交互式的编程环境。<br>JShell 是 Java 9 新增的一个交互式的编程环境工具。它允许你无需使用类或者方法包装来执行 Java 语句。它与 Python 的解释器类似，可以直接 输入表达式并查看其执行结果。  </p>
<h5 id="执行-JSHELL"><a href="#执行-JSHELL" class="headerlink" title="执行 JSHELL"></a>执行 JSHELL</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ jshell</span><br><span class="line">|  Welcome to JShell -- Version 9-ea</span><br><span class="line">|  For an introduction type: /help intro</span><br><span class="line">jshell&gt;</span><br></pre></td></tr></table></figure>
<h5 id="查看-JShell-命令"><a href="#查看-JShell-命令" class="headerlink" title="查看 JShell 命令"></a>查看 JShell 命令</h5><p>输入 /help 可以查看 JShell相关的命令：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; /help</span><br><span class="line">|  Type a Java language expression, statement, or declaration.</span><br><span class="line">|  Or type one of the following commands:</span><br><span class="line">|  /list [&lt;name or id&gt;|-all|-start]</span><br><span class="line">|  list the source you have typed</span><br><span class="line">|  /edit &lt;name or id&gt;</span><br><span class="line">|  edit a source entry referenced by name or id</span><br><span class="line">|  /drop &lt;name or id&gt;</span><br><span class="line">|  delete a source entry referenced by name or id</span><br><span class="line">|  /save [-all|-history|-start] &lt;file&gt;</span><br><span class="line">|  Save snippet source to a file.</span><br><span class="line">|  /open &lt;file&gt;</span><br><span class="line">|  open a file as source input</span><br><span class="line">|  /vars [&lt;name or id&gt;|-all|-start]</span><br><span class="line">|  list the declared variables and their values</span><br><span class="line">|  /methods [&lt;name or id&gt;|-all|-start]</span><br><span class="line">|  list the declared methods and their signatures</span><br><span class="line">|  /types [&lt;name or id&gt;|-all|-start]</span><br><span class="line">|  list the declared types</span><br><span class="line">|  /imports </span><br><span class="line">|  list the imported items</span><br></pre></td></tr></table></figure>
<h5 id="执行-JShell-命令"><a href="#执行-JShell-命令" class="headerlink" title="执行 JShell 命令"></a>执行 JShell 命令</h5><p>/imports 命令用于查看已导入的包：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; /imports</span><br><span class="line">|    import java.io.*</span><br><span class="line">|    import java.math.*</span><br><span class="line">|    import java.net.*</span><br><span class="line">|    import java.nio.file.*</span><br><span class="line">|    import java.util.*</span><br><span class="line">|    import java.util.concurrent.*</span><br><span class="line">|    import java.util.function.*</span><br><span class="line">|    import java.util.prefs.*</span><br><span class="line">|    import java.util.regex.*</span><br><span class="line">|    import java.util.stream.*</span><br><span class="line">jshell&gt;</span><br></pre></td></tr></table></figure>
<h5 id="JShell-执行计算"><a href="#JShell-执行计算" class="headerlink" title="JShell 执行计算"></a>JShell 执行计算</h5><p>以下实例执行 JShell 简单计算：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; 3+1</span><br><span class="line">$1 ==&gt; 4</span><br><span class="line">jshell&gt; 13%7</span><br><span class="line">$2 ==&gt; 6</span><br><span class="line">jshell&gt; $2</span><br><span class="line">$2 ==&gt; 6</span><br><span class="line">jshell&gt;</span><br></pre></td></tr></table></figure>
<h5 id="JShell-创建与使用函数"><a href="#JShell-创建与使用函数" class="headerlink" title="JShell 创建与使用函数"></a>JShell 创建与使用函数</h5><p>创建一个函数 doubled() ，将传入的整型参数乘于 2 后返回：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; int doubled(int i)&#123; return i*2;&#125;</span><br><span class="line">|  created method doubled(int)</span><br><span class="line">jshell&gt; doubled(6)</span><br><span class="line">$3 ==&gt; 12</span><br><span class="line">jshell&gt;</span><br></pre></td></tr></table></figure>
<h5 id="退出-JShell"><a href="#退出-JShell" class="headerlink" title="退出 JShell"></a>退出 JShell</h5><p>输入 /exit 命令退出 jshell：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jshell&gt; /exit</span><br><span class="line">| Goodbye</span><br></pre></td></tr></table></figure>
<h5 id="多版本兼容-jar-包"><a href="#多版本兼容-jar-包" class="headerlink" title="多版本兼容 jar 包"></a>多版本兼容 jar 包</h5><p>多版本兼容 JAR 功能能让你创建仅在特定版本的 Java 环境中运行库程序时选择使用的 class 版本。<br>通过 <code>--release</code> 参数指定编译版本。<br>具体的变化就是 META-INF 目录下 MANIFEST.MF 文件新增了一个属性：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Multi-Release: true</span><br></pre></td></tr></table></figure>
<p>然后 META-INF 目录下还新增了一个 versions 目录，如果是要支持 java9，则在 versions 目录下有 9 的目录。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">multirelease.jar</span><br><span class="line">├── META-INF</span><br><span class="line">│   └── versions</span><br><span class="line">│       └── 9</span><br><span class="line">│           └── multirelease</span><br><span class="line">│               └── Helper.class</span><br><span class="line">├── multirelease</span><br><span class="line">    ├── Helper.class</span><br><span class="line">    └── Main.class</span><br></pre></td></tr></table></figure>
<p>在以下实例中，我们使用多版本兼容 JAR 功能将 Tester.java 文件生成了两个版本的 jar 包, 一个是 jdk 7，另一个是 jdk 9，然后我们再不同环境下执行。  </p>
<p><strong>第一步</strong>   </p>
<p>创建文件夹 c:/test/java7/com/alvin，并在该文件夹下创建 Test.java 文件，代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.alvin;</span><br><span class="line"></span><br><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      System.out.println(&quot;Inside java 7&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第二步</strong>     </p>
<p>创建文件夹 c:/test/java9/com/alvin，并在该文件夹下创建 Test.java 文件，代码如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.alvin;</span><br><span class="line"></span><br><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      System.out.println(&quot;Inside java 9&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译源代码：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\test &gt; javac --release 9 java9/com/alvin/Tester.java    C:\JAVA &gt; javac --release 7 java7/com/alvin/Tester.java</span><br></pre></td></tr></table></figure>
<p>创建多版本兼容 jar 包    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\JAVA &gt; jar -c -f test.jar -C java7 . --release 9 -C java9.</span><br><span class="line">Warning: entry META-INF/versions/9/com/alvin/Tester.java, </span><br><span class="line">   multiple resources with same name</span><br></pre></td></tr></table></figure>
<p>使用 JDK 7 执行：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\JAVA &gt; java -cp test.jar com.tutorialspoint.Tester</span><br><span class="line">Inside Java 7</span><br></pre></td></tr></table></figure>
<p>使用 JDK 9 执行：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\JAVA &gt; java -cp test.jar com.tutorialspoint.Tester</span><br><span class="line">Inside Java 9</span><br></pre></td></tr></table></figure>
<h4 id="集合工厂方法"><a href="#集合工厂方法" class="headerlink" title="集合工厂方法"></a>集合工厂方法</h4><p>Java 9 List，Set 和 Map 接口中，新的静态工厂方法可以创建这些集合的不可变实例。<br>这些工厂方法可以以更简洁的方式来创建集合。  </p>
<h5 id="旧方法创建集合"><a href="#旧方法创建集合" class="headerlink" title="旧方法创建集合"></a>旧方法创建集合</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Set;</span><br><span class="line"> </span><br><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String []args) &#123;</span><br><span class="line">      Set&lt;String&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">      set.add(&quot;A&quot;);</span><br><span class="line">      set.add(&quot;B&quot;);</span><br><span class="line">      set.add(&quot;C&quot;);</span><br><span class="line">      set = Collections.unmodifiableSet(set);</span><br><span class="line">      System.out.println(set);</span><br><span class="line">      List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">      list.add(&quot;A&quot;);</span><br><span class="line">      list.add(&quot;B&quot;);</span><br><span class="line">      list.add(&quot;C&quot;);</span><br><span class="line">      list = Collections.unmodifiableList(list);</span><br><span class="line">      System.out.println(list);</span><br><span class="line">      Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">      map.put(&quot;A&quot;,&quot;Apple&quot;);</span><br><span class="line">      map.put(&quot;B&quot;,&quot;Boy&quot;);</span><br><span class="line">      map.put(&quot;C&quot;,&quot;Cat&quot;);</span><br><span class="line">      map = Collections.unmodifiableMap(map);</span><br><span class="line">      System.out.println(map);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[A, B, C]</span><br><span class="line">[A, B, C]</span><br><span class="line">&#123;A=Apple, B=Boy, C=Cat&#125;</span><br></pre></td></tr></table></figure>
<h5 id="新方法创建集合"><a href="#新方法创建集合" class="headerlink" title="新方法创建集合"></a>新方法创建集合</h5><p>Java 9 中，以下方法被添加到 List，Set 和 Map 接口以及它们的重载对象。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3);</span><br><span class="line">static &lt;E&gt; Set&lt;E&gt;  of(E e1, E e2, E e3);</span><br><span class="line">static &lt;K,V&gt; Map&lt;K,V&gt; of(K k1, V v1, K k2, V v2, K k3, V v3);</span><br><span class="line">static &lt;K,V&gt; Map&lt;K,V&gt; ofEntries(Map.Entry&lt;? extends K,? extends V&gt;... entries)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>List 和 Set 接口, of(…) 方法重载了 0 ~ 10 个参数的不同方法 。  </p>
</li>
<li><p>Map 接口, of(…) 方法重载了 0 ~ 10 个参数的不同方法 。  </p>
</li>
<li><p>Map 接口如果超过 10 个参数, 可以使用 ofEntries(…) 方法。  </p>
</li>
</ul>
<h5 id="新方法创建集合实例"><a href="#新方法创建集合实例" class="headerlink" title="新方法创建集合实例"></a>新方法创建集合实例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.AbstractMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Set;</span><br><span class="line"> </span><br><span class="line">public class Tester &#123;</span><br><span class="line"> </span><br><span class="line">   public static void main(String []args) &#123;</span><br><span class="line">      Set&lt;String&gt; set = Set.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);      </span><br><span class="line">      System.out.println(set);</span><br><span class="line">      List&lt;String&gt; list = List.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);</span><br><span class="line">      System.out.println(list);</span><br><span class="line">      Map&lt;String, String&gt; map = Map.of(&quot;A&quot;,&quot;Apple&quot;,&quot;B&quot;,&quot;Boy&quot;,&quot;C&quot;,&quot;Cat&quot;);</span><br><span class="line">      System.out.println(map);</span><br><span class="line">  </span><br><span class="line">      Map&lt;String, String&gt; map1 = Map.ofEntries (</span><br><span class="line">         new AbstractMap.SimpleEntry&lt;&gt;(&quot;A&quot;,&quot;Apple&quot;),</span><br><span class="line">         new AbstractMap.SimpleEntry&lt;&gt;(&quot;B&quot;,&quot;Boy&quot;),</span><br><span class="line">         new AbstractMap.SimpleEntry&lt;&gt;(&quot;C&quot;,&quot;Cat&quot;));</span><br><span class="line">      System.out.println(map1);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上输出：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[A, B, C]</span><br><span class="line">[A, B, C]</span><br><span class="line">&#123;A=Apple, B=Boy, C=Cat&#125;</span><br><span class="line">&#123;A=Apple, B=Boy, C=Cat&#125;</span><br></pre></td></tr></table></figure>
<h4 id="私有接口方法"><a href="#私有接口方法" class="headerlink" title="私有接口方法"></a>私有接口方法</h4><p>在 Java 8之前，接口可以有常量变量和抽象方法。如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface Logging &#123;</span><br><span class="line">   String ORACLE = &quot;Oracle_Database&quot;;</span><br><span class="line">   String MYSQL = &quot;MySql_Database&quot;;</span><br><span class="line"> </span><br><span class="line">   void logInfo(String message);</span><br><span class="line">   void logWarn(String message);</span><br><span class="line">   void logError(String message);</span><br><span class="line">   void logFatal(String message);</span><br><span class="line"> </span><br><span class="line">   void getConnection();</span><br><span class="line">   void closeConnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Java 8 接口引入了一些新功能——默认方法和静态方法。我们可以在Java SE 8的接口中编写方法实现，仅仅需要使用 default 关键字来定义它们。<br>在 Java 8 中，一个接口中能定义如下几种变量/方法：  </p>
<ul>
<li>常量  </li>
<li>抽象方法  </li>
<li>默认方法  </li>
<li>静态方法  </li>
</ul>
<p>如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">interface Logging &#123;</span><br><span class="line">   String ORACLE = &quot;Oracle_Database&quot;;</span><br><span class="line">   String MYSQL = &quot;MySql_Database&quot;;</span><br><span class="line"> </span><br><span class="line">   default void logInfo(String message) &#123;</span><br><span class="line">      getConnection();</span><br><span class="line">      System.out.println(&quot;Log Message : &quot; + &quot;INFO&quot;);</span><br><span class="line">      closeConnection();</span><br><span class="line">   &#125;</span><br><span class="line">   default void logWarn(String message) &#123;</span><br><span class="line">      getConnection();</span><br><span class="line">      System.out.println(&quot;Log Message : &quot; + &quot;WARN&quot;);</span><br><span class="line">      closeConnection();</span><br><span class="line">   &#125;</span><br><span class="line">   default void logError(String message) &#123;</span><br><span class="line">      getConnection();</span><br><span class="line">      System.out.println(&quot;Log Message : &quot; + &quot;ERROR&quot;);</span><br><span class="line">      closeConnection();</span><br><span class="line">   &#125;</span><br><span class="line">   default void logFatal(String message) &#123;</span><br><span class="line">      getConnection();</span><br><span class="line">      System.out.println(&quot;Log Message : &quot; + &quot;FATAL&quot;);</span><br><span class="line">      closeConnection();</span><br><span class="line">   &#125;</span><br><span class="line">   static void getConnection() &#123;</span><br><span class="line">      System.out.println(&quot;Open Database connection&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   static void closeConnection() &#123;</span><br><span class="line">      System.out.println(&quot;Close Database connection&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Java 9 不仅像 Java 8 一样支持接口默认方法，同时还支持私有方法<br>在 Java 9 中，一个接口中能定义如下几种变量/方法：  </p>
<ul>
<li>常量  </li>
<li>抽象方法  </li>
<li>默认方法  </li>
<li>静态方法  </li>
<li>私有方法  </li>
<li>私有静态方法  </li>
</ul>
<p>以下实例提取了冗余到通用方法，看起来明显更简洁：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String []args) &#123;</span><br><span class="line">      LogOracle log = new LogOracle();</span><br><span class="line">      log.logInfo(&quot;&quot;);</span><br><span class="line">      log.logWarn(&quot;&quot;);</span><br><span class="line">      log.logError(&quot;&quot;);</span><br><span class="line">      log.logFatal(&quot;&quot;);</span><br><span class="line">      </span><br><span class="line">      LogMySql log1 = new LogMySql();</span><br><span class="line">      log1.logInfo(&quot;&quot;);</span><br><span class="line">      log1.logWarn(&quot;&quot;);</span><br><span class="line">      log1.logError(&quot;&quot;);</span><br><span class="line">      log1.logFatal(&quot;&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">final class LogOracle implements Logging &#123; </span><br><span class="line">&#125;</span><br><span class="line">final class LogMySql implements Logging &#123; </span><br><span class="line">&#125;</span><br><span class="line">interface Logging &#123;</span><br><span class="line">   String ORACLE = &quot;Oracle_Database&quot;;</span><br><span class="line">   String MYSQL = &quot;MySql_Database&quot;;</span><br><span class="line"> </span><br><span class="line">   private void log(String message, String prefix) &#123;</span><br><span class="line">      getConnection();</span><br><span class="line">      System.out.println(&quot;Log Message : &quot; + prefix);</span><br><span class="line">      closeConnection();</span><br><span class="line">   &#125;</span><br><span class="line">   default void logInfo(String message) &#123;</span><br><span class="line">      log(message, &quot;INFO&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   default void logWarn(String message) &#123;</span><br><span class="line">      log(message, &quot;WARN&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   default void logError(String message) &#123;</span><br><span class="line">      log(message, &quot;ERROR&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   default void logFatal(String message) &#123;</span><br><span class="line">      log(message, &quot;FATAL&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   private static void getConnection() &#123;</span><br><span class="line">      System.out.println(&quot;Open Database connection&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   private static void closeConnection() &#123;</span><br><span class="line">      System.out.println(&quot;Close Database connection&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="改进的进程-API"><a href="#改进的进程-API" class="headerlink" title="改进的进程 API"></a>改进的进程 API</h4><p>在 Java 9 之前，Process API 仍然缺乏对使用本地进程的基本支持，例如获取进程的 PID 和所有者，进程的开始时间，进程使用了多少 CPU 时间，多少本地进程正在运行等。<br>Java 9 向 Process API 添加了一个名为 ProcessHandle 的接口来增强 java.lang.Process 类。<br>ProcessHandle 接口的实例标识一个本地进程，它允许查询进程状态并管理进程。<br>ProcessHandle 嵌套接口 Info 来让开发者逃离时常因为要获取一个本地进程的 PID 而不得不使用本地代码的窘境。<br>我们不能在接口中提供方法实现。如果我们要提供抽象方法和非抽象方法（方法与实现）的组合，那么我们就得使用抽象类。<br>ProcessHandle 接口中声明的 onExit() 方法可用于在某个进程终止时触发某些操作。  </p>
<p>实例：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.time.ZoneId;</span><br><span class="line">import java.util.stream.Stream;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"> </span><br><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) throws IOException &#123;</span><br><span class="line">      ProcessBuilder pb = new ProcessBuilder(&quot;notepad.exe&quot;);</span><br><span class="line">      String np = &quot;Not Present&quot;;</span><br><span class="line">      Process p = pb.start();</span><br><span class="line">      ProcessHandle.Info info = p.info();</span><br><span class="line">      System.out.printf(&quot;Process ID : %s%n&quot;, p.pid());</span><br><span class="line">      System.out.printf(&quot;Command name : %s%n&quot;, info.command().orElse(np));</span><br><span class="line">      System.out.printf(&quot;Command line : %s%n&quot;, info.commandLine().orElse(np));</span><br><span class="line"> </span><br><span class="line">      System.out.printf(&quot;Start time: %s%n&quot;,</span><br><span class="line">         info.startInstant().map(i -&gt; i.atZone(ZoneId.systemDefault())</span><br><span class="line">         .toLocalDateTime().toString()).orElse(np));</span><br><span class="line"> </span><br><span class="line">      System.out.printf(&quot;Arguments : %s%n&quot;,</span><br><span class="line">         info.arguments().map(a -&gt; Stream.of(a).collect(</span><br><span class="line">         Collectors.joining(&quot; &quot;))).orElse(np));</span><br><span class="line"> </span><br><span class="line">      System.out.printf(&quot;User : %s%n&quot;, info.user().orElse(np));</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上输出：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Process ID : 5800</span><br><span class="line">Command name : C:\Windows\System32\notepad.exe</span><br><span class="line">Command line : Not Present</span><br><span class="line">Start time: 2017-11-04T21:35:03.626</span><br><span class="line">Arguments : Not Present</span><br><span class="line">User: administrator</span><br></pre></td></tr></table></figure>
<h4 id="改进的-Stream-API"><a href="#改进的-Stream-API" class="headerlink" title="改进的 Stream API"></a>改进的 Stream API</h4><p>Java 9 改进的 Stream API 添加了一些便利的方法，使流处理更容易，并使用收集器编写复杂的查询。<br>Java 9 为 Stream 新增了几个方法：dropWhile、takeWhile、ofNullable，为 iterate 方法新增了一个重载方法。  </p>
<h5 id="takeWhile-方法"><a href="#takeWhile-方法" class="headerlink" title="takeWhile 方法"></a>takeWhile 方法</h5><p><strong>语法</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default Stream&lt;T&gt; takeWhile(Predicate&lt;? super T&gt; predicate)</span><br></pre></td></tr></table></figure>
<p>takeWhile() 方法使用一个断言作为参数，返回给定 Stream 的子集直到断言语句第一次返回 false。如果第一个值不满足断言条件，将返回一个空的 Stream。<br>takeWhile() 方法在有序的 Stream 中，takeWhile 返回从开头开始的尽量多的元素；在无序的 Stream 中，takeWhile 返回从开头开始的符合 Predicate 要求的元素的子集。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import java.util.stream.Stream;</span><br><span class="line"> </span><br><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Stream.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;&quot;,&quot;e&quot;,&quot;f&quot;).takeWhile(s-&gt;!s.isEmpty())</span><br><span class="line">         .forEach(System.out::print);      </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上实例 takeWhile 方法在碰到空字符串时停止循环输出，执行输出结果为：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abc</span><br></pre></td></tr></table></figure>
<h5 id="dropWhile-方法"><a href="#dropWhile-方法" class="headerlink" title="dropWhile 方法"></a>dropWhile 方法</h5><p><strong>语法</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default Stream&lt;T&gt; dropWhile(Predicate&lt;? super T&gt; predicate)</span><br></pre></td></tr></table></figure>
<p>dropWhile 方法和 takeWhile 作用相反的，使用一个断言作为参数，直到断言语句第一次返回 true 才返回给定 Stream 的子集。<br>实例：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import java.util.stream.Stream;</span><br><span class="line"> </span><br><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Stream.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;&quot;,&quot;e&quot;,&quot;f&quot;).dropWhile(s-&gt; !s.isEmpty())</span><br><span class="line">         .forEach(System.out::print);</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上实例 dropWhile 方法在碰到空字符串时开始循环输出，执行输出结果为：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ef</span><br></pre></td></tr></table></figure>
<h5 id="iterate-方法"><a href="#iterate-方法" class="headerlink" title="iterate 方法"></a>iterate 方法</h5><p><strong>语法</strong>   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; Stream&lt;T&gt; iterate(T seed, Predicate&lt;? super T&gt; hasNext, UnaryOperator&lt;T&gt; next)</span><br></pre></td></tr></table></figure>
<p>方法允许使用初始种子值创建顺序（可能是无限）流，并迭代应用指定的下一个方法。 当指定的 hasNext 的 predicate 返回 false 时，迭代停止。<br>实例：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.util.stream.IntStream;</span><br><span class="line"> </span><br><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      IntStream.iterate(3, x -&gt; x &lt; 10, x -&gt; x+ 3).forEach(System.out::println);</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">6</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
<h5 id="ofNullable方法"><a href="#ofNullable方法" class="headerlink" title="ofNullable方法"></a>ofNullable方法</h5><p><strong>语法</strong>   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; Stream&lt;T&gt; ofNullable(T t)</span><br></pre></td></tr></table></figure>
<p>ofNullable 方法可以预防 NullPointerExceptions 异常， 可以通过检查流来避免 null 值。<br>如果指定元素为非 null，则获取一个元素并生成单个元素流，元素为 null 则返回一个空流。   </p>
<p>实例：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import java.util.stream.Stream;</span><br><span class="line"> </span><br><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      long count = Stream.ofNullable(100).count();</span><br><span class="line">      System.out.println(count);</span><br><span class="line">  </span><br><span class="line">      count = Stream.ofNullable(null).count();</span><br><span class="line">      System.out.println(count);</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行输出结果为：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h4 id="改进的-try-with-resources"><a href="#改进的-try-with-resources" class="headerlink" title="改进的 try-with-resources"></a>改进的 try-with-resources</h4><p>try-with-resources 是 JDK 7 中一个新的异常处理机制，它能够很容易地关闭在 try-catch 语句块中使用的资源。所谓的资源（resource）是指在程序完成后，必须关闭的对象。try-with-resources 语句确保了每个资源在语句结束时关闭。所有实现了 java.lang.AutoCloseable 接口（其中，它包括实现了 java.io.Closeable 的所有对象），可以使用作为资源。<br>try-with-resources 声明在 JDK 9 已得到改进。如果你已经有一个资源是 final 或等效于 final 变量,您可以在 try-with-resources 语句中使用该变量，而无需在 try-with-resources 语句中声明一个新变量。   </p>
<p>实例：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.Reader;</span><br><span class="line">import java.io.StringReader;</span><br><span class="line"> </span><br><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) throws IOException &#123;</span><br><span class="line">      System.out.println(readData(&quot;test&quot;));</span><br><span class="line">   &#125; </span><br><span class="line">   static String readData(String message) throws IOException &#123;</span><br><span class="line">      Reader inputString = new StringReader(message);</span><br><span class="line">      BufferedReader br = new BufferedReader(inputString);</span><br><span class="line">      try (BufferedReader br1 = br) &#123;</span><br><span class="line">         return br1.readLine();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test</span><br></pre></td></tr></table></figure>
<p>以上实例中我们需要在 try 语句块中声明资源 br1，然后才能使用它。<br>在 Java 9 中，我们不需要声明资源 br1 就可以使用它，并得到相同的结果。   </p>
<p>实例：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.Reader;</span><br><span class="line">import java.io.StringReader;</span><br><span class="line"> </span><br><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) throws IOException &#123;</span><br><span class="line">      System.out.println(readData(&quot;test&quot;));</span><br><span class="line">   &#125; </span><br><span class="line">   static String readData(String message) throws IOException &#123;</span><br><span class="line">      Reader inputString = new StringReader(message);</span><br><span class="line">      BufferedReader br = new BufferedReader(inputString);</span><br><span class="line">      try (br) &#123;</span><br><span class="line">         return br.readLine();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行输出结果为：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test</span><br></pre></td></tr></table></figure>
<p>在处理必须关闭的资源时，使用try-with-resources语句替代try-finally语句。 生成的代码更简洁，更清晰，并且生成的异常更有用。 try-with-resources语句在编写必须关闭资源的代码时会更容易，也不会出错，而使用try-finally语句实际上是不可能的。   </p>
<h4 id="钻石操作符-Diamond-Operator"><a href="#钻石操作符-Diamond-Operator" class="headerlink" title="钻石操作符(Diamond Operator)"></a>钻石操作符(Diamond Operator)</h4><p>钻石操作符是在 java 7 中引入的，可以让代码更易读，但它不能用于匿名的内部类。<br>在 java 9 中， 它可以与匿名的内部类一起使用，从而提高代码的可读性。<br>考虑以下 Java 9 之前的代码：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Handler&lt;Integer&gt; intHandler = new Handler&lt;Integer&gt;(1) &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void handle() &#123;</span><br><span class="line">            System.out.println(content);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      intHandler.handle();</span><br><span class="line">      Handler&lt;? extends Number&gt; intHandler1 = new Handler&lt;Number&gt;(2) &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void handle() &#123;</span><br><span class="line">            System.out.println(content);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      intHandler1.handle();</span><br><span class="line">      Handler&lt;?&gt; handler = new Handler&lt;Object&gt;(&quot;test&quot;) &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void handle() &#123;</span><br><span class="line">            System.out.println(content);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      handler.handle();    </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br><span class="line">abstract class Handler&lt;T&gt; &#123;</span><br><span class="line">   public T content;</span><br><span class="line"> </span><br><span class="line">   public Handler(T content) &#123;</span><br><span class="line">      this.content = content; </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   abstract void handle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">Test</span><br></pre></td></tr></table></figure>
<p>在 Java 9 中，我们可以在匿名类中使用 &lt;&gt; 操作符，如下所示：<br>实例：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Handler&lt;Integer&gt; intHandler = new Handler&lt;&gt;(1) &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void handle() &#123;</span><br><span class="line">            System.out.println(content);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      intHandler.handle();</span><br><span class="line">      Handler&lt;? extends Number&gt; intHandler1 = new Handler&lt;&gt;(2) &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void handle() &#123;</span><br><span class="line">            System.out.println(content);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      intHandler1.handle();</span><br><span class="line">      Handler&lt;?&gt; handler = new Handler&lt;&gt;(&quot;test&quot;) &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void handle() &#123;</span><br><span class="line">            System.out.println(content);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"> </span><br><span class="line">      handler.handle();    </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">abstract class Handler&lt;T&gt; &#123;</span><br><span class="line">   public T content;</span><br><span class="line"> </span><br><span class="line">   public Handler(T content) &#123;</span><br><span class="line">      this.content = content; </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   abstract void handle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">Test</span><br></pre></td></tr></table></figure>
<h4 id="改进的-Optional-类"><a href="#改进的-Optional-类" class="headerlink" title="改进的 Optional 类"></a>改进的 Optional 类</h4><p>Optional 类在 Java 8 中引入，Optional 类的引入很好的解决空指针异常。。在 java 9 中, 添加了三个方法来改进它的功能：   </p>
<ul>
<li>stream()  </li>
<li>ifPresentOrElse()  </li>
<li>or()  </li>
</ul>
<h5 id="stream-方法"><a href="#stream-方法" class="headerlink" title="stream() 方法"></a>stream() 方法</h5><p><strong>语法</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Stream&lt;T&gt; stream()</span><br></pre></td></tr></table></figure>
<p>stream 方法的作用就是将 Optional 转为一个 Stream，如果该 Optional 中包含值，那么就返回包含这个值的 Stream，否则返回一个空的 Stream（Stream.empty()）。<br>实例：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Optional;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line">import java.util.stream.Stream;</span><br><span class="line"> </span><br><span class="line">public class Tester &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">   List&lt;Optional&lt;String&gt;&gt; list = Arrays.asList (</span><br><span class="line">      Optional.empty(), </span><br><span class="line">      Optional.of(&quot;A&quot;), </span><br><span class="line">      Optional.empty(), </span><br><span class="line">      Optional.of(&quot;B&quot;));</span><br><span class="line"> </span><br><span class="line">      //filter the list based to print non-empty values</span><br><span class="line">  </span><br><span class="line">      //if optional is non-empty, get the value in stream, otherwise return empty</span><br><span class="line">      List&lt;String&gt; filteredList = list.stream()</span><br><span class="line">         .flatMap(o -&gt; o.isPresent() ? Stream.of(o.get()) : Stream.empty())</span><br><span class="line">         .collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line">      //Optional::stream method will return a stream of either one </span><br><span class="line">      //or zero element if data is present or not.</span><br><span class="line">      List&lt;String&gt; filteredListJava9 = list.stream()</span><br><span class="line">         .flatMap(Optional::stream)</span><br><span class="line">         .collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line">      System.out.println(filteredList);</span><br><span class="line">      System.out.println(filteredListJava9);</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行输出结果为：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[A, B]</span><br><span class="line">[A, B]</span><br></pre></td></tr></table></figure>
<h5 id="ifPresentOrElse-方法"><a href="#ifPresentOrElse-方法" class="headerlink" title="ifPresentOrElse() 方法"></a>ifPresentOrElse() 方法</h5><p><strong>语法</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void ifPresentOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction)</span><br></pre></td></tr></table></figure>
<p>ifPresentOrElse 方法的改进就是有了 else，接受两个参数 Consumer 和 Runnable。<br>ifPresentOrElse 方法的用途是，如果一个 Optional 包含值，则对其包含的值调用函数 action，即 action.accept(value)，这与 ifPresent 一致；与 ifPresent 方法的区别在于，ifPresentOrElse 还有第二个参数 emptyAction —— 如果 Optional 不包含值，那么 ifPresentOrElse 便会调用 emptyAction，即 emptyAction.run()。  </p>
<p>实例：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Optional;</span><br><span class="line"> </span><br><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Optional&lt;Integer&gt; optional = Optional.of(1);</span><br><span class="line"> </span><br><span class="line">      optional.ifPresentOrElse( x -&gt; System.out.println(&quot;Value: &quot; + x),() -&gt; </span><br><span class="line">         System.out.println(&quot;Not Present.&quot;));</span><br><span class="line"> </span><br><span class="line">      optional = Optional.empty();</span><br><span class="line"> </span><br><span class="line">      optional.ifPresentOrElse( x -&gt; System.out.println(&quot;Value: &quot; + x),() -&gt; </span><br><span class="line">         System.out.println(&quot;Not Present.&quot;));</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Value: 1</span><br><span class="line">Not Present.</span><br></pre></td></tr></table></figure>
<h4 id="or-方法"><a href="#or-方法" class="headerlink" title="or() 方法"></a>or() 方法</h4><p><strong>语法</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Optional&lt;T&gt; or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier)</span><br></pre></td></tr></table></figure>
<p>如果值存在，返回 Optional 指定的值，否则返回一个预设的值。<br>实例：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Optional;</span><br><span class="line">import java.util.function.Supplier;</span><br><span class="line"> </span><br><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Optional&lt;String&gt; optional1 = Optional.of(&quot;Mahesh&quot;);</span><br><span class="line">      Supplier&lt;Optional&lt;String&gt;&gt; supplierString = () -&gt; Optional.of(&quot;Not Present&quot;);</span><br><span class="line">      optional1 = optional1.or( supplierString);</span><br><span class="line">      optional1.ifPresent( x -&gt; System.out.println(&quot;Value: &quot; + x));</span><br><span class="line">      optional1 = Optional.empty();    </span><br><span class="line">      optional1 = optional1.or( supplierString);</span><br><span class="line">      optional1.ifPresent( x -&gt; System.out.println(&quot;Value: &quot; + x));  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行输出结果为：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Value: Mahesh</span><br><span class="line">Value: Not Present</span><br></pre></td></tr></table></figure>
<h4 id="多分辨率图像-API"><a href="#多分辨率图像-API" class="headerlink" title="多分辨率图像 API"></a>多分辨率图像 API</h4><p>Java 9 定义多分辨率图像 API，开发者可以很容易的操作和展示不同分辨率的图像了。<br>以下是多分辨率图像的主要操作方法：  </p>
<ul>
<li><strong>Image getResolutionVariant(double destImageWidth, double destImageHeight)</strong> − 获取特定分辨率的图像变体-表示一张已知分辨率单位为DPI的特定尺寸大小的逻辑图像，并且这张图像是最佳的变体。</li>
<li><strong>List<image> getResolutionVariants()</image></strong> − 返回可读的分辨率的图像变体列表。<br>实例：  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.URL;</span><br><span class="line">import java.net.MalformedURLException;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.awt.Image;</span><br><span class="line">import java.awt.image.MultiResolutionImage;</span><br><span class="line">import java.awt.image.BaseMultiResolutionImage;</span><br><span class="line"> </span><br><span class="line">import javax.imageio.ImageIO;</span><br><span class="line"> </span><br><span class="line">public class Tester &#123;</span><br><span class="line">   public static void main(String[] args) throws IOException, MalformedURLException &#123;</span><br><span class="line"> </span><br><span class="line">      List&lt;String&gt; imgUrls = List.of(&quot;http://www.runoob.com/wp-content/themes/runoob/assets/img/runoob-logo@2x.png&quot;,</span><br><span class="line">         &quot;http://www.runoob.com/wp-content/themes/runoob/assets/img/runoob-logo.png&quot;,</span><br><span class="line">         &quot;http://www.runoob.com/wp-content/themes/runoob/assets/images/qrcode.png&quot;);</span><br><span class="line"> </span><br><span class="line">      List&lt;Image&gt; images = new ArrayList&lt;Image&gt;();</span><br><span class="line"> </span><br><span class="line">      for (String url : imgUrls) &#123;</span><br><span class="line">         images.add(ImageIO.read(new URL(url)));</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      // 读取所有图片</span><br><span class="line">      MultiResolutionImage multiResolutionImage = </span><br><span class="line">         new BaseMultiResolutionImage(images.toArray(new Image[0]));</span><br><span class="line"> </span><br><span class="line">      // 获取图片的所有分辨率</span><br><span class="line">      List&lt;Image&gt; variants = multiResolutionImage.getResolutionVariants();</span><br><span class="line"> </span><br><span class="line">      System.out.println(&quot;Total number of images: &quot; + variants.size());</span><br><span class="line"> </span><br><span class="line">      for (Image img : variants) &#123;</span><br><span class="line">         System.out.println(img);</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      // 根据不同尺寸获取对应的图像分辨率</span><br><span class="line">      Image variant1 = multiResolutionImage.getResolutionVariant(156, 45);</span><br><span class="line">      System.out.printf(&quot;\nImage for destination[%d,%d]: [%d,%d]&quot;, </span><br><span class="line">         156, 45, variant1.getWidth(null), variant1.getHeight(null));</span><br><span class="line"> </span><br><span class="line">      Image variant2 = multiResolutionImage.getResolutionVariant(311, 89);</span><br><span class="line">      System.out.printf(&quot;\nImage for destination[%d,%d]: [%d,%d]&quot;, 311, 89, </span><br><span class="line">         variant2.getWidth(null), variant2.getHeight(null));</span><br><span class="line"> </span><br><span class="line">      Image variant3 = multiResolutionImage.getResolutionVariant(622, 178);</span><br><span class="line">      System.out.printf(&quot;\nImage for destination[%d,%d]: [%d,%d]&quot;, 622, 178, </span><br><span class="line">         variant3.getWidth(null), variant3.getHeight(null));</span><br><span class="line"> </span><br><span class="line">      Image variant4 = multiResolutionImage.getResolutionVariant(300, 300);</span><br><span class="line">      System.out.printf(&quot;\nImage for destination[%d,%d]: [%d,%d]&quot;, 300, 300, </span><br><span class="line">         variant4.getWidth(null), variant4.getHeight(null));</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="改进的-CompletableFuture-API"><a href="#改进的-CompletableFuture-API" class="headerlink" title="改进的 CompletableFuture API"></a>改进的 CompletableFuture API</h4><p>Java 8 引入了 CompletableFuture<t> 类，可能是 java.util.concurrent.Future<t> 明确的完成版（设置了它的值和状态），也可能被用作java.util.concurrent.CompleteStage 。支持 future 完成时触发一些依赖的函数和动作。Java 9 引入了一些CompletableFuture 的改进：<br>Java 9 对 CompletableFuture 做了改进：  </t></t></p>
<ul>
<li>支持 delays 和 timeouts  </li>
<li>提升了对子类化的支持  </li>
<li>新的工厂方法  </li>
</ul>
<h5 id="支持-delays-和-timeouts"><a href="#支持-delays-和-timeouts" class="headerlink" title="支持 delays 和 timeouts"></a>支持 delays 和 timeouts</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public CompletableFuture&lt;T&gt; completeOnTimeout(T value, long timeout, TimeUnit unit)</span><br></pre></td></tr></table></figure>
<p>在 timeout（单位在 java.util.concurrent.Timeunits units 中，比如 MILLISECONDS ）前以给定的 value 完成这个 CompletableFutrue。返回这个 CompletableFutrue。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public CompletableFuture&lt;T&gt; orTimeout(long timeout, TimeUnit unit)</span><br></pre></td></tr></table></figure>
<p>如果没有在给定的 timeout 内完成，就以 java.util.concurrent.TimeoutException 完成这个 CompletableFutrue，并返回这个 CompletableFutrue。  </p>
<h5 id="增强了对子类化的支持"><a href="#增强了对子类化的支持" class="headerlink" title="增强了对子类化的支持"></a>增强了对子类化的支持</h5><p>做了许多改进使得 CompletableFuture 可以被更简单的继承。比如，你也许想重写新的 public Executor defaultExecutor() 方法来代替默认的 executor。<br>另一个新的使子类化更容易的方法是：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; newIncompleteFuture()</span><br></pre></td></tr></table></figure>
<h5 id="新的工厂方法"><a href="#新的工厂方法" class="headerlink" title="新的工厂方法"></a>新的工厂方法</h5><p>Java 8引入了  CompletableFuture， completedFuture(U value) 工厂方法来返回一个已经以给定 value 完成了的 CompletableFuture。<br>Java 9以 一个新的  CompletableFuture failedFuture(Throwable ex) 来补充了这个方法，可以返回一个以给定异常完成的 CompletableFuture。<br>除此以外，Java 9 引入了下面这对 stage-oriented 工厂方法，返回完成的或异常完成的 completion stages:  </p>
<ul>
<li><strong> CompletionStage completedStage(U value):</strong> 返回一个新的以指定 value 完成的CompletionStage ，并且只支持 CompletionStage 里的接口。  </li>
<li><strong>CompletionStage failedStage(Throwable ex):</strong> 返回一个新的以指定异常完成的CompletionStage ，并且只支持 CompletionStage 里的接口。     </li>
</ul>
<h4 id="改进的-Javadoc"><a href="#改进的-Javadoc" class="headerlink" title="改进的 Javadoc"></a>改进的 Javadoc</h4><h4 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h4>
      
    </div>
    <footer class="article-footer">
      
      
      
      
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jdk/">jdk</a></li></ul>

      

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->


  
    <article id="post-jdk新特性之jdk8"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/10/15/jdk新特性之jdk8/">jdk新特性之jdk8</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/10/15/jdk新特性之jdk8/" class="article-date">
	  <time datetime="2018-10-15T15:43:00.000Z" itemprop="datePublished">2018-10-15</time>
	</a>

      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>毫无疑问，Java 8是Java自Java 5（发布于2004年）之后的最重要的版本。这个版本包含语言、编译器、库、工具和JVM等方面的十多个新特性。<br><a id="more"></a></p>
<h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><p>Lambda表达式，也称为闭包。Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中）。<br>使用Lambda表达式可以使代码变的更加简洁紧凑。<br>Lambda 表达式免去了使用匿名方法的麻烦，并且给予Java简单但是强大的函数化的编程能力。  </p>
<p>语法：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br><span class="line">或</span><br><span class="line">(parameter) -&gt; &#123;expression;&#125;</span><br></pre></td></tr></table></figure>
<p>Lambda表达式的特征如下：  </p>
<blockquote>
<p>可选类型声明：不需要声明参数类型，编译器可以统一识别。<br>可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。<br>可选的大括号：如果主体包含了一个语句，就不需要使用大括号。<br>可选的返回关键字：如果主体只有一个表达式 。  </p>
</blockquote>
<p>简单例子：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 1. 不需要参数,返回值为 5  </span><br><span class="line">() -&gt; 5  </span><br><span class="line">  </span><br><span class="line">// 2. 接收一个参数(数字类型),返回其2倍的值  </span><br><span class="line">x -&gt; 2 * x  </span><br><span class="line">  </span><br><span class="line">// 3. 接受2个参数(数字),并返回他们的差值  </span><br><span class="line">(x, y) -&gt; x – y  </span><br><span class="line">  </span><br><span class="line">// 4. 接收2个int型整数,返回他们的和  </span><br><span class="line">(int x, int y) -&gt; x + y  </span><br><span class="line">  </span><br><span class="line">// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  </span><br><span class="line">(String s) -&gt; System.out.print(s)</span><br></pre></td></tr></table></figure>
<p>测试：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Java8Lambda &#123;</span><br><span class="line">    interface MathOperation &#123;</span><br><span class="line">        int operation(int a, int b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface GreetingService &#123;</span><br><span class="line">        void sayMessage(String message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int operate(int a, int b, MathOperation mathOperation) &#123;</span><br><span class="line">        return mathOperation.operation(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Java8Lambda java8Lambda = new Java8Lambda();</span><br><span class="line">        // 参数类型声明</span><br><span class="line">        MathOperation addition = (int a, int b) -&gt; a + b;</span><br><span class="line">        // 不用类型声明</span><br><span class="line">        MathOperation subtraction = (a, b) -&gt; a - b;</span><br><span class="line">        // 大括号中返回语句</span><br><span class="line">        MathOperation multiplication = (int a, int b) -&gt; &#123;</span><br><span class="line">            return a * b;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 没有大括号及返回语句</span><br><span class="line">        MathOperation division = (int a, int b) -&gt; a / b;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;6 + 2 = &quot; + java8Lambda.operate(6, 2, addition));</span><br><span class="line">        System.out.println(&quot;6 - 2 = &quot; + java8Lambda.operate(6, 2, subtraction));</span><br><span class="line">        System.out.println(&quot;6 * 2 = &quot; + java8Lambda.operate(6, 2, multiplication));</span><br><span class="line">        System.out.println(&quot;6 / 2 = &quot; + java8Lambda.operate(6, 2, division));</span><br><span class="line">        // 不用括号</span><br><span class="line">        GreetingService gs1 = message -&gt; System.out.println(&quot;hello, &quot; + message);</span><br><span class="line">        // 用括号</span><br><span class="line">        GreetingService gs2 = (message) -&gt; System.out.println(&quot;Hello,&quot; + message);</span><br><span class="line"></span><br><span class="line">        gs1.sayMessage(&quot;Runoob&quot;);</span><br><span class="line">        gs2.sayMessage(&quot;Google&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="接口默认方法"><a href="#接口默认方法" class="headerlink" title="接口默认方法"></a>接口默认方法</h4><p>简单说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。我们只需在方法名前面加个default关键字即可实现默认方法。</p>
<p><strong>为什么要有这个特性？</strong></p>
<blockquote>
<p>首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类，目前的java 8之前的集合框架没有foreach方法，通常能想到的解决办法是在JDK里给相关的接口添加新的方法及实现。然而，对于已经发布的版本，是没法在给接口添加新方法的同时不影响已有的实现。所以引进的默认方法。他们的目的是为了解决接口的修改与现有的实现不兼容的问题。</p>
</blockquote>
<p><strong>语法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Vehicle &#123;</span><br><span class="line">   default void print()&#123;</span><br><span class="line">      System.out.println(&quot;she is lily&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>多个默认方法：</strong><br>一个接口有默认方法，考虑这样的情况，一个类实现了多个接口，且这些接口有相同的默认方法，以下实例说明了这种情况的解决方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface Vehicle &#123;</span><br><span class="line">   default void print()&#123;</span><br><span class="line">      System.out.println(&quot;我是一辆车!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface FourWheeler &#123;</span><br><span class="line">   default void print()&#123;</span><br><span class="line">      System.out.println(&quot;我是一辆四轮车!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个解决方案是创建自己的默认方法，来覆盖重写接口的默认方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Car implements Vehicle, FourWheeler &#123;</span><br><span class="line">   default void print()&#123;</span><br><span class="line">      System.out.println(&quot;我是一辆四轮汽车!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种解决方案可以使用 super 来调用指定接口的默认方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Car implements Vehicle, FourWheeler &#123;</span><br><span class="line">   public void print()&#123;</span><br><span class="line">      Vehicle.super.print();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>Java 8 的另一个特性是接口可以声明（并且可以提供实现）静态方法。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Java8Tester &#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      Vehicle vehicle = new Car();</span><br><span class="line">      vehicle.print();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Vehicle &#123;</span><br><span class="line">   default void print()&#123;</span><br><span class="line">      System.out.println(&quot;我是一辆车!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   static void blowHorn()&#123;</span><br><span class="line">      System.out.println(&quot;按喇叭!!!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface FourWheeler &#123;</span><br><span class="line">   default void print()&#123;</span><br><span class="line">      System.out.println(&quot;我是一辆四轮车!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Car implements Vehicle, FourWheeler &#123;</span><br><span class="line">   public void print()&#123;</span><br><span class="line">      Vehicle.super.print();</span><br><span class="line">      FourWheeler.super.print();</span><br><span class="line">      Vehicle.blowHorn();</span><br><span class="line">      System.out.println(&quot;我是一辆汽车!&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p>函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。<br>函数式接口可以被隐式转换为lambda表达式。<br>函数式接口可以现有的函数友好地支持 lambda。  </p>
<ul>
<li>JDK 1.8之前已有的函数式接口  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Runnable</span><br><span class="line">java.util.concurrent.Callable</span><br><span class="line">java.security.PrivilegedAction</span><br><span class="line">java.util.Comparator</span><br><span class="line">java.io.FileFilter</span><br><span class="line">java.nio.file.PathMatcher</span><br><span class="line">java.lang.reflect.InvocationHandler</span><br><span class="line">java.beans.PropertyChangeListener</span><br><span class="line">java.awt.event.ActionListener</span><br><span class="line">javax.swing.event.ChangeListener</span><br></pre></td></tr></table></figure>
<ul>
<li>JDK 1.8 新增加的函数接口 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.function</span><br></pre></td></tr></table></figure>
<ul>
<li>java.util.function 它包含了很多类，用来支持 Java的 函数式编程，该包中的函数式接口有     </li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">接口 &amp; 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">BiConsumer<t,u> 代表了一个接受两个输入参数的操作，并且不返回任何结果</t,u></td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">BiFunction<t,u,r> 代表了一个接受两个输入参数的方法，并且返回一个结果</t,u,r></td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">BinaryOperator<t> 代表了一个作用于于两个同类型操作符的操作，并且返回了操作符同类型的结果</t></td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">BiPredicate<t,u> 代表了一个两个参数的boolean值方法</t,u></td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">BooleanSupplier代表了boolean值结果的提供方</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">Consumer<t>代表了接受一个输入参数并且无返回的操作</t></td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">DoubleBinaryOperator 代表了作用于两个double值操作符的操作，并且返回了一个double值的结果。</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">DoubleConsumer 代表一个接受double值参数的操作，并且不返回结果。</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left">DoubleFunction<r> 代表接受一个double值参数的方法，并且返回结果</r></td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">DoublePredicate 代表一个拥有double值参数的boolean值方法</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left">DoubleSupplier 代表一个double值结构的提供方</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left">DoubleToIntFunction 接受一个double类型输入，返回一个int类型结果</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left">DoubleToLongFunction 接受一个double类型输入，返回一个long类型结果</td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:left">DoubleUnaryOperator 接受一个参数同为类型double,返回值类型也为double</td>
</tr>
<tr>
<td style="text-align:left">15</td>
<td style="text-align:left">Function<t,r> 接受一个输入参数，返回一个结果</t,r></td>
</tr>
<tr>
<td style="text-align:left">16</td>
<td style="text-align:left">IntBinaryOperator 接受两个参数同为类型int,返回值类型也为int</td>
</tr>
<tr>
<td style="text-align:left">17</td>
<td style="text-align:left">IntConsumer 接受一个int类型的输入参数，无返回值</td>
</tr>
<tr>
<td style="text-align:left">18</td>
<td style="text-align:left">IntFunction<r> 接受一个int类型输入参数，返回一个结果</r></td>
</tr>
<tr>
<td style="text-align:left">19</td>
<td style="text-align:left">IntPredicate 接受一个int输入参数，返回一个布尔值的结果</td>
</tr>
<tr>
<td style="text-align:left">…</td>
<td style="text-align:left">…</td>
</tr>
</tbody>
</table>
<ul>
<li>函数式接口实例<br>redicate <t> 接口是一个函数式接口，它接受一个输入参数 T，返回一个布尔值结果。<br>该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）。<br>该接口用于测试对象是 true 或 false。<br>我们可以通过以下实例（Java8Tester.java）来了解函数式接口 Predicate <t> 的使用：    </t></t></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.function.Predicate;</span><br><span class="line"> </span><br><span class="line">public class Java8Tester &#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);</span><br><span class="line">        </span><br><span class="line">      // Predicate&lt;Integer&gt; predicate = n -&gt; true</span><br><span class="line">      // n 是一个参数传递到 Predicate 接口的 test 方法</span><br><span class="line">      // n 如果存在则 test 方法返回 true</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;输出所有数据:&quot;);</span><br><span class="line">        </span><br><span class="line">      // 传递参数 n</span><br><span class="line">      eval(list, n-&gt;true);</span><br><span class="line">        </span><br><span class="line">      // Predicate&lt;Integer&gt; predicate1 = n -&gt; n%2 == 0</span><br><span class="line">      // n 是一个参数传递到 Predicate 接口的 test 方法</span><br><span class="line">      // 如果 n%2 为 0 test 方法返回 true</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;输出所有偶数:&quot;);</span><br><span class="line">      eval(list, n-&gt; n%2 == 0 );</span><br><span class="line">        </span><br><span class="line">      // Predicate&lt;Integer&gt; predicate2 = n -&gt; n &gt; 3</span><br><span class="line">      // n 是一个参数传递到 Predicate 接口的 test 方法</span><br><span class="line">      // 如果 n 大于 3 test 方法返回 true</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;输出大于 3 的所有数字:&quot;);</span><br><span class="line">      eval(list, n-&gt; n &gt; 3 );</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   public static void eval(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate) &#123;</span><br><span class="line">      for(Integer n: list) &#123;</span><br><span class="line">        </span><br><span class="line">         if(predicate.test(n)) &#123;</span><br><span class="line">            System.out.println(n + &quot; &quot;);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>eval 函数可以写为如下格式  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static void eval(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate) &#123;</span><br><span class="line">    list.stream().filter(predicate).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者直接可以不用定义 eval 函数，使用:   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().filter(n -&gt; n &gt; 3).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>来输出所有大于 3 的数字。   </p>
<h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>方法引用通过方法的名字来指向一个方法。<br>方法引用可以使语言的构造更紧凑简洁，减少冗余代码。<br>方法引用使用一对冒号<code>::</code>。  </p>
<p> 下面，我们在 Car 类中定义了 4 个方法作为例子来区分 Java 中 4 种不同方法的引用。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Supplier&lt;T&gt; &#123;</span><br><span class="line">    T get();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Car &#123;</span><br><span class="line">    //Supplier是jdk1.8的接口，这里和lamda一起使用了</span><br><span class="line">    public static Car create(final Supplier&lt;Car&gt; supplier) &#123;</span><br><span class="line">        return supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void collide(final Car car) &#123;</span><br><span class="line">        System.out.println(&quot;Collided &quot; + car.toString());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void follow(final Car another) &#123;</span><br><span class="line">        System.out.println(&quot;Following the &quot; + another.toString());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void repair() &#123;</span><br><span class="line">        System.out.println(&quot;Repaired &quot; + this.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>构造器引用：</strong> 它的语法是Class::new，或者更一般的Class&lt; T &gt;::new实例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final Car car = Car.create( Car::new );</span><br><span class="line">final List&lt; Car &gt; cars = Arrays.asList( car );</span><br></pre></td></tr></table></figure>
<p><strong>静态方法引用：</strong>它的语法是Class::static_method，实例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cars.forEach( Car::collide );</span><br></pre></td></tr></table></figure></p>
<p><strong>特定类的任意对象的方法引用：</strong>它的语法是Class::method实例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cars.forEach( Car::repair );</span><br></pre></td></tr></table></figure></p>
<p><strong>特定对象的方法引用：</strong>它的语法是instance::method实例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final Car police = Car.create( Car::new );</span><br><span class="line">cars.forEach( police::follow );</span><br></pre></td></tr></table></figure></p>
<ul>
<li>方法引用实例     </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String args[])&#123;</span><br><span class="line">     List names = new ArrayList();</span><br><span class="line">       </span><br><span class="line">     names.add(&quot;Google&quot;);</span><br><span class="line">     names.add(&quot;Runoob&quot;);</span><br><span class="line">     names.add(&quot;Taobao&quot;);</span><br><span class="line">     names.add(&quot;Baidu&quot;);</span><br><span class="line">     names.add(&quot;Sina&quot;);</span><br><span class="line">       </span><br><span class="line">     names.forEach(System.out::println);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h4><p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明式的方式处理数据。<br>Stream使用一种类似用SQL语句从数据库查询数据的直观方式来提供一种对Java集合运算和表达的高阶抽象。<br>Stream API可以极大的提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。<br>这种风格将要处理的元素集合看作一种流，流在管道中传输，并且可以在管道的节点上进行处理，比如筛选、排序、聚合等。<br>元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作（terminal operation）得到前面处理的结果。   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+       +------+   +------+   +---+   +-------+</span><br><span class="line">| stream of elements +-----&gt; |filter+-&gt; |sorted+-&gt; |map+-&gt; |collect|</span><br><span class="line">+--------------------+       +------+   +------+   +---+   +-------+</span><br></pre></td></tr></table></figure>
<p>以上的流程转换为 Java 代码为： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; transactionsIds = </span><br><span class="line">widgets.stream()</span><br><span class="line">             .filter(b -&gt; b.getColor() == RED)</span><br><span class="line">             .sorted((x,y) -&gt; x.getWeight() - y.getWeight())</span><br><span class="line">             .mapToInt(Widget::getWeight)</span><br><span class="line">             .sum();</span><br></pre></td></tr></table></figure>
<ul>
<li>什么是 Stream？<br>Stream（流）是一个来自数据源的元素队列并支持聚合操作</li>
</ul>
<blockquote>
<p>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。<br><strong>数据源</strong> 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。<br><strong>聚合操作</strong> 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。   </p>
</blockquote>
<p>和以前的Collection操作不同， Stream操作还有两个基础的特征：   </p>
<blockquote>
<p><strong>Pipelining:</strong> 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。<br><strong>内部迭代：</strong> 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。   </p>
</blockquote>
<ul>
<li>生成流<br>在 Java 8 中, 集合接口有两个方法来生成流：<br>1）stream() − 为集合创建串行流。<br>2）parallelStream() − 为集合创建并行流。   </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<ul>
<li>forEach<br>Stream 提供了新的方法 ‘forEach’ 来迭代流中的每个数据。以下代码片段使用 forEach 输出了10个随机数：  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = new Random();</span><br><span class="line">random.ints().limit(10).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<ul>
<li>map<br>map 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：   </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);</span><br><span class="line">// 获取对应的平方数</span><br><span class="line">List&lt;Integer&gt; squaresList = numbers.stream().map( i -&gt; i*i).distinct().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<ul>
<li>filter<br>filter 方法用于通过设置的条件过滤出元素。以下代码片段使用 filter 方法过滤出空字符串：  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">// 获取空字符串的数量</span><br><span class="line">int count = strings.stream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure>
<ul>
<li>limit<br>limit 方法用于获取指定数量的流。 以下代码片段使用 limit 方法打印出 10 条数据：  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = new Random();</span><br><span class="line">random.ints().limit(10).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<ul>
<li>sorted<br>sorted 方法用于对流进行排序。以下代码片段使用 sorted 方法对输出的 10 个随机数进行排序：   </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = new Random();</span><br><span class="line">random.ints().limit(10).sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<ul>
<li>并行（parallel）程序<br>parallelStream 是流并行处理程序的代替方法。以下实例我们使用 parallelStream 来输出空字符串的数量： </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">// 获取空字符串的数量</span><br><span class="line">int count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure>
<ul>
<li>Collectors<br>Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors 可用于返回列表或字符串：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line">System.out.println(&quot;筛选列表: &quot; + filtered);</span><br><span class="line">String mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(&quot;, &quot;));</span><br><span class="line">System.out.println(&quot;合并字符串: &quot; + mergedString);</span><br></pre></td></tr></table></figure>
<ul>
<li>统计<br>另外，一些产生统计结果的收集器也非常有用。它们主要用于int、double、long等基本类型上，它们可以用来产生类似如下的统计结果。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);</span><br><span class="line">IntSummaryStatistics stats = integers.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line">System.out.println(&quot;列表中最大的数 : &quot; + stats.getMax());</span><br><span class="line">System.out.println(&quot;列表中最小的数 : &quot; + stats.getMin());</span><br><span class="line">System.out.println(&quot;所有数之和 : &quot; + stats.getSum());</span><br><span class="line">System.out.println(&quot;平均数 : &quot; + stats.getAverage());</span><br></pre></td></tr></table></figure>
<ul>
<li>Stream 完整实例    </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.IntSummaryStatistics;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Random;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line">import java.util.Map;</span><br><span class="line"> </span><br><span class="line">public class Java8Tester &#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      System.out.println(&quot;使用 Java 7: &quot;);</span><br><span class="line">        </span><br><span class="line">      // 计算空字符串</span><br><span class="line">      List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">      System.out.println(&quot;列表: &quot; +strings);</span><br><span class="line">      long count = getCountEmptyStringUsingJava7(strings);</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;空字符数量为: &quot; + count);</span><br><span class="line">      count = getCountLength3UsingJava7(strings);</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;字符串长度为 3 的数量为: &quot; + count);</span><br><span class="line">        </span><br><span class="line">      // 删除空字符串</span><br><span class="line">      List&lt;String&gt; filtered = deleteEmptyStringsUsingJava7(strings);</span><br><span class="line">      System.out.println(&quot;筛选后的列表: &quot; + filtered);</span><br><span class="line">        </span><br><span class="line">      // 删除空字符串，并使用逗号把它们合并起来</span><br><span class="line">      String mergedString = getMergedStringUsingJava7(strings,&quot;, &quot;);</span><br><span class="line">      System.out.println(&quot;合并字符串: &quot; + mergedString);</span><br><span class="line">      List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);</span><br><span class="line">        </span><br><span class="line">      // 获取列表元素平方数</span><br><span class="line">      List&lt;Integer&gt; squaresList = getSquares(numbers);</span><br><span class="line">      System.out.println(&quot;平方数列表: &quot; + squaresList);</span><br><span class="line">      List&lt;Integer&gt; integers = Arrays.asList(1,2,13,4,15,6,17,8,19);</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;列表: &quot; +integers);</span><br><span class="line">      System.out.println(&quot;列表中最大的数 : &quot; + getMax(integers));</span><br><span class="line">      System.out.println(&quot;列表中最小的数 : &quot; + getMin(integers));</span><br><span class="line">      System.out.println(&quot;所有数之和 : &quot; + getSum(integers));</span><br><span class="line">      System.out.println(&quot;平均数 : &quot; + getAverage(integers));</span><br><span class="line">      System.out.println(&quot;随机数: &quot;);</span><br><span class="line">        </span><br><span class="line">      // 输出10个随机数</span><br><span class="line">      Random random = new Random();</span><br><span class="line">        </span><br><span class="line">      for(int i=0; i &lt; 10; i++)&#123;</span><br><span class="line">         System.out.println(random.nextInt());</span><br><span class="line">      &#125;</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;使用 Java 8: &quot;);</span><br><span class="line">      System.out.println(&quot;列表: &quot; +strings);</span><br><span class="line">        </span><br><span class="line">      count = strings.stream().filter(string-&gt;string.isEmpty()).count();</span><br><span class="line">      System.out.println(&quot;空字符串数量为: &quot; + count);</span><br><span class="line">        </span><br><span class="line">      count = strings.stream().filter(string -&gt; string.length() == 3).count();</span><br><span class="line">      System.out.println(&quot;字符串长度为 3 的数量为: &quot; + count);</span><br><span class="line">        </span><br><span class="line">      filtered = strings.stream().filter(string -&gt;!string.isEmpty()).collect(Collectors.toList());</span><br><span class="line">      System.out.println(&quot;筛选后的列表: &quot; + filtered);</span><br><span class="line">        </span><br><span class="line">      mergedString = strings.stream().filter(string -&gt;!string.isEmpty()).collect(Collectors.joining(&quot;, &quot;));</span><br><span class="line">      System.out.println(&quot;合并字符串: &quot; + mergedString);</span><br><span class="line">        </span><br><span class="line">      squaresList = numbers.stream().map( i -&gt;i*i).distinct().collect(Collectors.toList());</span><br><span class="line">      System.out.println(&quot;Squares List: &quot; + squaresList);</span><br><span class="line">      System.out.println(&quot;列表: &quot; +integers);</span><br><span class="line">        </span><br><span class="line">      IntSummaryStatistics stats = integers.stream().mapToInt((x) -&gt;x).summaryStatistics();</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;列表中最大的数 : &quot; + stats.getMax());</span><br><span class="line">      System.out.println(&quot;列表中最小的数 : &quot; + stats.getMin());</span><br><span class="line">      System.out.println(&quot;所有数之和 : &quot; + stats.getSum());</span><br><span class="line">      System.out.println(&quot;平均数 : &quot; + stats.getAverage());</span><br><span class="line">      System.out.println(&quot;随机数: &quot;);</span><br><span class="line">        </span><br><span class="line">      random.ints().limit(10).sorted().forEach(System.out::println);</span><br><span class="line">        </span><br><span class="line">      // 并行处理</span><br><span class="line">      count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span><br><span class="line">      System.out.println(&quot;空字符串的数量为: &quot; + count);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private static int getCountEmptyStringUsingJava7(List&lt;String&gt; strings)&#123;</span><br><span class="line">      int count = 0;</span><br><span class="line">        </span><br><span class="line">      for(String string: strings)&#123;</span><br><span class="line">        </span><br><span class="line">         if(string.isEmpty())&#123;</span><br><span class="line">            count++;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return count;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private static int getCountLength3UsingJava7(List&lt;String&gt; strings)&#123;</span><br><span class="line">      int count = 0;</span><br><span class="line">        </span><br><span class="line">      for(String string: strings)&#123;</span><br><span class="line">        </span><br><span class="line">         if(string.length() == 3)&#123;</span><br><span class="line">            count++;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return count;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private static List&lt;String&gt; deleteEmptyStringsUsingJava7(List&lt;String&gt; strings)&#123;</span><br><span class="line">      List&lt;String&gt; filteredList = new ArrayList&lt;String&gt;();</span><br><span class="line">        </span><br><span class="line">      for(String string: strings)&#123;</span><br><span class="line">        </span><br><span class="line">         if(!string.isEmpty())&#123;</span><br><span class="line">             filteredList.add(string);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return filteredList;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private static String getMergedStringUsingJava7(List&lt;String&gt; strings, String separator)&#123;</span><br><span class="line">      StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">        </span><br><span class="line">      for(String string: strings)&#123;</span><br><span class="line">        </span><br><span class="line">         if(!string.isEmpty())&#123;</span><br><span class="line">            stringBuilder.append(string);</span><br><span class="line">            stringBuilder.append(separator);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      String mergedString = stringBuilder.toString();</span><br><span class="line">      return mergedString.substring(0, mergedString.length()-2);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private static List&lt;Integer&gt; getSquares(List&lt;Integer&gt; numbers)&#123;</span><br><span class="line">      List&lt;Integer&gt; squaresList = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">      for(Integer number: numbers)&#123;</span><br><span class="line">         Integer square = new Integer(number.intValue() * number.intValue());</span><br><span class="line">            </span><br><span class="line">         if(!squaresList.contains(square))&#123;</span><br><span class="line">            squaresList.add(square);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return squaresList;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private static int getMax(List&lt;Integer&gt; numbers)&#123;</span><br><span class="line">      int max = numbers.get(0);</span><br><span class="line">        </span><br><span class="line">      for(int i=1;i &lt; numbers.size();i++)&#123;</span><br><span class="line">        </span><br><span class="line">         Integer number = numbers.get(i);</span><br><span class="line">            </span><br><span class="line">         if(number.intValue() &gt; max)&#123;</span><br><span class="line">            max = number.intValue();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return max;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private static int getMin(List&lt;Integer&gt; numbers)&#123;</span><br><span class="line">      int min = numbers.get(0);</span><br><span class="line">        </span><br><span class="line">      for(int i=1;i &lt; numbers.size();i++)&#123;</span><br><span class="line">         Integer number = numbers.get(i);</span><br><span class="line">        </span><br><span class="line">         if(number.intValue() &lt; min)&#123;</span><br><span class="line">            min = number.intValue();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return min;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private static int getSum(List numbers)&#123;</span><br><span class="line">      int sum = (int)(numbers.get(0));</span><br><span class="line">        </span><br><span class="line">      for(int i=1;i &lt; numbers.size();i++)&#123;</span><br><span class="line">         sum += (int)numbers.get(i);</span><br><span class="line">      &#125;</span><br><span class="line">      return sum;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   private static int getAverage(List&lt;Integer&gt; numbers)&#123;</span><br><span class="line">      return getSum(numbers) / numbers.size();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行以上脚本，输出结果为：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">$ javac Java8Tester.java </span><br><span class="line">$ java Java8Tester</span><br><span class="line">使用 Java 7: </span><br><span class="line">列表: [abc, , bc, efg, abcd, , jkl]</span><br><span class="line">空字符数量为: 2</span><br><span class="line">字符串长度为 3 的数量为: 3</span><br><span class="line">筛选后的列表: [abc, bc, efg, abcd, jkl]</span><br><span class="line">合并字符串: abc, bc, efg, abcd, jkl</span><br><span class="line">平方数列表: [9, 4, 49, 25]</span><br><span class="line">列表: [1, 2, 13, 4, 15, 6, 17, 8, 19]</span><br><span class="line">列表中最大的数 : 19</span><br><span class="line">列表中最小的数 : 1</span><br><span class="line">所有数之和 : 85</span><br><span class="line">平均数 : 9</span><br><span class="line">随机数: </span><br><span class="line">-393170844</span><br><span class="line">-963842252</span><br><span class="line">447036679</span><br><span class="line">-1043163142</span><br><span class="line">-881079698</span><br><span class="line">221586850</span><br><span class="line">-1101570113</span><br><span class="line">576190039</span><br><span class="line">-1045184578</span><br><span class="line">1647841045</span><br><span class="line">使用 Java 8: </span><br><span class="line">列表: [abc, , bc, efg, abcd, , jkl]</span><br><span class="line">空字符串数量为: 2</span><br><span class="line">字符串长度为 3 的数量为: 3</span><br><span class="line">筛选后的列表: [abc, bc, efg, abcd, jkl]</span><br><span class="line">合并字符串: abc, bc, efg, abcd, jkl</span><br><span class="line">Squares List: [9, 4, 49, 25]</span><br><span class="line">列表: [1, 2, 13, 4, 15, 6, 17, 8, 19]</span><br><span class="line">列表中最大的数 : 19</span><br><span class="line">列表中最小的数 : 1</span><br><span class="line">所有数之和 : 85</span><br><span class="line">平均数 : 9.444444444444445</span><br><span class="line">随机数: </span><br><span class="line">-1743813696</span><br><span class="line">-1301974944</span><br><span class="line">-1299484995</span><br><span class="line">-779981186</span><br><span class="line">136544902</span><br><span class="line">555792023</span><br><span class="line">1243315896</span><br><span class="line">1264920849</span><br><span class="line">1472077135</span><br><span class="line">1706423674</span><br><span class="line">空字符串的数量为: 2</span><br></pre></td></tr></table></figure>
<h4 id="Optional-类"><a href="#Optional-类" class="headerlink" title="Optional 类"></a>Optional 类</h4><blockquote>
<p>Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。<br>Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。<br>Optional 类的引入很好的解决空指针异常。  </p>
</blockquote>
<ul>
<li>类声明   </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public final class Optional&lt;T&gt;</span><br><span class="line">extends Object</span><br></pre></td></tr></table></figure>
<ul>
<li>类方法  </li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">方法 &amp; 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">static <t> Optional<t> empty() 返回空的 Optional 实例。</t></t></td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">boolean equals(Object obj) 判断其他对象是否等于 Optional。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">Optional<t> filter(Predicate&lt;? super <t> predicate)  如果值存在，并且这个值匹配给定的 predicate，返回一个Optional用以描述这个值，否则返回一个空的Optional。</t></t></td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><u> Optional<u> flatMap(Function&lt;? super T,Optional<u>&gt; mapper) 如果值存在，返回基于Optional包含的映射方法的值，否则返回一个空的Optional</u></u></u></td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">T get() 如果在这个Optional中包含这个值，返回值，否则抛出异常：NoSuchElementException</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">int hashCode() 返回存在值的哈希码，如果值不存在 返回 0。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">void ifPresent(Consumer&lt;? super T&gt; consumer) 如果值存在则使用该值调用 consumer , 否则不做任何事情。</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">boolean isPresent() 如果值存在则方法会返回true，否则返回 false。</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left"><u>Optional<u> map(Function&lt;? super T,? extends U&gt; mapper) 如果存在该值，提供的映射方法，如果返回非null，返回一个Optional描述结果。</u></u></td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">static <t> Optional<t> of(T value) 返回一个指定非null值的Optional。</t></t></td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left">static <t> Optional<t> ofNullable(T value) 如果为非空，返回 Optional 描述的指定值，否则返回空的 Optional。</t></t></td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left">T orElse(T other) 如果存在该值，返回值， 否则返回 other。</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left">T orElseGet(Supplier&lt;? extends T&gt; other) 如果存在该值，返回值， 否则触发 other，并返回 other 调用的结果。</td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:left"><x extends="" throwable=""> T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) 如果存在该值，返回包含的值，否则抛出由 Supplier 继承的异常。</x></td>
</tr>
<tr>
<td style="text-align:left">15</td>
<td style="text-align:left">String toString()  返回一个Optional的非空字符串，用来调试</td>
</tr>
</tbody>
</table>
<p><strong>注意：</strong> 这些方法是从 java.lang.Object 类继承来的。  </p>
<ul>
<li>Optional 实例    </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Optional;</span><br><span class="line"> </span><br><span class="line">public class Java8Tester &#123;</span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">   </span><br><span class="line">      Java8Tester java8Tester = new Java8Tester();</span><br><span class="line">      Integer value1 = null;</span><br><span class="line">      Integer value2 = new Integer(10);</span><br><span class="line">        </span><br><span class="line">      // Optional.ofNullable - 允许传递为 null 参数</span><br><span class="line">      Optional&lt;Integer&gt; a = Optional.ofNullable(value1);</span><br><span class="line">        </span><br><span class="line">      // Optional.of - 如果传递的参数是 null，抛出异常 NullPointerException</span><br><span class="line">      Optional&lt;Integer&gt; b = Optional.of(value2);</span><br><span class="line">      System.out.println(java8Tester.sum(a,b));</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   public Integer sum(Optional&lt;Integer&gt; a, Optional&lt;Integer&gt; b)&#123;</span><br><span class="line">    </span><br><span class="line">      // Optional.isPresent - 判断值是否存在</span><br><span class="line">        </span><br><span class="line">      System.out.println(&quot;第一个参数值存在: &quot; + a.isPresent());</span><br><span class="line">      System.out.println(&quot;第二个参数值存在: &quot; + b.isPresent());</span><br><span class="line">        </span><br><span class="line">      // Optional.orElse - 如果值存在，返回它，否则返回默认值</span><br><span class="line">      Integer value1 = a.orElse(new Integer(0));</span><br><span class="line">        </span><br><span class="line">      //Optional.get - 获取值，值需要存在</span><br><span class="line">      Integer value2 = b.get();</span><br><span class="line">      return value1 + value2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行以上脚本，输出结果为：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一个参数值存在: false</span><br><span class="line">第二个参数值存在: true</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<h4 id="Nashorn-JavaScript"><a href="#Nashorn-JavaScript" class="headerlink" title="Nashorn JavaScript"></a>Nashorn JavaScript</h4><p>Nashorn 一个 javascript 引擎。<br>从JDK 1.8开始，Nashorn取代Rhino(JDK 1.6, JDK1.7)成为Java的嵌入式JavaScript引擎。Nashorn完全支持ECMAScript 5.1规范以及一些扩展。它使用基于JSR 292的新语言特性，其中包含在JDK 7中引入的 invokedynamic，将JavaScript编译成Java字节码。<br>与先前的Rhino实现相比，这带来了2到10倍的性能提升。  </p>
<h5 id="jjs"><a href="#jjs" class="headerlink" title="jjs"></a>jjs</h5><p>jjs是个基于Nashorn引擎的命令行工具。它接受一些JavaScript源代码为参数，并且执行这些源代码。<br>例如，我们创建一个具有如下内容的example.js文件：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;Ping Pong&apos;)</span><br></pre></td></tr></table></figure>
<p>打开控制台，输入以下命令：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jjs example.js</span><br></pre></td></tr></table></figure>
<p>以上程序输出结果为：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ping Pong!</span><br></pre></td></tr></table></figure>
<h5 id="jjs交互式编程"><a href="#jjs交互式编程" class="headerlink" title="jjs交互式编程"></a>jjs交互式编程</h5><p>打开控制台，输入以下命令：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ jjs</span><br><span class="line">jjs&gt; print(&quot;Ping, Pong!&quot;)</span><br><span class="line">Ping, Pong!</span><br><span class="line">jjs&gt; quit()</span><br><span class="line">&gt;&gt;</span><br></pre></td></tr></table></figure>
<h5 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h5><p>打开控制台，输入以下命令：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jjs -- h i j k</span><br><span class="line">jjs&gt; print(&apos;字符：&apos; + arguments.join(&quot;,&quot;))</span><br><span class="line">字符：h,i,j,k</span><br></pre></td></tr></table></figure>
<h5 id="java中调用JavaScript"><a href="#java中调用JavaScript" class="headerlink" title="java中调用JavaScript"></a>java中调用JavaScript</h5><p>使用ScriptEngineManager，JavaScript代码可以在Java中执行，实例如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Jdk8Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ScriptEngineManager scriptEngineManager = new ScriptEngineManager();</span><br><span class="line">        ScriptEngine nashorn = scriptEngineManager.getEngineByName(&quot;nashorn&quot;);</span><br><span class="line"></span><br><span class="line">        String name = &quot;Nashorn&quot;;</span><br><span class="line">        Integer result = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            nashorn.eval(&quot;print(&apos;&quot; + name + &quot;&apos;)&quot;);</span><br><span class="line">            result = (Integer) nashorn.eval(&quot;6 + 2&quot;);</span><br><span class="line">        &#125; catch (ScriptException e) &#123;</span><br><span class="line">            System.out.println(&quot;js脚本执行异常：&quot; + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行脚本输出如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Nashorn</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<h5 id="JavaScript中调用Java"><a href="#JavaScript中调用Java" class="headerlink" title="JavaScript中调用Java"></a>JavaScript中调用Java</h5><p>实例如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var BigDecimal = Java.type(&apos;java.math.BigDecimal&apos;);</span><br><span class="line"></span><br><span class="line">function calculate(amount, percentage) &#123;</span><br><span class="line">   var result = new BigDecimal(amount).multiply(</span><br><span class="line">   new BigDecimal(percentage)).divide(new BigDecimal(&quot;100&quot;), 2, BigDecimal.ROUND_HALF_EVEN);</span><br><span class="line">   return result.toPlainString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result = calculate(10086000000001,15.8);</span><br><span class="line">print(result);</span><br></pre></td></tr></table></figure>
<p>执行如上输出：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ jjs example.js</span><br><span class="line">1593588000000.16</span><br></pre></td></tr></table></figure>
<h4 id="日期时间-API"><a href="#日期时间-API" class="headerlink" title="日期时间 API"></a>日期时间 API</h4><p> Java 8通过发布新的Date-Time API (JSR 310)来进一步加强对日期与时间的处理。<br> 旧版时间API存在的问题主要有：  </p>
<ul>
<li><strong>非线程安全&gt; </strong> java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一。    </li>
<li><strong>设计很差&gt; </strong>Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计。  </li>
<li><p><strong>时区处理麻烦&gt; </strong>日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有的问题。  </p>
<p>Java8在java.time包下提供了很多新的API。以下为两个重要的比较：  </p>
</li>
<li><strong>Local(本地)&gt; </strong>简化了日期时间的处理，没有时区的问题。  </li>
<li><p><strong>Zoned(时区)&gt; </strong>通过制定的时区处理日期时间。  </p>
<p>新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。  </p>
<h5 id="本地化日期时间-API"><a href="#本地化日期时间-API" class="headerlink" title="本地化日期时间 API"></a>本地化日期时间 API</h5><p>LocalDate/LocalTime 和 LocalDateTime 类可以在处理时区不是必须的情况。代码如下：   </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class Jdk8Demo &#123;</span><br><span class="line">     public static void main(String args[])&#123;</span><br><span class="line">         Jdk8Demo jdk8Demo = new Jdk8Demo();</span><br><span class="line">         jdk8Demo.testLocalDateTime();</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     public void testLocalDateTime()&#123;</span><br><span class="line"> </span><br><span class="line">         // 获取当前的日期时间</span><br><span class="line">         LocalDateTime currentTime = LocalDateTime.now();</span><br><span class="line">         System.out.println(&quot;当前时间: &quot; + currentTime);</span><br><span class="line"> </span><br><span class="line">         LocalDate date1 = currentTime.toLocalDate();</span><br><span class="line">         System.out.println(&quot;当前日期: &quot; + date1);</span><br><span class="line"> </span><br><span class="line">         Month month = currentTime.getMonth();</span><br><span class="line">         int day = currentTime.getDayOfMonth();</span><br><span class="line">         int seconds = currentTime.getSecond();</span><br><span class="line"> </span><br><span class="line">         System.out.println(&quot;月: &quot; + month.getValue() +&quot;, 日: &quot; + day +&quot;, 秒: &quot; + seconds);</span><br><span class="line"> </span><br><span class="line">         //修改当前时间 设置年月日</span><br><span class="line">         LocalDateTime date2 = currentTime.withDayOfMonth(10).withYear(2012).withMonth(10);</span><br><span class="line">         System.out.println(&quot;当前时间设置后: &quot; + date2);</span><br><span class="line"> </span><br><span class="line">         // 修改当前时间 设置年月日</span><br><span class="line">         LocalDate date3 = LocalDate.of(2014, Month.DECEMBER, 12);</span><br><span class="line">         System.out.println(&quot;当前时间设置后1: &quot; + date3);</span><br><span class="line"> </span><br><span class="line">         // 修改当前时间 设置时分</span><br><span class="line">         LocalTime date4 = LocalTime.of(22, 15);</span><br><span class="line">         System.out.println(&quot;当前时间设置后2: &quot; + date4);</span><br><span class="line"> </span><br><span class="line">         // 解析字符串</span><br><span class="line">         LocalTime date5 = LocalTime.parse(&quot;20:15:30&quot;);</span><br><span class="line">         System.out.println(&quot;解析字符时间为日期对象: &quot; + date5);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>以上执行输出：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当前时间: 2018-09-27T16:22:35.565</span><br><span class="line">当前日期: 2018-09-27</span><br><span class="line">月: 9, 日: 27, 秒: 35</span><br><span class="line">当前时间设置后: 2012-10-10T16:22:35.565</span><br><span class="line">当前时间设置后1: 2014-12-12</span><br><span class="line">当前时间设置后2: 22:15</span><br><span class="line">解析字符时间为日期对象: 20:15:30</span><br></pre></td></tr></table></figure>
<h5 id="使用时区的日期时间API"><a href="#使用时区的日期时间API" class="headerlink" title="使用时区的日期时间API"></a>使用时区的日期时间API</h5><p>如果我们需要考虑到时区，就可以使用时区的日期时间API：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Jdk8Demo &#123;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        Jdk8Demo jdk8Demo = new Jdk8Demo();</span><br><span class="line">        jdk8Demo.testZonedDateTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void testZonedDateTime()&#123;</span><br><span class="line"></span><br><span class="line">        // 解析字符串时间</span><br><span class="line">        ZonedDateTime date1 = ZonedDateTime.parse(&quot;2015-12-03T10:15:30+05:30[Asia/Shanghai]&quot;);</span><br><span class="line">        System.out.println(&quot;解析字符串时间: &quot; + date1);</span><br><span class="line"></span><br><span class="line">        //设置zoneid</span><br><span class="line">        ZoneId id = ZoneId.of(&quot;Europe/Paris&quot;);</span><br><span class="line">        System.out.println(&quot;输出zoneid: &quot; + id);</span><br><span class="line"></span><br><span class="line">        ZoneId currentZone = ZoneId.systemDefault();</span><br><span class="line">        System.out.println(&quot;默认当期时区: &quot; + currentZone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上执行输出：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解析字符串时间: 2015-12-03T10:15:30+08:00[Asia/Shanghai]</span><br><span class="line">输出zoneid: Europe/Paris</span><br><span class="line">默认当期时区: Asia/Shanghai</span><br></pre></td></tr></table></figure>
<h4 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h4><p>在Java8中，Base64编码已经成为Java类库的标准。<br>Java8内置了Base64编码的编码器和解码器。<br>Base64工具类提供了一套静态方法获取下面三种BASE64编解码器：  </p>
<ul>
<li><strong>基本：</strong> 输出被映射到一组字符A-Za-z0-9+/，编码不添加任何行标，输出的解码仅支持A-Za-z0-9+/  </li>
<li><strong>URL：</strong> 输出映射到一组字符A-Za-z0-9+_，输出是URL和文件。  </li>
<li><strong>MIME：</strong> 输出映射到MIME友好格式。输出每行不超过76字符，并且使用’\r’并跟随’\n’作为分割。编码输出最后没有行分割。  </li>
</ul>
<h5 id="内嵌类"><a href="#内嵌类" class="headerlink" title="内嵌类"></a>内嵌类</h5><table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">内嵌类 &amp; 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">static class Base64.Decoder 该类实现一个解码器用于，使用 Base64 编码来解码字节数据。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">static class Base64.Encoder 该类实现一个编码器，使用 Base64 编码来编码字节数据。</td>
</tr>
</tbody>
</table>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">方法 &amp; 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">static Base64.Decoder getDecoder() 返回一个 Base64.Decoder ，解码使用基本型 base64 编码方案。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">static Base64.Encoder getEncoder() 返回一个 Base64.Encoder ，编码使用基本型 base64 编码方案。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">static Base64.Decoder getMimeDecoder() 返回一个 Base64.Decoder ，解码使用 MIME 型 base64 编码方案。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">static Base64.Encoder getMimeEncoder() 返回一个 Base64.Encoder ，编码使用 MIME 型 base64 编码方案。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">static Base64.Encoder getMimeEncoder(int lineLength, byte[] lineSeparator) 返回一个 Base64.Encoder ，编码使用 MIME 型 base64 编码方案，可以通过参数指定每行的长度及行的分隔符。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">static Base64.Decoder getUrlDecoder() 返回一个 Base64.Decoder ，解码使用 URL 和文件名安全型 base64 编码方案。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">static Base64.Encoder getUrlEncoder() 返回一个 Base64.Encoder ，编码使用 URL 和文件名安全型 base64 编码方案。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意：Base64 类的很多方法从 java.lang.Object 类继承。  </p>
</blockquote>
<h5 id="Base64-实例"><a href="#Base64-实例" class="headerlink" title="Base64 实例"></a>Base64 实例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Jdk8Demo &#123;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Jdk8Demo jdk8Demo = new Jdk8Demo();</span><br><span class="line">        jdk8Demo.testBase64();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void testBase64() &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">            // 基本编码</span><br><span class="line">            String base64encodedString = Base64.getEncoder().encodeToString(&quot;this 是 java8&quot;.getBytes(&quot;utf-8&quot;));</span><br><span class="line">            System.out.println(&quot;Base64字符串 (基本) :&quot; + base64encodedString);</span><br><span class="line"></span><br><span class="line">            // 解码</span><br><span class="line">            byte[] base64decodedBytes = Base64.getDecoder().decode(base64encodedString);</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;原始字符串: &quot; + new String(base64decodedBytes, &quot;utf-8&quot;));</span><br><span class="line">            base64encodedString = Base64.getUrlEncoder().encodeToString(&quot;url编码 &quot;.getBytes(&quot;utf-8&quot;));</span><br><span class="line">            System.out.println(&quot;Base64 编码字符串 (URL) :&quot; + base64encodedString);</span><br><span class="line"></span><br><span class="line">            StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">                stringBuilder.append(UUID.randomUUID().toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            byte[] mimeBytes = stringBuilder.toString().getBytes(&quot;utf-8&quot;);</span><br><span class="line">            String mimeEncodedString = Base64.getMimeEncoder().encodeToString(mimeBytes);</span><br><span class="line">            System.out.println(&quot;Base64 编码字符串 (MIME) :&quot; + mimeEncodedString);</span><br><span class="line"></span><br><span class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">            System.out.println(&quot;Error :&quot; + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Base64字符串 (基本) :dGhpcyDmmK8gamF2YTg=</span><br><span class="line">原始字符串: this 是 java8</span><br><span class="line">Base64 编码字符串 (URL) :dXJs57yW56CBIA==</span><br><span class="line">Base64 编码字符串 (MIME) :YTgxZDgxOTAtZTM3ZS00ODQ1LTk0YjEtOGI4MWViY2VlNmZmZmFhNTdiMTItZTI0NS00ZTJhLWIx</span><br><span class="line">OTQtNGQ4OTFmNTc4MjFiNmU1MGZlNjYtYzhmZS00OWIzLWIzMzItNzA4YWU0NTdhNDQ2MGZjNDg2</span><br><span class="line">NzYtNjc2ZS00M2Y0LWIwNjgtYWQ1ZTA5NTYzNWVlNjZmNTRkZjgtNDljNi00MmVlLTllMjUtZjRl</span><br><span class="line">ZjM3ZjQ3NDk0YjAwMjJhOGYtYjJkMC00MzNhLWEyNDktZGFhNTFiMzMwMTAyYWY1OGEwZmMtZDQ5</span><br><span class="line">MC00ZjUyLWFlYzYtNzk2OTNkZDUwMWEzYzk3OTI2NDUtN2Q5Ni00ZTEzLWFiZWUtNzFlNDMxNTY3</span><br><span class="line">Nzg2YjE2NTU3OTAtMGViOS00YmM4LTg1NjAtYzcxMmNmMDk0NTgxNjdiN2JkMzUtNDVjZS00MjZk</span><br><span class="line">LTgzZTktNmQ3ZGM5YzQ1Njk1</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      
      
      
      
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jdk/">jdk</a></li></ul>

      

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->


  
    <article id="post-jdk新特性之jdk7"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/09/26/jdk新特性之jdk7/">jdk新特性之jdk7</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/09/26/jdk新特性之jdk7/" class="article-date">
	  <time datetime="2018-09-26T09:07:00.000Z" itemprop="datePublished">2018-09-26</time>
	</a>

      
    <a class="article-category-link" href="/categories/java/">java</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>jdk7新特性主要有switch中可以使用字串、泛型实例化类型自动推断、资源自动关闭、新增一些取环境信息的工具方法、Boolean类型反转，空指针安全，参与位运算、字符之间可以使用equals、安全的加减乘除、对Java集合（Collections）的增强支持、数值文本、支持二进制文字、在try catch异常扑捉中，一个catch可以写多个异常类型，用”|”隔开。<br><a id="more"></a>  </p>
<h4 id="jdk7新特性"><a href="#jdk7新特性" class="headerlink" title="jdk7新特性"></a>jdk7新特性</h4><hr>
<h5 id="switch中可以使用字串"><a href="#switch中可以使用字串" class="headerlink" title="switch中可以使用字串"></a>switch中可以使用字串</h5> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;a&quot;;</span><br><span class="line">switch (s) &#123;</span><br><span class="line">case &quot;a&quot; :</span><br><span class="line">System.out.println(&quot;a&quot;);</span><br><span class="line">break;</span><br><span class="line">case &quot;b&quot; :</span><br><span class="line">System.out.println(&quot;b&quot;);</span><br><span class="line">break;</span><br><span class="line">default :</span><br><span class="line">System.out.println(&quot;default&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="泛型实例化类型自动推断"><a href="#泛型实例化类型自动推断" class="headerlink" title="泛型实例化类型自动推断"></a>泛型实例化类型自动推断</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// java 7前，前后&lt;&gt;都必须声明类型</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">//java 7 &lt;&gt;不须声明类型，自动根据前面&lt;&gt;推断其类型</span><br><span class="line">List&lt;String&gt; list1 = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h5 id="资源自动关闭"><a href="#资源自动关闭" class="headerlink" title="资源自动关闭"></a>资源自动关闭</h5><p>在Java中，有许多的资源在使用完成之后需要对其进行关闭操作。举个栗子，InputStream，Writer，Sockets，Connection等等。在Java 7 之前通常都是显示调用其close()方法，在Java 7，你可以不用理会其是否未关闭，我们可以使用try-with-resources代码块。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceCloseTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * java 7以前版本，关闭资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">oldCloseResource</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(path));</span><br><span class="line">            <span class="keyword">return</span> br.readLine();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"BufferedReader Exception"</span> + e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (br != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                    <span class="comment">//br.ready();//资源关闭后，访问资源抛出异常</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.err.println(<span class="string">"BufferedReader close Exception"</span> + e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * java 7版本关闭资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">newCloseResource</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 当try语句块运行结束时，FileInputStream 会被自动关闭。这是因为FileInputStream 实现了java中的java.lang.AutoCloseable接口。</span></span><br><span class="line"><span class="comment">         * 所有实现了这个接口的类都可以在try-with-resources结构中使用。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(path))) &#123;<span class="comment">//try()中可以定义多个资源</span></span><br><span class="line">            <span class="keyword">return</span> br.readLine();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"BufferedReader Exception"</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        oldCloseResource(<span class="string">"C:\\Users\\alvin\\Desktop\\a.txt"</span>);</span><br><span class="line">        newCloseResource(<span class="string">"C:\\Users\\alvin\\Desktop\\a.txt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="新增一些取环境信息的工具方法"><a href="#新增一些取环境信息的工具方法" class="headerlink" title="新增一些取环境信息的工具方法"></a>新增一些取环境信息的工具方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">File System.getUserHomeDir() // 当前用户目录</span><br><span class="line">File System.getUserDir() // 启动java进程时所在的目录</span><br><span class="line">File System.getJavaIoTempDir() // io临时文件夹</span><br><span class="line">File System.getJavaHomeDir() // jre的安装目录</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>
<h5 id="Boolean类型反转，空指针安全，参与位运算"><a href="#Boolean类型反转，空指针安全，参与位运算" class="headerlink" title="Boolean类型反转，空指针安全，参与位运算"></a>Boolean类型反转，空指针安全，参与位运算</h5><p>在java8中找不到Booleans这个类，是废弃了吗？  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Boolean Booleans.negate(Boolean booleanObj)</span><br><span class="line">True =&gt; False , False =&gt; True, Null =&gt; Null</span><br><span class="line">boolean Booleans.and(boolean[] array)</span><br><span class="line">boolean Booleans.or(boolean[] array)</span><br><span class="line">boolean Booleans.xor(boolean[] array)</span><br><span class="line">boolean Booleans.and(Boolean[] array)</span><br><span class="line">boolean Booleans.or(Boolean[] array)</span><br><span class="line">boolean Booleans.xor(Boolean[] array)</span><br></pre></td></tr></table></figure>
<h5 id="字符之间可以使用equals"><a href="#字符之间可以使用equals" class="headerlink" title="字符之间可以使用equals"></a>字符之间可以使用equals</h5><p>在java8中不管用呢，是废弃了吗？   </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean Character.equalsIgnoreCase(char ch1, char ch2)</span><br></pre></td></tr></table></figure>
<h5 id="安全的加减乘除"><a href="#安全的加减乘除" class="headerlink" title="安全的加减乘除"></a>安全的加减乘除</h5><p>在java8中不管用呢，是废弃了吗？  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int Math.safeToInt(long value)</span><br><span class="line">int Math.safeNegate(int value)</span><br><span class="line">long Math.safeSubtract(long value1, int value2)</span><br><span class="line">long Math.safeSubtract(long value1, long value2)</span><br><span class="line">int Math.safeMultiply(int value1, int value2)</span><br><span class="line">long Math.safeMultiply(long value1, int value2)</span><br><span class="line">long Math.safeMultiply(long value1, long value2)</span><br><span class="line">long Math.safeNegate(long value)</span><br><span class="line">int Math.safeAdd(int value1, int value2)</span><br><span class="line">long Math.safeAdd(long value1, int value2)</span><br><span class="line">long Math.safeAdd(long value1, long value2)</span><br><span class="line">int Math.safeSubtract(int value1, int value2)</span><br></pre></td></tr></table></figure>
<h5 id="对Java集合（Collections）的增强支持"><a href="#对Java集合（Collections）的增强支持" class="headerlink" title="对Java集合（Collections）的增强支持"></a>对Java集合（Collections）的增强支持</h5><p>jdk7以前：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//创建List接口对象</span><br><span class="line">List&lt;String&gt; list=new ArrayList&lt;String&gt;();</span><br><span class="line">list.add(&quot;item1&quot;); //用add()方法获取对象</span><br><span class="line">String Item=list.get(0); //用get()方法获取对象</span><br><span class="line"></span><br><span class="line">//创建Set接口对象</span><br><span class="line">Set&lt;String&gt; set=new HashSet&lt;String&gt;();</span><br><span class="line">set.add(&quot;item1&quot;); //用add()方法添加对象</span><br><span class="line"></span><br><span class="line">//创建Map接口对象</span><br><span class="line">Map&lt;String,String&gt; map=new HashMap&lt;String,String&gt;();</span><br><span class="line">map.put(&quot;key1&quot;, &quot;value1&quot;); //用put()方法添加对象</span><br><span class="line">String value=map.get(&quot;key1&quot;);</span><br></pre></td></tr></table></figure>
<p>jdk7：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list=[&quot;item1&quot;]; //向List集合中添加元素</span><br><span class="line">String item=list[0]; //从List集合中获取元素</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; set=&#123;&quot;item1&quot;&#125;; //向Set集合对象中添加元素</span><br><span class="line">Map&lt;String,String&gt; map=&#123;&quot;key1&quot;:&quot;value1&quot;&#125;; //向Map集合中添加对象</span><br><span class="line">String value=map[&quot;key1&quot;]; //从Map集合中获取对象</span><br></pre></td></tr></table></figure>
<p>but：在java8不管用呢。。。  </p>
<h5 id="数值文本"><a href="#数值文本" class="headerlink" title="数值文本"></a>数值文本</h5><p>未方便数0。。。，支持下划线划分。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如：int twoMillion = 2_000_000;</span><br><span class="line">或  </span><br><span class="line">int twoMillion = 200_0000;</span><br></pre></td></tr></table></figure></p>
<h5 id="支持二进制文字"><a href="#支持二进制文字" class="headerlink" title="支持二进制文字"></a>支持二进制文字</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例如：int binary = 0b1001_1001;</span><br><span class="line">//下划线可以划在ob1之后到0b10011001之前任何位置</span><br></pre></td></tr></table></figure>
<h5 id="在try-catch异常扑捉中，一个catch可以写多个异常类型，用”-”隔开"><a href="#在try-catch异常扑捉中，一个catch可以写多个异常类型，用”-”隔开" class="headerlink" title="在try catch异常扑捉中，一个catch可以写多个异常类型，用”|”隔开"></a>在try catch异常扑捉中，一个catch可以写多个异常类型，用”|”隔开</h5><p>jdk7之前：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   ......</span><br><span class="line">&#125; <span class="keyword">catch</span>(ClassNotFoundException ex) &#123;</span><br><span class="line">   ex.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span>(SQLException ex) &#123;</span><br><span class="line">   ex.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>jdk7：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   ......</span><br><span class="line">&#125; <span class="keyword">catch</span>(ClassNotFoundException|SQLException ex) &#123;</span><br><span class="line">   ex.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      
      
      
      
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jdk/">jdk</a></li></ul>

      

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->


  
    <article id="post-jdk新特性之jdk6"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/09/26/jdk新特性之jdk6/">jdk新特性之jdk6</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/09/26/jdk新特性之jdk6/" class="article-date">
	  <time datetime="2018-09-26T08:53:00.000Z" itemprop="datePublished">2018-09-26</time>
	</a>

      
    <a class="article-category-link" href="/categories/java/">java</a>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>jdk6新特性主要体现在如下模块：Desktop类和SystemTray类、使用JAXB2来实现对象与XML之间的映射、StAX、使用Compiler API、轻量级Http Server API、插入式注解处理API(Pluggable Annotation Processing API)、用Console开发控制台程序、对脚本语言的支持、Common Annotations及其它一些小改动。<br><a id="more"></a>  </p>
<h4 id="jdk6新特性"><a href="#jdk6新特性" class="headerlink" title="jdk6新特性"></a>jdk6新特性</h4><hr>
<h5 id="Desktop类和SystemTray类"><a href="#Desktop类和SystemTray类" class="headerlink" title="Desktop类和SystemTray类"></a>Desktop类和SystemTray类</h5><p>AWT新增加了两个类：Desktop和SystemTray<br>Desktop可以用来打开系统默认浏览器浏览指定的URL，打开系统默认邮件客户端给指定的邮箱发邮件，用默认应用程序打开或编辑文件，<br>用系统默认的打印机打印文档。<br>SystemTray可以在系统托盘区创建一个托盘程序。  </p>
<h5 id="使用JAXB2来实现对象与XML之间的映射"><a href="#使用JAXB2来实现对象与XML之间的映射" class="headerlink" title="使用JAXB2来实现对象与XML之间的映射"></a>使用JAXB2来实现对象与XML之间的映射</h5><p>JAXB是Java Architecture for XML Binding的缩写，可以将一个Java对象转变成为XML格式，反之亦然。<br>我们把对象与关系数据库之间的映射称为ORM，其实也可以把对象与XML之间的映射称为OXM（Object XML Mapping）。原来JAXB是Java EE<br>的一部分，在JDK1.6中，SUN将其放到了Java SE中，这也是SUN的一贯做法。JDK1.6中自带的这个JAXB版本是2.0，比起1.0来，JAXB2用JDK5<br>的新特性Annotation来标识要作绑定的类和属性，这就极大简化了开发的工作量。<br>实际上，在Java EE 5.0中，EJB和Web Services也通过Annotation来简化开发工作。另外，JAXB2在底层是用StAX(JSR 173)来处理XML文档。<br>除了JAXB之外，我们还可以通过XMLBeans和Castor等来实现同样的功能。  </p>
<h5 id="StAX"><a href="#StAX" class="headerlink" title="StAX"></a>StAX</h5><p>StAX(JSR 173)是JDK1.6.0中除了DOM和SAX之外的又一种处理XML文档的API。<br>StAX 的来历：在JAXP1.3(JSR 206)有两种处理XML文档的方法：DOM(Document Object Model)和SAX(Simple API for XML)。<br>由于JDK1.6.0中的JAXB2(JSR 222)和JAX-WS 2.0(JSR 224)都会用到StAX所以Sun决定把StAX加入到JAXP家族当中来，并将JAXP的版本升级到1.4(JAXP1.4是JAXP1.3的维护版本)。JDK1.6里面JAXP的版本就是1.4。<br>StAX是The Streaming API for XML的缩写，一种利用拉模式解析(pull-parsing)XML文档的API。StAX通过提供一种基于事件迭代器(Iterator)的API让程序员去控制xml文档解析过程，程序遍历这个事件迭代器去处理每一个解析事件，解析事件可以看做是程序拉出来的，也就是程序促使解析器产生一个解析事件然后处理该事件，之后又促使解析器产生下一个解析事件，如此循环直到碰到文档结束符；<br>SAX也是基于事件处理xml文档，但却是用推模式解析，解析器解析完整个xml文档后，才产生解析事件，然后推给程序去处理这些事件；DOM采用的方式是将整个xml文档映射到一颗内存树，这样就可以很容易地得到父节点和子结点以及兄弟节点的数据，但如果文档很大，将会严重影响性能。  </p>
<h5 id="使用Compiler-API"><a href="#使用Compiler-API" class="headerlink" title="使用Compiler API"></a>使用Compiler API</h5><p>现在我 们可以用JDK1.6 的Compiler API(JSR 199)去动态编译Java源文件，Compiler API结合反射功能就可以实现动态的产生Java代码并编译执行这些代码，有点动态语言的特征。<br>这个特性对于某些需要用到动态编译的应用程序相当有用，比如JSP Web Server，当我们手动修改JSP后，是不希望需要重启Web Server才可以看到效果的，这时候我们就可以用Compiler API来实现动态编译JSP文件，当然，现在的JSP Web Server也是支持JSP热部署的，现在的JSP Web Server通过在运行期间通过Runtime.exec或ProcessBuilder来调用javac来编译代码，这种方式需要我们产生另一个进程去做编译工作，不够优雅而且容易使代码依赖与特定的操作系统；Compiler API通过一套易用的标准的API提供了更加丰富的方式去做动态编译，而且是跨平台的。  </p>
<h5 id="轻量级Http-Server-API"><a href="#轻量级Http-Server-API" class="headerlink" title="轻量级Http Server API"></a>轻量级Http Server API</h5><p>JDK1.6 提供了一个简单的Http Server API，据此我们可以构建自己的嵌入式Http Server，它支持Http和Https协议，提供了HTTP1.1的部分实现，没有被实现的那部分可以通过扩展已有的Http Server API来实现，程序员必须自己实现HttpHandler接口，HttpServer会调用HttpHandler实现类的回调方法来处理客户端请求，在这里，我们把一个Http请求和它的响应称为一个交换，包装成HttpExchange类，HttpServer负责将HttpExchange传给HttpHandler实现类的回调方法。  </p>
<h5 id="插入式注解处理API-Pluggable-Annotation-Processing-API"><a href="#插入式注解处理API-Pluggable-Annotation-Processing-API" class="headerlink" title="插入式注解处理API(Pluggable Annotation Processing API)"></a>插入式注解处理API(Pluggable Annotation Processing API)</h5><p>插入式注解处理API(JSR 269)提供一套标准API来处理Annotations(JSR 175)。<br>实际上JSR 269不仅仅用来处理Annotation，我觉得更强大的功能是它建立了Java语言本身的一个模型，它把method，package，constructor，type，variable， enum，annotation等Java语言元素映射为Types和Elements(两者有什么区别?)，从而将Java语言的语义映射成为对象，我们可以在javax.lang.model包下面可以看到这些类。 所以我们可以利用JSR 269提供的API来构建一个功能丰富的元编程(metaprogramming)环境。<br>JSR 269用Annotation Processor在编译期间而不是运行期间处理Annotation，Annotation Processor相当于编译器的一个插件，所以称为插入式注解处理.如果Annotation Processor处理Annotation时(执行process方法)产生了新的Java代码，编译器会再调用一次Annotation Processor，如果第二次处理还有新代码产生，就会接着调用Annotation Processor，直到没有新代码产生为止.每执行一次process()方法被称为一个”round”，这样整个Annotation processing过程可以看作是一个round的序列。<br>JSR 269主要被设计成为针对Tools或者容器的API. 举个例子，我们想建立一套基于Annotation的单元测试框架(如TestNG)，在测试类里面用Annotation来标识测试期间需要执行的测试方法。  </p>
<h5 id="用Console开发控制台程序"><a href="#用Console开发控制台程序" class="headerlink" title="用Console开发控制台程序"></a>用Console开发控制台程序</h5><p>JDK1.6中提供了java.io.Console 类专用来访问基于字符的控制台设备。你的程序如果要与Windows下的cmd或者Linux下的Terminal交互，就可以用Console类代劳。但我们不总是能得到可用的Console，一个JVM是否有可用的Console依赖于底层平台和JVM如何被调用。如果JVM是在交互式命令行(比如Windows的cmd)中启动的，并且输入输出没有重定向到另外的地方，那么就可以得到一个可用的Console实例。  </p>
<h5 id="对脚本语言的支持"><a href="#对脚本语言的支持" class="headerlink" title="对脚本语言的支持"></a>对脚本语言的支持</h5><p>如：ruby，groovy，javascript。  </p>
<h5 id="Common-Annotations"><a href="#Common-Annotations" class="headerlink" title="Common Annotations"></a>Common Annotations</h5><p>Common annotations原本是Java EE 5.0(JSR 244)规范的一部分，现在SUN把它的一部分放到了Java SE 6.0中。<br>随着Annotation元数据功能(JSR 175)加入到Java SE 5.0里面，很多Java 技术(比如EJB，Web Services)都会用Annotation部分代替XML文件来配置运行参数（或者说是支持声明式编程,如EJB的声明式事务），如果这些技术为通用目的都单独定义了自己的Annotations,显然有点重复建设, 所以,为其他相关的Java技术定义一套公共的Annotation是有价值的，可以避免重复建设的同时，也保证Java SE和Java EE 各种技术的一致性。  </p>
<h5 id="有一些小的改动"><a href="#有一些小的改动" class="headerlink" title="有一些小的改动"></a>有一些小的改动</h5><p><strong>如下方法获取磁盘使用信息：</strong><br>getTotalSpace() - 返回此抽象路径名指定的分区大小。以字节为单位。  getFreeSpace() - 返回此抽象路径名指定的分区中未分配的字节数。<br>getUsableSpace() - 返回此抽象路径名指定的分区上可用于此虚拟机的字节数。若有可能，此方法将检查写权限和其他操作系统限制，因此与 getFreeSpace() 相比，此方法能更准确地估计可实际写入的新数据数。 </p>
<p><strong>如下方法获取文件权限：</strong><br>setWritable(boolean writable, boolean ownerOnly) 和 setWritable(boolean writable) - 设置此抽象路径名的所有者或所有用户的写权限。<br>setReadable(boolean readable, boolean ownerOnly) 和 setReadable(boolean readable) - 设置此抽象路径名的所有者或所有用户的读权限。<br>setExecutable(boolean executable, boolean ownerOnly) 和 setExecutable(boolean executable) - 设置此抽象路径名的所有者或所有用户的执行权限。<br>canExecute() - 测试应用程序是否可以执行此抽象路径名表示的文件。 </p>
<p><strong>IOException类增加构造函数</strong><br>IOException支持异常链通过新的构造函数：IOException(String, Throwable) 和IOException(Throwable)。<br>File.isFile()方法的行为发生变化。<br>Windows环境下对保留设备名如： CON, NUL, AUX, LPT, 等等，永远返回false。  </p>
<p><strong>java GUI界面的显示的改动</strong><br>JDK6.0（也就是JDK1.6）支持最新的windows vista系统的Windows Aero视窗效果，而JDK1.5不支持。<br>你要在vista环境下编程的话最好装jdk6.0，否则它总是换到windows basic视窗效果。  </p>
<p><strong>java.nio模块，增加java.nio.channels.SelectorProvider实现类等</strong></p>

      
    </div>
    <footer class="article-footer">
      
      
      
      
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jdk/">jdk</a></li></ul>

      

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->


  
    <article id="post-java编程思想-21"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/09/26/java编程思想-21/">java编程思想[21]-并发</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/09/26/java编程思想-21/" class="article-date">
	  <time datetime="2018-09-26T05:23:00.000Z" itemprop="datePublished">2018-09-26</time>
	</a>

      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>并发老生常谈，确实也是java中十分重要的模块，该部分重点讲解并发相关的零碎知识点。<br><a id="more"></a>   </p>
<h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><hr>
<h5 id="并发的多面性"><a href="#并发的多面性" class="headerlink" title="并发的多面性"></a>并发的多面性</h5><p>用并发解决的问题大体上可以分为速度和设计可管理性两种。  </p>
<ul>
<li>更快的执行<br>为了程序运行的更快，并发充分利用这些额外的处理器。<br>单核处理器上并发带来的开销比顺序执行大，因为其中增加了大量的上下文切换。但在单核上使用并发可以防止程序停止，即使一个任务阻塞了，其它任务可以继续执行。  </li>
<li>改进代码设计<br>单核机器通过并发可以仿真，仿真目标一般都是多任务的，每个线程处理单独的任务。  </li>
</ul>
<h5 id="基本的线程机制"><a href="#基本的线程机制" class="headerlink" title="基本的线程机制"></a>基本的线程机制</h5><p>并发编程使我们可以将程序划分为多个分离的、独立运行的任务。通过使用多线程机制，这些独立任务中的每一个都将由执行线程来驱动。  </p>
<ul>
<li>定义任务<br>实现Runnable接口，实现方法run。<br>在main方法中直接调用run方法，是顺序执行，并不会启动一个新的线程处理。  </li>
<li>Thread类<br>将Runnable对象转变为工作任务的传统方式是把它提交给一个Thread构造器。  </li>
<li>使用Executor  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">for()&#123;</span><br><span class="line">   exec.execute(实现Runnable的对象实例);</span><br><span class="line">&#125;</span><br><span class="line">exec.shutdown();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以将上面的CachedThreadPool替换为不同类型的Executor。FixedThreadPool使用了有限的线程集来执行所提交的任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService exec = Executor.newFixedThreadPool(5);</span><br><span class="line">for()&#123;</span><br><span class="line">    exec.execute(实现Runnable的对象实例);</span><br><span class="line">&#125;</span><br><span class="line">exec.shutdown();</span><br></pre></td></tr></table></figure></p>
<p>SingleThreadExecutor就像是线程数量为1的FixedTreadPool。这对于希望在另一个线程中连续运行的事物来说，都是很有用的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService exec = Executor.SingleThreadExecutor();</span><br><span class="line">for()&#123;</span><br><span class="line">    exec.execute(实现Runnable的对象实例);</span><br><span class="line">&#125;</span><br><span class="line">exec.shutdown();</span><br></pre></td></tr></table></figure></p>
<ul>
<li>从任务中产生返回值<br>Runnable独立执行任务，不返回值。Callable是一种具有类型参数的泛型，它的类型参数表示的是从call()方法返回的值，并且必须使用ExecutorService.submit()方法调用它。如下： </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class TaskWithResult implements Callable&lt;String&gt; &#123;</span><br><span class="line">    private int id;</span><br><span class="line"></span><br><span class="line">    public TaskWithResult(int id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        return &quot;result of TaskWithResult &quot; + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CallableDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        ArrayList&lt;Future&lt;String&gt;&gt; results = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            results.add(exec.submit(new TaskWithResult(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        for (Future&lt;String&gt; fs : results) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(fs.get());</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">                return;</span><br><span class="line">            &#125; catch (ExecutionException e) &#123;</span><br><span class="line">                System.out.println(e);</span><br><span class="line">            &#125;finally &#123;</span><br><span class="line">                exec.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>休眠<br>sleep(long)将使任务中止执行指定时间。  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  TimeUnit.MILLISECONDS.sleep(100);</span><br><span class="line">&#125; catch (InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>优先级<br>线程的优先级将该线程的重要性传递给了调度器。优先级较低的线程仅仅是执行的频率较低。<br>设置线程的优先级通过setPriority()方法进行设置。  </p>
</li>
<li><p>后台线程即守护线程<br>当所有非后台线程结束时，程序也就终止了，同时会杀死进程中所有的后台线程。<br>只要有任何非后台线程还在执行，程序就不好终止。<br>通过setDeamon()方法设置为后台线程。</p>
</li>
<li><p>让步<br>调用yield()时，你也是在建议具有相同优先级的其他线程可以运行。</p>
</li>
<li><p>编码的变体<br>通过继承Thread创建线程类。通过构造器设置线程名。</p>
</li>
<li><p>术语<br>任务和线程并不等价。在描述将要执行的任务时使用术语”任务”，只有在引用到驱动任务的具体机制时，才使用线程。只在概念<br>级别上讨论系统，就可以只使用任务，而不需要提及驱动机制。</p>
</li>
<li><p>加入一个线程<br>一个线程可以在其他线程之上调用join()方法，其效果是等待一段时间直到第二个线程结束才继续执行。如果某个线程在另一个线程t上调用<br>t.join()，此线程将被挂起，直到目标t结束才恢复（即t.isAlive()返回为false）。<br>也可以在调用join()时带上一个超时参数，如果目标线程在这段时间到期时还没有结束，join()总能返回。<br>对join()对方法调用可以被中断，做法是在调用线程上调用interrupt()方法，这时需要用到try-catch字句。  </p>
</li>
<li><p>线程组<br>线程组持有一个线程集合。可以把线程组看成是一次不成功的尝试，忽略就好。  </p>
</li>
<li><p>捕获异常<br>由于线程的本质特性，使得你不能捕获从线程中逃逸的异常。一旦异常逃出任务的run()方法，它就会向外传播到控制台。可以用Executor来解决这个问题。<br>通过在每个Thread对象上都附着一个异常处理器。Thread.UncaughtExceptionHandler.uncaughtException()会在线程因未捕获的异常而临近死亡时被调用。创建一个新类型的ThreadFactory，<br>它将在每个新创建的Thread对象上附着一个Thread.UncaughtExceptionHandler。  </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class ExceptionThread2 implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        System.out.println(&quot;run() by &quot; + t);</span><br><span class="line">        System.out.println(&quot;eh = &quot; + t.getUncaughtExceptionHandler());</span><br><span class="line">        throw new RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void uncaughtException(Thread t, Throwable e) &#123;</span><br><span class="line">        System.out.println(&quot;caught &quot; + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HandlerThreadFactory implements ThreadFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Thread newThread(Runnable r) &#123;</span><br><span class="line">        System.out.println(this + &quot;creating new Thread&quot;);</span><br><span class="line">        Thread t = new Thread(r);</span><br><span class="line">        System.out.println(&quot;created &quot; + t);</span><br><span class="line">        t.setUncaughtExceptionHandler(new MyUncaughtExceptionHandler());</span><br><span class="line">        System.out.println(&quot;eh = &quot; + t.getUncaughtExceptionHandler());</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CaptureUncaughtException &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool(new HandlerThreadFactory());</span><br><span class="line">        exec.execute(new ExceptionThread2());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="共享受限资源"><a href="#共享受限资源" class="headerlink" title="共享受限资源"></a>共享受限资源</h5><p>基本上所有的并发模式在解决线程冲突问题的时候，都是采用序列化访问共享资源的方案。<br>在共享资源的代码前加锁语句来实现，使得一段时间内只有一个任务访问共享资源。锁语句产生了一种互相排斥的效果，所以这种机制常常称为互斥量。  </p>
<ul>
<li>描述  </li>
</ul>
<p>屋子里的浴室实例：房子里的多个人都希望单独使用浴室。为了使用浴室，一个人先敲门，看看能否使用。如果没人的话，他就进入浴室锁上门。这时其它人<br>要使用浴室的话，就会被阻挡，所以他们要在门口等待，直到浴室可用。<br>当浴室使用完毕，当锁住浴室门的那个人打开锁准备离开的时候，簇拥在门口的人中，离门口最近的那个最有可能成为下一个进入浴室的人。可以通过yield<br>和setPriority来给线程调度器建议，但这些建议未必有多大效果，这取决于具体的平台和JVM实现。  </p>
<p>共享资源一般是以对象存在的内存片段，但也可以是文件、输入/输出端口、或者是打印机。要控制对共享资源的访问，得先把它包装成对象，然后把所有要<br>访问这个资源的方法都标记为synchronized。  </p>
<p>在使用并发时，将域设置为private是非常重要的。否则，synchronized就不能防止其它任务直接访问域，这样就会产生冲突。  </p>
<p>一个任务可以多次获得对象的锁，如果调用了一个对象的同步方法，方法中又调用了同一对象的另一个同步方法，JVM负责跟踪统计对象加锁的次数，每进入这个对象<br>的同步方法，计数加1；每退出这个对象的同步方法，计数减一。如果对象被解锁，计数为0。  </p>
<p>针对每个类，也有一个锁（作为类的Class对象的一部分），所以synchronized static可以在类的范围内防止对static数据的并发访问。  </p>
<p>每个访问临界共享资源的方法都应该被同步，否则它们就不能正确的工作。  </p>
<ul>
<li>使用显式的Lock对象  </li>
</ul>
<p>java.util.concurrent类库包含定义在java.util.concurrent.locks中显示的互斥机制。Lock对象必须被显式地创建、锁定<br>和释放。与内建的锁形式相比，代码缺乏优雅性，出错的可能性比较大。但是，对于解决某些类型的问题来说，它更加灵活。  </p>
<ul>
<li>原子性与易变性  </li>
</ul>
<p>原子操作是不能被线程调度机制中断的操作；一旦操作开始，那么它一定在 “上下文切换” 之前执行完毕。原子性不能替代同步，除非<br>有十足的把握。<br>原子性可以应用于除long和double之外的所有基本类型之上的简单操作。当你定义long或double变量时，如果使用volatitle<br>关键字，就会获得原子性。  </p>
<p>在多处理器系统上，相对于单处理器系统而言，可视性问题远比原子性问题多得多。一个任务做出的修改，即使在不中断的意义上讲<br>是原子性的，对其他任务也可能是不可视的。  </p>
<p>volatitle确保了应用中的可视性。一个域声明为volatitle的，那么只要对这个域产生了写操作，那么所有的读操作就都可以看到<br>这个修改。volatitle域会立即被写入到主内存中，而读取操作就发生在主内存中。  </p>
<p>synchronized会将工作内存变量值刷新到主内存中，用synchronized一般不需要volatitle。  </p>
<p>使用volatile而不是synchronized关键字的唯一安全的情况是类中只有一个可变的域。再次提醒，你的第一选择应该是使用synchronized<br>关键字，这是最安全的方式，而尝试其他任何方式都是有风险的。</p>
<ul>
<li>原子类  </li>
</ul>
<p>AtomicInteger、AtomicLong、AtomicReference等原子变量类，一般涉及到性能调优会用到。常规编程也很少用到。  </p>
<ul>
<li>临界区  </li>
</ul>
<p>也称为同步代码块；防止多个线程同时访问方法内部的部分代码而不是防止访问整个方法。通过这种方式分离出的代码段被称为<br>临界区，形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized(syncObject) &#123;</span><br><span class="line">  //</span><br><span class="line">  //</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>在其他对象上同步   </li>
</ul>
<p>synchronized块必须给定一个在其上进行同步的对象，使用synchronized(this)时，其他synchronized方法和临界区就不能<br>被调用。因此一般设置一个私有成员变量，以该变量作为同步对象。  </p>
<ul>
<li>线程本地存储  </li>
</ul>
<p>线程本地存储是一种自动化机制，可以为使用相同变量的每个不同的线程都创建不同的存储。<br>创建和管理本地存储一般使用java.lang.ThreadLocal类来实现。<br>ThreadLocal对象通常当作静态域存储。在创建ThreadLocal时，你只能通过get()和set()方法来访问该对象内容。<br>其中get()方法将返回与其线程相关联的对象的副本，而set()会将参数插入到为其线程存储的对象中，并返回存储中<br>原有的对象。  </p>
<h5 id="终结任务"><a href="#终结任务" class="headerlink" title="终结任务"></a>终结任务</h5><ul>
<li>装饰性花园  </li>
<li>在阻塞时终结  </li>
</ul>
<p>sleep()的一种情况，它使任务从执行状态变为被阻塞状态，而有时你必须终止被阻塞的任务。  </p>
<p><strong>线程状态</strong><br>1）新建（New）:当线程被创建时，它只会短暂地处于这种状态。此时它已经分配了必须的系统资源，并执行了<br>初始化。此刻线程已有资格获得CPU时间了，之后调度器将把这个线程转变为可运行状态或阻塞状态。<br>2）就绪（Runnable）：在这种状态下，只要调度器把时间片分配给线程，线程就可以运行。<br>3）阻塞（Blocked）：线程能够运行，但有某个条件阻止它的运行。当线程处于阻塞状态时，调度器将忽略线程，不会<br>分配线程任何cpu时间。直到线程重新进入就绪状态。<br>4）死亡（Dead）：处于死亡或终止状态的线程将不再是可调度的，并且再也不会得到cpu时间，它的任务已结束，或不再<br>是可运行的。任务死亡的通常方式是从run()方法返回，但是任务的线程还可以被中断。  </p>
<p><strong>进入阻塞状态</strong><br>进入阻塞状态的原因有如下：<br>1）通过调用sleep(milliseconds)使任务进入休眠状态，在这种情况下，任务在指定时间内不会运行。<br>2）调用wait()使线程挂起。直到线程得到了notify()或notifyAll()的消息（或在java.util.concurrent类库中等价的signal()或signalAll()消息），<br>线程才会进入就绪状态。<br>3）任务在等待某个输入/输出完成。<br>4）任务试图在某个对象上调用其同步控制方法，但是对象锁不可用，因为另一个任务已经获取了这个锁。<br>在较早的代码中可能看到suspend()和resume()来阻塞和唤醒线程，因为可能导致死锁，现在已经废弃了。stop()<br>方法也已经被弃用了，因为它不释放线程获得的锁，并且如果线程处于不一致状态，其它任务可以在这种状态下浏览并<br>修改它们，造成的问题难以发现。  </p>
<ul>
<li><p>中断<br>异常中断通过调用Thread的interrupt()方法。<br>当线程抛出异常InterruptedException或调用中断方法时，中断状态将被复位。<br>SleepBlocked是可中断，IOBlocked和SynchronizedBlocked是不可以中断的，对于这类问题可以关闭任务在其上发生阻塞的底层资源。  </p>
</li>
<li><p>被互斥所阻塞  </p>
</li>
<li>检查中断<br>通过调用interrupted()来检查中断状态。  </li>
</ul>
<h5 id="线程之间的协作"><a href="#线程之间的协作" class="headerlink" title="线程之间的协作"></a>线程之间的协作</h5><ul>
<li><p>wait()与notifyAll()<br>调用sleep()和yield()时候锁并没有被释放。<br>wait()调用时，线程将被挂起，对象上的锁被释放。在该对象上的其它synchronized方法在wait()期间被调用。<br>两种形式的wait：第一种接受毫秒作为参数，意为在此期间等待；第二种没有参数，一直等待。两种方式都可以通过notify和notifyAll恢复执行。<br>wait、notify、notifyAll这些方法是基类Object的一部分。在调用这些方法前必须先获取该对象的锁。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sychronized(x) &#123;</span><br><span class="line">    x.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>错失的信号  </p>
</li>
<li><p>notify()与nitifyAll()<br>使用nitify()而不是nitifyAll()是一种优化。<br>使用notify()时，在众多等待同一个锁的任务中只有一个会被唤醒，因此要使用notify就必须保证被唤醒的是恰当的任务。  </p>
</li>
<li><p>生产者与消费者  </p>
</li>
<li><p>使用显示的Lock和Condition对象  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private Lock lock = new ReentrantLock();</span><br><span class="line">private Condition condition = lock.newCondition();</span><br><span class="line">public void test() &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">      condition.await();</span><br><span class="line">      condition.signalAll();//</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>生产者-消费者队列  </p>
</li>
<li>任务间使用管道进行输入/输出  </li>
</ul>
<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><h5 id="新类库中的构件"><a href="#新类库中的构件" class="headerlink" title="新类库中的构件"></a>新类库中的构件</h5><ul>
<li>CountDownLatch<br>它被用来同步一个或多个任务，强制它们等待由其他任务执行的一组操作完成。不能充值。  </li>
<li>CyclicBarrier<br>你希望创建一组任务，它们并行地执行工作，然后在进行下一个步骤之前等待，直至所有任务都完成。可以重置。  </li>
<li>DelayQueue<br>一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象的延迟<br>到期的时间最长。如果没有任何延迟到期，那么就不会有任何头元素。  </li>
<li>PriorityBlockingQueue<br>这是一个很基础的优先级队列，它具有可阻塞的读取操作。  </li>
<li>使用ScheduledExecutor的温室控制器  </li>
<li>Semaphore<br>计数信号量允许n个任务同时访问这个资源。  </li>
<li>Exchanger<br>Exchanger是在两个任务之间交换对象的栅栏。当这些任务进入栅栏时，它们各自拥有一个对象，当它们离开时，它们都拥有之前由对象持有的对象。  </li>
</ul>
<h5 id="仿真"><a href="#仿真" class="headerlink" title="仿真"></a>仿真</h5><h5 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h5><h5 id="活动对象"><a href="#活动对象" class="headerlink" title="活动对象"></a>活动对象</h5>
      
    </div>
    <footer class="article-footer">
      
      
      
      
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编程思想/">编程思想</a></li></ul>

      

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->


  
    <article id="post-java编程思想-17"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/09/25/java编程思想-17/">java编程思想[17]-容器</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/09/25/java编程思想-17/" class="article-date">
	  <time datetime="2018-09-25T10:32:00.000Z" itemprop="datePublished">2018-09-25</time>
	</a>

      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Java当中，如果有一个类专门用来存放其它类的对象，这个类就叫做容器，或者就叫做集合，集合就是将若干性质相同或相近的类对象组合在一起而形成的一个整体。<br><a id="more"></a> </p>
<h4 id="容器深入研究"><a href="#容器深入研究" class="headerlink" title="容器深入研究"></a>容器深入研究</h4><hr>
<h5 id="完整的容器分类法"><a href="#完整的容器分类法" class="headerlink" title="完整的容器分类法"></a>完整的容器分类法</h5><h5 id="填充容器"><a href="#填充容器" class="headerlink" title="填充容器"></a>填充容器</h5><p>使用Collections.nCopies()进行填充，可以自定义添加填充个数，而Collections.fill()只能替换元素不能添加元素。  </p>
<h5 id="Collections的功能方法"><a href="#Collections的功能方法" class="headerlink" title="Collections的功能方法"></a>Collections的功能方法</h5><p>如下Collection所有操作，也是可以通过Set或List执行的所有操作（List还有额外功能）。Map不是继承自Collecion所以不使用下面方法。  </p>
<ul>
<li>boolean add(T) 确保容器持有具有泛型类型T的参数。如果没有将此参数添加进容器，则返回false。  </li>
<li>boolean addAll(Collection&lt;? extends T&gt;) 添加参数中的所有元素，只要添加了任意元素就返回true。  </li>
<li>void clear()  移除容器中的所有元素。  </li>
<li>boolean contains(T) 如果容器已经持有具有泛型类型T此参数，则返回true。  </li>
<li>Boolean containsAll(Collecion&lt;?&gt;) 如果容器持有此参数的所有元素，则返回true。  </li>
<li>boolean isEmpty() 容器中没有任何元素返回true。  </li>
<li>Iterator<t> iterator() 返回一个Iterator<t>，可以用来遍历容器中的元素。  </t></t></li>
<li>Boolean remove(Object) 如果参数在容器中，则移除此元素一个实例。如果做了移除动作，返回true。  </li>
<li>boolean removeAll(Collection&lt;?&gt;) 移除参数中的所有元素。只要有移除动作发生就返回true。  </li>
<li>Boolean retainAll(Collection&lt;?&gt;) 只保存参数中的元素（应用集合论的”交集”概念）。 只要集合发生了改变就返回true。  </li>
<li>int size()返回容器中元素数目。  </li>
<li>Object[] toArray() 返回一个数组，该数组包含容器中的所有元素。  </li>
<li><t> T[] toArray(T[] a) 返回一个数组，该数组包含容器中的所有元素。返回结果的运行时类型与参数数组a的相同，而不是单纯的Object。  </t></li>
</ul>
<h5 id="可选操作"><a href="#可选操作" class="headerlink" title="可选操作"></a>可选操作</h5><h5 id="List的功能方法"><a href="#List的功能方法" class="headerlink" title="List的功能方法"></a>List的功能方法</h5><h5 id="Set和存储顺序"><a href="#Set和存储顺序" class="headerlink" title="Set和存储顺序"></a>Set和存储顺序</h5><p>Set中的存储顺序如何维护，Set的不同实现之间有所变化。因此不同Set实现不仅有不同的行为，而且它们对于可以在特定的Set中放置的元素的类型也有不同的要求  </p>
<blockquote>
<p><strong>Set（interface）:</strong>存入Set的每个元素必须是唯一的，因为Set不保存重复元素。加入Set的元素必须定义equals()方法以确保对象的唯一性。Set与Collection有完全一样的接口。Set接口不保证维护元素的次序。<br><strong>HashSet：</strong>为快速查找而设计的Set，存入HashSet的元素必须定义hashCode()，没有其他的限制，应默认采取该方式，对速度进行了优化。<br><strong>TreeSet：</strong>保持次序的Set，底层为树结构。使用它可以从Set中提取有序的序列。元素必须实现Comparable<br><strong>LinkedHashSet：</strong>具有HashSet的查询速度，且内部使用链表维护元素的顺序（插入的次序）。于是在使用迭代器遍历Set时，结果会按元素插入的次序显示，元素也必须定义hashCode()方法   </p>
</blockquote>
<ul>
<li>SortedSet<br>SortedSet中的元素可以保证处于排序状态，具有如下方法提供的附加功能：<br><strong>Comparator comparator()</strong>返回当前Set使用的Comparator。<br><strong>Object first()</strong>返回容器中的第一个元素。<br><strong>Object last()</strong>返回容器中的最末一个元素。<br><strong>SortedSet subSet(fromElement, toElement)</strong>返回从fromElement（包含）到toElement（不包含）<br><strong>SortedSet headSet(toElement)</strong>生成此Set的子集，由小于toElement的元素组成。<br><strong>SortedSet tailSet(fromElement)</strong>生成此Set的子集，由大于或等于fromElement的元素组成。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class SortedSetDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SortedSet&lt;String&gt; sortedSet = new TreeSet&lt;&gt;();</span><br><span class="line">        Collections.addAll(sortedSet, &quot;one two three four five six seven eight&quot;.split(&quot; &quot;));</span><br><span class="line">        System.out.println(sortedSet);</span><br><span class="line">        String low = sortedSet.first();</span><br><span class="line">        String high = sortedSet.last();</span><br><span class="line">        System.out.println(low);</span><br><span class="line">        System.out.println(high);</span><br><span class="line">        Iterator&lt;String&gt; it = sortedSet.iterator();</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt;= 6; i++) &#123;</span><br><span class="line">    if (i == 3) &#123;</span><br><span class="line">    low = it.next();</span><br><span class="line">    System.out.println(&quot;i==3 low:&quot; + low);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    if (i == 6) &#123;</span><br><span class="line">    high = it.next();</span><br><span class="line">    System.out.println(&quot;i==6 high:&quot; + high);</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    String temp =  it.next();</span><br><span class="line">    System.out.println(&quot;temp:&quot; + temp);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(low);</span><br><span class="line">    System.out.println(high);</span><br><span class="line">    System.out.println(sortedSet.subSet(low,high));</span><br><span class="line">    System.out.println(sortedSet.headSet(high));</span><br><span class="line">    System.out.println(sortedSet.tailSet(low));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// output : </span><br><span class="line">[eight, five, four, one, seven, six, three, two]</span><br><span class="line">eight</span><br><span class="line">two</span><br><span class="line">temp:eight</span><br><span class="line">temp:five</span><br><span class="line">temp:four</span><br><span class="line">i==3 low:one</span><br><span class="line">temp:seven</span><br><span class="line">temp:six</span><br><span class="line">temp:three</span><br><span class="line">i==6 high:two</span><br><span class="line">one</span><br><span class="line">two</span><br><span class="line">[one, seven, six, three]</span><br><span class="line">[eight, five, four, one, seven, six, three]</span><br><span class="line">[one, seven, six, three, two]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意：SortedSet是按照元素的比较函数对元素排序，而不是元素插入的顺序。出入顺序可以用LinkedHashSet保存。   </p>
<h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><ul>
<li>Java SE5中仅有的两个实现是LinkedList和PriorityQueue，它们差异在于排序行为而不是性能。  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class QueueBehavior &#123;</span><br><span class="line">    private static int count = 10;</span><br><span class="line"></span><br><span class="line">    static &lt;T&gt; void test(Queue&lt;T&gt; queue, Generator&lt;T&gt; gen) &#123;</span><br><span class="line">        for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            queue.offer(gen.next());//队尾添加元素，队满返回false</span><br><span class="line">        &#125;</span><br><span class="line">        while (queue.peek() != null) &#123;//取队头，没有返回null</span><br><span class="line">            System.out.print(queue.remove() + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    static class Gen implements Generator&lt;String&gt; &#123;</span><br><span class="line">        String[] s = (&quot;one two three four five six seven eight nine ten&quot;).split(&quot; &quot;);</span><br><span class="line">        int i;</span><br><span class="line">        public String next() &#123;</span><br><span class="line">            return s[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        test(new LinkedList&lt;String&gt;(), new Gen());</span><br><span class="line">        test(new PriorityQueue&lt;String&gt;(), new Gen());//优先队列的作用是能保证每次取出的元素都是队列中权值最小的</span><br><span class="line">        test(new ArrayBlockingQueue&lt;&gt;(count), new Gen());//阻塞队列</span><br><span class="line">        test(new ConcurrentLinkedDeque&lt;&gt;(), new Gen());//非阻塞线程安全队列</span><br><span class="line">        test(new LinkedBlockingDeque&lt;&gt;(), new Gen());//基于链表的双端阻塞队列，支持FIFO和FILO，线程安全</span><br><span class="line">        test(new PriorityBlockingQueue&lt;&gt;(), new Gen());//阻塞优先级队列，线程安全</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>双向队列<br>ArrayDeque不是线程安全的，可以双向（队头和队尾操作），主要方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">1.添加元素</span><br><span class="line">     addFirst(E e)在数组前面添加元素</span><br><span class="line">     addLast(E e)在数组后面添加元素</span><br><span class="line">     offerFirst(E e) 在数组前面添加元素，并返回是否添加成功</span><br><span class="line">     offerLast(E e) 在数组后天添加元素，并返回是否添加成功</span><br><span class="line"></span><br><span class="line">2.删除元素</span><br><span class="line">     removeFirst()删除第一个元素，并返回删除元素的值,如果元素为null，将抛出异常</span><br><span class="line">     pollFirst()删除第一个元素，并返回删除元素的值，如果元素为null，将返回null</span><br><span class="line">     removeLast()删除最后一个元素，并返回删除元素的值，如果为null，将抛出异常</span><br><span class="line">     pollLast()删除最后一个元素，并返回删除元素的值，如果为null，将返回null</span><br><span class="line">     removeFirstOccurrence(Object o) 删除第一次出现的指定元素</span><br><span class="line">     removeLastOccurrence(Object o) 删除最后一次出现的指定元素</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 3.获取元素</span><br><span class="line">     getFirst() 获取第一个元素,如果没有将抛出异常</span><br><span class="line">     getLast() 获取最后一个元素，如果没有将抛出异常</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 4.队列操作</span><br><span class="line">     add(E e) 在队列尾部添加一个元素</span><br><span class="line">     offer(E e) 在队列尾部添加一个元素，并返回是否成功</span><br><span class="line">     remove() 删除队列中第一个元素，并返回该元素的值，如果元素为null，将抛出异常(其实底层调用的是removeFirst())</span><br><span class="line">     poll()  删除队列中第一个元素，并返回该元素的值,如果元素为null，将返回null(其实调用的是pollFirst())</span><br><span class="line">     element() 获取第一个元素，如果没有将抛出异常</span><br><span class="line">     peek() 获取第一个元素，如果返回null</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"> 5.栈操作</span><br><span class="line">     push(E e) 栈顶添加一个元素</span><br><span class="line">     pop(E e) 移除栈顶元素,如果栈顶没有元素将抛出异常</span><br><span class="line">     </span><br><span class="line"></span><br><span class="line"> 6.其他</span><br><span class="line">     size() 获取队列中元素个数</span><br><span class="line">     isEmpty() 判断队列是否为空</span><br><span class="line">     iterator() 迭代器，从前向后迭代</span><br><span class="line">     descendingIterator() 迭代器，从后向前迭代</span><br><span class="line">     contain(Object o) 判断队列中是否存在该元素</span><br><span class="line">     toArray() 转成数组</span><br><span class="line">     clear() 清空队列</span><br><span class="line">     clone() 克隆(复制)一个新的队列</span><br></pre></td></tr></table></figure>
<h5 id="理解Map"><a href="#理解Map" class="headerlink" title="理解Map"></a>理解Map</h5><ul>
<li>性能<br>HashMap是使用对象的hashCode()进行快速查询的，此方法能够显著提高性能。<br>下面是基本的Map实现。在HashMap上打星号表示如果没有其他的限制，它就应该成为你的默认选择，因为它对速度进行了优化。其它实现强调了其他的特性，因此都不如HashMap快。  </li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">HashMap</td>
<td style="text-align:left">Map基于散列表的实现。插入和查询键值对的开销是固定的。可以通过构造器设置容量和负载因子，以调整容器的性能。</td>
</tr>
<tr>
<td style="text-align:left">LinkedHashMap</td>
<td style="text-align:left">类似于HashMap，但是迭代遍历它时，取得键值对的顺序是其插入次序，或者是最近最少使用的次序。只比HashMap慢一点，而在迭代访问时反而更快，因为它使用链表维护内部次序。</td>
</tr>
<tr>
<td style="text-align:left">TreeMap</td>
<td style="text-align:left">基于红黑树的实现。查看键或键值对时，它们会被排序（有Comparable或Comparator决定）。TreeMap的特点在于，所得到的结果是经过排序的。唯一带有subMap()方法的Map。</td>
</tr>
<tr>
<td style="text-align:left">WeakHashMap</td>
<td style="text-align:left">弱键映射，允许释放映射所指向的对象；为解决某类特殊问题而设计的。如果映射之外没有引用指向某个键，则此键可以被垃圾回收器回收。</td>
</tr>
<tr>
<td style="text-align:left">ConcurrentHashMap</td>
<td style="text-align:left">一种线程安全的Map，它不涉及同步加锁。</td>
</tr>
<tr>
<td style="text-align:left">IdentityHashMap</td>
<td style="text-align:left">使用==代替equals对键进行比较的散列映射。</td>
</tr>
</tbody>
</table>
<ul>
<li>SortedMap<br>使用SortedMap（TreeMap是现阶段唯一实现），可以确保键处于排序状态。  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//返回元素比较器。如果是自然顺序，则返回null；</span><br><span class="line">    Comparator&lt;? super K&gt; comparator();</span><br><span class="line">    </span><br><span class="line">    //返回从fromKey到toKey的集合：含头不含尾</span><br><span class="line">    java.util.SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey);</span><br><span class="line"></span><br><span class="line">    //返回从头到toKey的集合：不包含toKey</span><br><span class="line">    java.util.SortedMap&lt;K,V&gt; headMap(K toKey);</span><br><span class="line"></span><br><span class="line">    //返回从fromKey到结尾的集合：包含fromKey</span><br><span class="line">    java.util.SortedMap&lt;K,V&gt; tailMap(K fromKey);</span><br><span class="line">    </span><br><span class="line">    //返回集合中的第一个元素：</span><br><span class="line">    K firstKey();</span><br><span class="line">   </span><br><span class="line">    //返回集合中的最后一个元素：</span><br><span class="line">    K lastKey();</span><br><span class="line">    </span><br><span class="line">    //返回集合中所有key的集合：</span><br><span class="line">    Set&lt;K&gt; keySet();</span><br><span class="line">    </span><br><span class="line">    //返回集合中所有value的集合：</span><br><span class="line">    Collection&lt;V&gt; values();</span><br><span class="line">    </span><br><span class="line">    //返回集合中的元素映射：</span><br><span class="line">    Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</span><br></pre></td></tr></table></figure>
<ul>
<li>LinkedHashMap<br>LinkedHashMap 是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，<br>按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。  </li>
</ul>
<h5 id="散列和散列码"><a href="#散列和散列码" class="headerlink" title="散列和散列码"></a>散列和散列码</h5><p>假如键没有按照一定的顺序进行保存，那么查询的时候就只能按照顺序进行线性查询，然而，线性查询是最慢的查询方式。所以，将键值按照一定的顺序排序，并且使用二分查找能购有效的提升速度。散列在此之上，更近一步，他将键保存在数组中(数组的查询速度最快)，用数组来表示键的信息，但是由于Map的容量是可变的，而数组的容量是不变的。要解决这个问题，数组中存的并不是键本身，而是键对象生成的一个数字，将其作为数组的下标，这个数字就是散列码。<br>而这种办法所产生的问题就是下标重复。而我们的解决办法就是配合equals来确定键值。<br>查询的过程首先就是计算散列码，然后用散列码来查询函数(下标)，通常，我们的数组中保存的是值的list，因此，我们计算出散列码之后，通过下表取到的对应部分的list，然后通过equals就可以快速找到键值。  </p>
<p>散列码：通过hashCode返回int类型的数值，即为对象的散列码。</p>

      
    </div>
    <footer class="article-footer">
      
      
      
      
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编程思想/">编程思想</a></li></ul>

      

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->


  
    <article id="post-java编程思想-16"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/08/23/java编程思想-16/">java编程思想[16]-数组</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/08/23/java编程思想-16/" class="article-date">
	  <time datetime="2018-08-23T07:34:00.000Z" itemprop="datePublished">2018-08-23</time>
	</a>

      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>泛型对数组是极大的威胁，带有泛型的容器拥有更强大的适用性。只有在证明性能受限时，才会考虑使用数组，但数组还是必须掌握的基础知识。<br><a id="more"></a>  </p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><hr>
<h5 id="数组为什么特殊"><a href="#数组为什么特殊" class="headerlink" title="数组为什么特殊"></a>数组为什么特殊</h5><ul>
<li>数组是一种效率最高的存储和随机访问对象引用序列的方式。数组就是一个简单的线性序列，这使得元素访问非常快速。数据大小固定。  </li>
</ul>
<p>数组与泛型容器比较：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class BerylliumSphere &#123;</span><br><span class="line">private static long counter;</span><br><span class="line">private final long id = counter++;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;Sphere &quot; + id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ContainerComparison &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">BerylliumSphere[] spheres = new BerylliumSphere[10];</span><br><span class="line">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">spheres[i] = new BerylliumSphere();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(spheres));</span><br><span class="line">System.out.println(spheres[4]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">List&lt;BerylliumSphere&gt; sphereList = new ArrayList&lt;&gt;();</span><br><span class="line">for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">sphereList.add(new BerylliumSphere());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sphereList);</span><br><span class="line">System.out.println(sphereList.get(4));</span><br><span class="line"></span><br><span class="line">int[] integers = &#123;0, 1, 2, 3, 4, 5&#125;;</span><br><span class="line">System.out.println(Arrays.toString(integers));</span><br><span class="line">System.out.println(integers[4]);</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; intList = new ArrayList&lt;&gt;(Arrays.asList(0, 1, 2, 3, 4, 5));</span><br><span class="line">intList.add(97);</span><br><span class="line">System.out.println(intList);</span><br><span class="line">System.out.println(intList.get(4));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h5><p>初始化赋值，也可以循环赋。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MultidimensionalPrimitiveArray &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  int[][] a = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;&#125;;</span><br><span class="line">  System.out.println(Arrays.deepToString(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="数组与泛型"><a href="#数组与泛型" class="headerlink" title="数组与泛型"></a>数组与泛型</h5><p>不能实例化具有参数化类型的数组：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Peel&lt;Banana&gt;[] peels = new Peel&lt;Banana&gt;[10];//Illegal</span><br></pre></td></tr></table></figure>
<p>擦除会移除参数类型信息，而数组必须知道它们所持有的确切类型，以强制保证类型安全。<br>但是，可以参数化数组本身的类型：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class ClassParameter&lt;T&gt; &#123;</span><br><span class="line">    public T[] f(T[] arg) &#123;</span><br><span class="line">        return arg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MethodParameter &#123;</span><br><span class="line">    public static &lt;T&gt; T[] f(T[] arg) &#123;</span><br><span class="line">        return arg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ParameteriaedArrayType &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer[] ints = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">        Double[] doubles = &#123;1.1, 2.2, 3.3, 4.4, 5.5&#125;;</span><br><span class="line">        Integer[] ints2 = new ClassParameter&lt;Integer&gt;().f(ints);</span><br><span class="line">        Double[] doubles2 = new ClassParameter&lt;Double&gt;().f(doubles);</span><br><span class="line">        ints2 = MethodParameter.f(ints);</span><br><span class="line">        doubles = MethodParameter.f(doubles);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="创建测试数据"><a href="#创建测试数据" class="headerlink" title="创建测试数据"></a>创建测试数据</h5><ul>
<li>Arrays.fill()<br>只能用同一个值填充各个位置，而针对对象而言，就是复制同一个引用进行填充。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class FillingArrays &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int size = 6;</span><br><span class="line">        boolean[] a1 = new boolean[size];</span><br><span class="line">        byte[] a2 = new byte[size];</span><br><span class="line">        char[] a3 = new char[size];</span><br><span class="line">        short[] a4 = new short[size];</span><br><span class="line">        int[] a5 = new int[size];</span><br><span class="line">        long[] a6 = new long[size];</span><br><span class="line">        float[] a7 = new float[size];</span><br><span class="line">        double[] a8 = new double[size];</span><br><span class="line">        String[] a9 = new String[size];</span><br><span class="line">        Arrays.fill(a1, true);</span><br><span class="line">        System.out.println(&quot;a1 = &quot; + Arrays.toString(a1));</span><br><span class="line">        Arrays.fill(a2, (byte)11);</span><br><span class="line">        System.out.println(&quot;a2 = &quot; + Arrays.toString(a2));</span><br><span class="line">        Arrays.fill(a3, &apos;x&apos;);</span><br><span class="line">        System.out.println(&quot;a3 = &quot; + Arrays.toString(a3));</span><br><span class="line">        Arrays.fill(a4, (short)17);</span><br><span class="line">        System.out.println(&quot;a4 = &quot; + Arrays.toString(a4));</span><br><span class="line">        Arrays.fill(a5, 19);</span><br><span class="line">        System.out.println(&quot;a5 = &quot; + Arrays.toString(a5));</span><br><span class="line">        Arrays.fill(a6, 23);</span><br><span class="line">        System.out.println(&quot;a6 = &quot; + Arrays.toString(a6));</span><br><span class="line">        Arrays.fill(a7, 29);</span><br><span class="line">        System.out.println(&quot;a7 = &quot; + Arrays.toString(a7));</span><br><span class="line">        Arrays.fill(a8, 47);</span><br><span class="line">        System.out.println(&quot;a8 = &quot; + Arrays.toString(a8));</span><br><span class="line">        Arrays.fill(a9, &quot;hello&quot;);</span><br><span class="line">        System.out.println(&quot;a9 = &quot; + Arrays.toString(a9));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="Arrays实用功能"><a href="#Arrays实用功能" class="headerlink" title="Arrays实用功能"></a>Arrays实用功能</h5><ul>
<li>数组复制  </li>
</ul>
<blockquote>
<p>Java标准类库提供有static方法 <code>System.arraycopy()</code>，用它复制数组比用for循环快很多。<br>该方法不会执行自动拆包和自动包装，两个数组必须具有相同的确切类型。<br>如果数组存储的是对象，则拷贝属于浅复制，仅复制对象引用。</p>
</blockquote>
<p>参数详解：<br> <code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code> 其中，src表示源数组，srcPos表示源数组要复制的起始位置，dest表示目标数组，<br>destPos表示目标数组开始复制的起始位置，length表示要复制的长度。  </p>
<ul>
<li>数组的比较  </li>
</ul>
<blockquote>
<p>Arrays类提供了重载后的equals()方法，用来比较整个数组。<br>数组相等的条件是个数必须相等，并且对于位置的元素也相等，对每一个元素使用equals()作比较来判断。  </p>
</blockquote>
<p>参数详解：<br><code>Arrays.equals(a1, a2)</code>其中，a1为数组1，a2为数组2。  </p>
<ul>
<li>数组元素的比较  </li>
</ul>
<blockquote>
<p>基本数据类型的数组不需要实现自己的比较器，java提供默认比较器。  </p>
</blockquote>
<p>提供两种实现方式，对象实现接口java.lang.Comparable接口，使你的类天生具有”天生”比较能力。此方法要实现compareTo()一个方法。此方法接收另一个Object为参数，如果当前对象小于参数则返回负值，<br>如果相等就返回零，如果当前对象大于参数则返回正值。数组排序依赖于数组元素的比较，在数组对象实现Comparable接口后，调用<code>Arrays.sort(object)</code>其中object为目标数组，进行排序，只提供了升序排列。  </p>
<p>第二种也可以实现自己的比较器Comparator。然后调用<code>Arrays.sort(object, 比较器)</code>其中object为目标数组，比较器是自己实现的比较器。如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ComTypeComparator implements Comparator&lt;Object&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Object o1, Object o2) &#123;</span><br><span class="line">        return o1.hashCode() &lt; o2.hashCode() ? -1 : o1.hashCode() == o2.hashCode() ? 0 : 1 ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在已排序的数组中查找<br><code>Arrays.binarySearch(object[], object key)</code>其中object[]为查找的目标数组，key为要查找的值。如果key在数组中，则返回搜索值的索引；否则返回-1或者”-“(插入点)。插入点是索引键将要插入数组的那一点，即第一个大于该键的元素索引。  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        int a[] = new int[] &#123;1, 3, 4, 6, 8, 9&#125;;</span><br><span class="line">        int x1 = Arrays.binarySearch(a, 5);</span><br><span class="line">        int x2 = Arrays.binarySearch(a, 4);</span><br><span class="line">        int x3 = Arrays.binarySearch(a, 0);</span><br><span class="line">        int x4 = Arrays.binarySearch(a, 10);</span><br><span class="line">        System.out.println(&quot;x1:&quot; + x1 + &quot;, x2:&quot; + x2);</span><br><span class="line">        System.out.println(&quot;x3:&quot; + x3 + &quot;, x4:&quot; + x4);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      
      
      
      
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编程思想/">编程思想</a></li></ul>

      

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->


  
    <article id="post-java编程思想-15"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/2018/08/23/java编程思想-15/">java编程思想[15]-范型</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2018/08/23/java编程思想-15/" class="article-date">
	  <time datetime="2018-08-23T07:32:00.000Z" itemprop="datePublished">2018-08-23</time>
	</a>

      
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>泛型正如其名称暗示的：它是一种方法，通过它可以写出更泛化的代码，这些代码对于它们所操作的类型有更少的限制，因此单个代码段可以应用到更多的类型上，减少重复编码。<br><a id="more"></a></p>
<h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><h5 id="简单泛型"><a href="#简单泛型" class="headerlink" title="简单泛型"></a>简单泛型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public calss Holder&lt;T&gt; &#123;</span><br><span class="line"> private T a;</span><br><span class="line"> public Holder(T a) &#123;</span><br><span class="line">  this.a = a;</span><br><span class="line"> &#125;</span><br><span class="line"> public T get() &#123;</span><br><span class="line">  return a;</span><br><span class="line"> &#125;</span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">  Holder&lt;Automobile&gt; h = </span><br><span class="line">    new Holder&lt;Automobile&gt;(new Automobile);</span><br><span class="line">  Automobile a = h.get();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>有了泛型，可以很容易地创建元组，令其返回一组任意类型的对象。通过元组的方式实现返回多个对象的功能     </li>
</ul>
<p><strong>可以通过继承实现更长的元组：</strong>      </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class TwoTuple&lt;A, B&gt; &#123;</span><br><span class="line">    public final A first;</span><br><span class="line">    public  final B second;</span><br><span class="line"></span><br><span class="line">    public TwoTuple(A a, B b) &#123;</span><br><span class="line">        this.first = a;</span><br><span class="line">        this.second = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;(&quot; + first + &quot;，&quot; + second + &quot;)&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TwoTuple&lt;String, Integer&gt; ttsi = new TwoTuple&lt;&gt;(&quot;hi&quot;, 666);</span><br><span class="line">        System.out.println(ttsi.first);</span><br><span class="line">        System.out.println(ttsi.second);</span><br><span class="line">        System.out.println(ttsi.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>泛型实现一个堆栈类<br>不使用已有的Stack和LinkedList实现一个堆栈类  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedStack&lt;T&gt; &#123;</span><br><span class="line">    private static class Node&lt;U&gt; &#123;</span><br><span class="line">        U item;</span><br><span class="line">        Node&lt;U&gt; next;</span><br><span class="line">        Node() &#123;</span><br><span class="line">            item = null;</span><br><span class="line">            next = null;</span><br><span class="line">        &#125;</span><br><span class="line">        Node(U item, Node&lt;U&gt; next) &#123;</span><br><span class="line">            this.item = item;</span><br><span class="line">            this.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        boolean end() &#123;</span><br><span class="line">            return item == null &amp;&amp; next == null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Node&lt;T&gt; top = new Node&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void push(T item) &#123;</span><br><span class="line">        top = new Node&lt;&gt;(item, top);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T pop() &#123;</span><br><span class="line">        T result = top.item;</span><br><span class="line">        if (!top.end()) &#123;</span><br><span class="line">            top = top.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h5><p>泛型也可以应用于接口。如生成器</p>
<p>接口类： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Generator&lt;T&gt; &#123;</span><br><span class="line">    T next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以生成各类咖啡对象为例，这里准备一些Coffee类：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Coffee &#123;</span><br><span class="line">    private static long counter = 0;</span><br><span class="line">    private final long id = counter++;</span><br><span class="line"></span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return getClass().getSimpleName() + &quot; &quot; + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Americano extends Coffee &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Breve extends Coffee &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Cappuccino extends Coffee &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Latte extends Coffee &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Mocha extends Coffee &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写CoffeeGenerator类实现Generator<coffee>接口，随机生成不同类型的Coffee对象：  </coffee></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class CoffeeGenerator implements Generator&lt;Coffee&gt;, Iterable&lt;Coffee&gt;&#123;</span><br><span class="line"></span><br><span class="line">    private Class[] types = &#123;Latte.class, Mocha.class, Cappuccino.class, Americano.class, Breve.class&#125;;</span><br><span class="line">    private static Random rand = new Random(47);</span><br><span class="line"></span><br><span class="line">    public CoffeeGenerator() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int size = 0;</span><br><span class="line"></span><br><span class="line">    public CoffeeGenerator(int sz) &#123;</span><br><span class="line">        this.size = sz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Iterator&lt;Coffee&gt; iterator() &#123;</span><br><span class="line">        return new CoffeeIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Coffee next() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Coffee)types[rand.nextInt(types.length)].newInstance();</span><br><span class="line">        &#125;  catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class CoffeeIterator implements Iterator&lt;Coffee&gt; &#123;</span><br><span class="line">        int count = size;</span><br><span class="line">        @Override</span><br><span class="line">        public Coffee next() &#123;</span><br><span class="line">            count--;</span><br><span class="line">            return CoffeeGenerator.this.next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void remove() &#123;</span><br><span class="line">            throw new UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean hasNext() &#123;</span><br><span class="line">            return count &gt; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CoffeeGenerator gen = new CoffeeGenerator();</span><br><span class="line">        for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            System.out.println(gen.next());</span><br><span class="line">        &#125;</span><br><span class="line">        for (Coffee c : new CoffeeGenerator(5)) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h5><blockquote>
<p>泛型方法所在的类可以是泛型类，也可以不是泛型类<br>能用泛型方法，尽量不用泛型类，更清楚明白<br>static方法无法使用泛型类的类型参数，static要使用泛型能力，就必须成为泛型方法  </p>
</blockquote>
<p>要定义泛型方法，只需将泛型参数列表置于返回值之前：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class GenericMethods &#123;</span><br><span class="line">    public &lt;T&gt; void f(T x) &#123;</span><br><span class="line">        System.out.println(x.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        GenericMethods gm = new GenericMethods();</span><br><span class="line">        gm.f(&quot;&quot;);</span><br><span class="line">        gm.f(1);</span><br><span class="line">        gm.f(1.0);</span><br><span class="line">        gm.f(1.0f);</span><br><span class="line">        gm.f(&apos;c&apos;);</span><br><span class="line">        gm.f(gm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>类型参数推断<br>当使用泛型类时，必须在创建对象的时候指定类型参数的值，而使用泛型方法的时候，通常不必指明参数类型，因为编译器会为我们找出具体的类型。  </p>
</li>
<li><p>可变参数与泛型方法<br>泛型方法与可变参数列表可以很好的共存  </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class GenericVarargs &#123;</span><br><span class="line">    public static &lt;T&gt; List&lt;T&gt; makeList(T... args) &#123;</span><br><span class="line">        List&lt;T&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        for (T item : args) &#123;</span><br><span class="line">            result.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; ls = makeList(&quot;A&quot;);</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">        ls = makeList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">        ls = makeList(&quot;ABCDEFGHIJKLMNOPQ&quot;.split(&quot;&quot;));</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="泛型应用到内部类及匿名内部类"><a href="#泛型应用到内部类及匿名内部类" class="headerlink" title="泛型应用到内部类及匿名内部类"></a>泛型应用到内部类及匿名内部类</h5><p>Customer和Teller只有private构造器，必须使用Generator对象。Customer中generator方法，每次生成一个Generator<customer>对象。<br>其实不需要这么多Generator对象，Teller只创建了一个public的generator对象。  </customer></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Customer &#123;</span><br><span class="line">    private static long counter = 1;</span><br><span class="line">    private final long id = counter++;</span><br><span class="line">    private Customer() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Customer &quot; + id;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Generator&lt;Customer&gt; generator() &#123;</span><br><span class="line">        return new Generator&lt;Customer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Customer next() &#123;</span><br><span class="line">                return new Customer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Teller &#123;</span><br><span class="line">    private static long counter = 1;</span><br><span class="line">    private final long id = counter++;</span><br><span class="line"></span><br><span class="line">    private Teller() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;teller: &quot; + id;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Generator&lt;Teller&gt; generator =</span><br><span class="line">            new Generator&lt;Teller&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public Teller next() &#123;</span><br><span class="line">                    return new Teller();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BankTeller &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="擦除的神秘之处"><a href="#擦除的神秘之处" class="headerlink" title="擦除的神秘之处"></a>擦除的神秘之处</h5><p>ArrayList<string>和ArrayList<integer>很容易被认为是不同的类型，其实不然：  </integer></string></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ErasedTypeEquivalence &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Class c1 = new ArrayList&lt;String&gt;().getClass();</span><br><span class="line">        Class c2 = new ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">        System.out.println(c1 == c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面运行返回true，下面示例是解答：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Frob &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Fnorkle &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Quark&lt;Q&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Particle&lt;POSITION, MOMENTUM&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class LostInformation &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Frob&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;Frob, Fnorkle&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        Quark&lt;Fnorkle&gt; quark = new Quark&lt;&gt;();</span><br><span class="line">        Particle&lt;Long, Double&gt; p = new Particle&lt;&gt;();</span><br><span class="line">        System.out.println(Arrays.toString(list.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(map.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(quark.getClass().getTypeParameters()));</span><br><span class="line">        System.out.println(Arrays.toString(p.getClass().getTypeParameters()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/* Output</span><br><span class="line">[E]</span><br><span class="line">[K, V]</span><br><span class="line">[Q]</span><br><span class="line">[POSITION, MOMENTUM]</span><br><span class="line">*///:~</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Class.getTypeParameters()将返回一个TypeVariable对象数组，表示有泛型声明所声明的类型参数。但是从输出可以看出，返回的仅仅的是参数占位符并不是具体的参数类型。<br>Java泛型是使用擦除实现的，但使用泛型时，任何具体的类型信息都被擦除了。因此List<string>和List<integer>在运行时是相同的类型，因为运行时都被擦除为原生类型即List。</integer></string></p>
</blockquote>
<h5 id="擦除的补偿"><a href="#擦除的补偿" class="headerlink" title="擦除的补偿"></a>擦除的补偿</h5><p>为了确定参数类型，通过显示的传递类型的Class对象。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Building &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class House extends Building &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class ClassTypeCapture&lt;T&gt; &#123;</span><br><span class="line">    Class&lt;T&gt; kind;</span><br><span class="line"></span><br><span class="line">    public ClassTypeCapture(Class&lt;T&gt; kind) &#123;</span><br><span class="line">        this.kind = kind;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean f(Object arg) &#123;</span><br><span class="line">        return kind.isInstance(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ClassTypeCapture&lt;Building&gt; ctt1 = new ClassTypeCapture&lt;&gt;(Building.class);</span><br><span class="line">        System.out.println(ctt1.f(new Building()));</span><br><span class="line">        System.out.println(ctt1.f(new House()));</span><br><span class="line">        ClassTypeCapture&lt;House&gt; ctt2 = new ClassTypeCapture&lt;&gt;(House.class);</span><br><span class="line">        System.out.println(ctt2.f(new Building()));</span><br><span class="line">        System.out.println(ctt2.f(new House()));</span><br><span class="line">    &#125;</span><br><span class="line">    /*output</span><br><span class="line">    true</span><br><span class="line">    true</span><br><span class="line">    false</span><br><span class="line">    true</span><br><span class="line">     */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h5><p>为了将泛型参数限定为某个类型子集，那么你就可以用这些类型子集来调用方法。为了执行限制，java泛型重用了extends关键字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">interface HasColor &#123;</span><br><span class="line">    Color getColor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Colored&lt;T extends HasColor&gt; &#123;</span><br><span class="line">    T item;</span><br><span class="line"></span><br><span class="line">    Colored(T item) &#123;</span><br><span class="line">        this.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T getItem() &#123;</span><br><span class="line">        return item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Color color() &#123;</span><br><span class="line">        return item.getColor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dimension &#123;</span><br><span class="line">    public int x,y, z;</span><br><span class="line">&#125;</span><br><span class="line">class ColoredDimension&lt;T extends Dimension &amp; HasColor&gt;&#123;</span><br><span class="line">    T item;</span><br><span class="line"></span><br><span class="line">    ColoredDimension(T item) &#123;</span><br><span class="line">        this.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T getItem() &#123;</span><br><span class="line">        return item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Color color() &#123;</span><br><span class="line">        return item.getColor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getX() &#123;</span><br><span class="line">        return item.x;</span><br><span class="line">    &#125;</span><br><span class="line">    int getY() &#123;</span><br><span class="line">        return item.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getZ() &#123;</span><br><span class="line">        return item.z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Weight &#123;</span><br><span class="line">    int weight();</span><br><span class="line">&#125;</span><br><span class="line">class Solid&lt;T extends Dimension &amp; HasColor &amp; Weight&gt;&#123;</span><br><span class="line">    T item;</span><br><span class="line"></span><br><span class="line">    Solid(T item) &#123;</span><br><span class="line">        this.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T getItem() &#123;</span><br><span class="line">        return item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Color color() &#123;</span><br><span class="line">        return item.getColor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getX() &#123;</span><br><span class="line">        return item.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getY() &#123;</span><br><span class="line">        return item.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getZ() &#123;</span><br><span class="line">        return item.z;</span><br><span class="line">    &#125;</span><br><span class="line">    int weight() &#123;</span><br><span class="line">        return item.weight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bounded extends Dimension implements HasColor, Weight &#123;</span><br><span class="line">   public Color getColor() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int weight() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class BasicBounds &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Solid&lt;Bounded&gt; solid = new Solid&lt;&gt;(new Bounded());</span><br><span class="line">        solid.color();</span><br><span class="line">        solid.getY();</span><br><span class="line">        solid.weight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h5><p>如下方式在编译器中是不通过的：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class NonCovariantGenerics &#123;</span><br><span class="line">//    List&lt;Fruit&gt; flist = new ArrayList&lt;Apple&gt;();//编译错误</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通配符为?，例如 <code>List&lt;? extends Fruit&gt;</code> 指具有任何从Fruit继承的类型的列表。但最终需要具体的继承自Fruit的对象数组被该引用所引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class GenericsAndCovariance &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;? extends Fruit&gt; flist = new ArrayList&lt;Apple&gt;(); //一旦向上转型就不能添加任何对象，不过可以将任何继承自Fruit的list对象数组赋值给该数组</span><br><span class="line">        //下面编译出错，不能添加任何对象</span><br><span class="line">//        flist.add(new Apple());</span><br><span class="line">//        flist.add(new Fruit());</span><br><span class="line">//        flist.add(new Object());</span><br><span class="line">//        flist.add(null);//合法但无意义</span><br><span class="line">        Fruit f = flist.get(0);</span><br><span class="line"></span><br><span class="line">        flist.clear();</span><br><span class="line">        List&lt;Apple&gt; appleList = new ArrayList&lt;&gt;();</span><br><span class="line">        appleList.add(new Apple());</span><br><span class="line">        flist = appleList;</span><br><span class="line">        Fruit fruit = flist.get(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>超类型通配符<br>可以声明通配符是由某个特定类的任何基类来界定的，方法是指定 <code>&lt;? super MyClass&gt;</code>，甚至或者使用类型参数：&lt;? super T&gt;，但不能声明 <code>T super MyClass</code>。  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class SuperTypeWildCards &#123;</span><br><span class="line">    static void writeTo(List&lt;? super Apple&gt; apples) &#123;</span><br><span class="line">        apples.add(new Apple());</span><br><span class="line">        apples.add(new Jonathan());</span><br><span class="line">        // apples.add(new Fruit()); // Error</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>无界通配符<br>无界通配符&lt;?&gt;意味着 “任何事物”，因此使用无界通配符好像等价于使用原生类型。事实上，编译器是支持这种判断的。  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class UnboundedWildcards1 &#123;</span><br><span class="line">    static List list1;</span><br><span class="line">    static List&lt;?&gt; list2;</span><br><span class="line">    static List&lt;? extends Object&gt; list3;</span><br><span class="line">    static void assign1(List list) &#123;</span><br><span class="line">        list1 = list;</span><br><span class="line">        list2 = list;</span><br><span class="line">        list3 = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void assign2(List&lt;?&gt; list) &#123;</span><br><span class="line">        list1 = list;</span><br><span class="line">        list2 = list;</span><br><span class="line">        list3 = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void assign3(List&lt;? extends Object&gt; list) &#123;</span><br><span class="line">        list1 = list;</span><br><span class="line">        list2 = list;</span><br><span class="line">        list3 = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        assign1(new ArrayList());</span><br><span class="line">        assign2(new ArrayList());</span><br><span class="line">        assign3(new ArrayList());</span><br><span class="line">        assign1(new ArrayList&lt;String&gt;());</span><br><span class="line">        assign2(new ArrayList&lt;String&gt;());</span><br><span class="line">        assign3(new ArrayList&lt;String&gt;());</span><br><span class="line"></span><br><span class="line">        List&lt;?&gt; wildList = new ArrayList();</span><br><span class="line">        wildList = new ArrayList&lt;String&gt;();</span><br><span class="line">        assign1(wildList);</span><br><span class="line">        assign2(wildList);</span><br><span class="line">        assign3(wildList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ul>
<li>任何基本类型不能用作类型参数，不如不能创建 <code>ArrayList&lt;Integer&gt;</code>  </li>
<li><p>一个类不能实现同一个泛型接口的两种变体<br>下面的写法会产生冲突：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Payable&lt;T&gt; &#123;&#125;</span><br><span class="line">class Employee implements Payable&lt;Employee&gt; &#123;&#125;</span><br><span class="line">class Hourly extends Employee implements Payable&lt;Hourly&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>转型和警告<br>使用带有泛型类型参数的转型或instanceof不会有任何效果。  </p>
</li>
<li>重载<br>由于擦除的原因，重载方法将产生相同的类型签名。  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class UseList&lt;W, T&gt; &#123;</span><br><span class="line">    void f(List&lt;T&gt; v) &#123;&#125;;</span><br><span class="line">    void f(List&lt;W&gt; v) &#123;&#125;;//两种方法签名一样</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>自限定的类型<br><code>class SelfBounded&lt;T extends SelfBounded&lt;T&gt;&gt; {</code> SelfBounded类接受泛型参数T，而T由一个边界类限定，这个边界就是拥有T作为其参数的SelfBounded。<br>它强调的是当extends关键字用于边界与用来创建子类明显是不同的。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
      
      
      
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编程思想/">编程思想</a></li></ul>

      

    </footer>
  </div>
  
</article>

<!-- Table of Contents -->


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/">下一页 &raquo;</a>
  </nav>

</section>
        
      </div>
      
        <div align="center" style="margin-top: 30px;"><hr class="hr" style="margin:0px; height:3px;"></div>
      
      <footer id="footer">
  

  <div class="container">
      	<div class="row">
	      <p> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a><!-- and <a href="https://github.com/iTimeTraveler/hexo-theme-hiker" target="_blank">Hexo-theme-hiker</a> --> </p>
	      <p id="copyRightEn">Copyright &copy; 2013 - 2018 alvin&#39;s blog All Rights Reserved.</p>
	      
	      
    		<p class="busuanzi_uv">
				访客数 : <span id="busuanzi_value_site_uv"></span> |  
				访问量 : <span id="busuanzi_value_site_pv"></span>
		    </p>
  		   
		</div>

		
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");
    var allheader = document.getElementById("allheader");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    if (allheader != null) {
      contentdiv.style.minHeight = document.body.offsetHeight - allheader.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    } else {
      contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    }
</script>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/scripts.js"></script>


  <script src="/js/home.js"></script>










	<div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="myModalLabel">设置</h2>
      </div>
      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">


      <div class="modal-body">
          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" onclick="javascript:setFontSize();" aria-expanded="true" aria-controls="collapseOne">
              正文字号大小
            </a>
          </div>
          <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
          <div class="panel-body">
            您已调整页面字体大小
          </div>
        </div>
      


          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" onclick="javascript:setBackground();" aria-expanded="true" aria-controls="collapseTwo">
              夜间护眼模式
            </a>
        </div>
          <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
          <div class="panel-body">
            夜间模式已经开启，再次单击按钮即可关闭 
          </div>
        </div>

        <div>
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="true" aria-controls="collapseThree">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关 于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
        </div>
         <div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
          <div class="panel-body">
            alvin&#39;s blog
          </div>
          <div class="panel-body">
            Copyright © 2018 alvin dong All Rights Reserved.
          </div>
        </div>
      </div>


      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <div class="modal-footer">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
      </div>
    </div>
  </div>
</div>
  
  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
  
</body>
</html>